{
  "version": 3,
  "sources": ["../../node_modules/fast-decode-uri-component/index.js", "../../node_modules/memoirist/dist/bun/index.js", "../../src/sucrose.ts", "../../src/error.ts", "../../src/utils.ts", "../../src/type-system.ts", "../../src/formats.ts", "../../node_modules/cookie/index.js", "../../src/cookies.ts", "../../src/handler.ts", "../../src/ws/index.ts", "../../src/compose.ts", "../../src/fast-querystring.ts", "../../src/trace.ts", "../../src/dynamic-handle.ts", "../../src/index.ts"],
  "sourcesContent": [
    "'use strict'\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n",
    "// @bun\nvar U=(z,q)=>{const v=q?.length?{}:null;if(v)for(let K of q)v[K.part.charCodeAt(0)]=K;return{part:z,store:null,inert:v,params:null,wildcardStore:null}},_=(z,q)=>({...z,part:q}),$=(z)=>({name:z,store:null,inert:null});class Y{root={};history=[];static regex={static:/:.+?(?=\\/|$)/,params:/:.+?(?=\\/|$)/g,optionalParams:/:.+?\\?(?=\\/|$)/g};add(z,q,v,{ignoreError:K=!1,ignoreHistory:V=!1}={}){if(typeof q!==\"string\")throw new TypeError(\"Route path must be a string\");if(q===\"\")q=\"/\";else if(q[0]!==\"/\")q=`/${q}`;const S=q[q.length-1]===\"*\",D=q.match(Y.regex.optionalParams);if(D){const F=q.replaceAll(\"?\",\"\");this.add(z,F,v,{ignoreError:K});for(let B=0;B<D.length;B++){let A=q.replace(\"/\"+D[B],\"\");this.add(z,A,v,{ignoreError:!0})}return v}if(D)q=q.replaceAll(\"?\",\"\");if(this.history.find(([F,B,A])=>F===z&&B===q))return v;if(S||D&&q.charCodeAt(q.length-1)===63)q=q.slice(0,-1);if(!V)this.history.push([z,q,v]);const G=q.split(Y.regex.static),J=q.match(Y.regex.params)||[];if(G[G.length-1]===\"\")G.pop();let b;if(!this.root[z])b=this.root[z]=U(\"/\");else b=this.root[z];let Q=0;for(let F=0;F<G.length;++F){let B=G[F];if(F>0){const A=J[Q++].slice(1);if(b.params===null)b.params=$(A);else if(b.params.name!==A)if(K)return v;else throw new Error(`Cannot create route \"${q}\" with parameter \"${A}\" `+\"because a route already exists with a different parameter name \"+`(\"${b.params.name}\") in the same location`);const O=b.params;if(O.inert===null){b=O.inert=U(B);continue}b=O.inert}for(let A=0;;){if(A===B.length){if(A<b.part.length){const O=_(b,b.part.slice(A));Object.assign(b,U(B,[O]))}break}if(A===b.part.length){if(b.inert===null)b.inert={};const O=b.inert[B.charCodeAt(A)];if(O){b=O,B=B.slice(A),A=0;continue}const X=U(B.slice(A));b.inert[B.charCodeAt(A)]=X,b=X;break}if(B[A]!==b.part[A]){const O=_(b,b.part.slice(A)),X=U(B.slice(A));Object.assign(b,U(b.part.slice(0,A),[O,X])),b=X;break}++A}}if(Q<J.length){const B=J[Q].slice(1);if(b.params===null)b.params=$(B);else if(b.params.name!==B)if(K)return v;else throw new Error(`Cannot create route \"${q}\" with parameter \"${B}\" `+\"because a route already exists with a different parameter name \"+`(\"${b.params.name}\") in the same location`);if(b.params.store===null)b.params.store=v;return b.params.store}if(S){if(b.wildcardStore===null)b.wildcardStore=v;return b.wildcardStore}if(b.store===null)b.store=v;return b.store}find(z,q){const v=this.root[z];if(!v)return null;return Z(q,q.length,v,0)}}var Z=(z,q,v,K)=>{const V=v.part,S=V.length,D=K+S;if(S>1){if(D>q)return null;if(S<15){for(let G=1,J=K+1;G<S;++G,++J)if(V.charCodeAt(G)!==z.charCodeAt(J))return null}else if(z.slice(K,D)!==V)return null}if(D===q){if(v.store!==null)return{store:v.store,params:{}};if(v.wildcardStore!==null)return{store:v.wildcardStore,params:{\"*\":\"\"}};return null}if(v.inert!==null){const G=v.inert[z.charCodeAt(D)];if(G!==void 0){const J=Z(z,q,G,D);if(J!==null)return J}}if(v.params!==null){const{store:G,name:J,inert:b}=v.params,Q=z.indexOf(\"/\",D);if(Q!==D){if(Q===-1||Q>=q){if(G!==null){const F={};return F[J]=z.substring(D,q),{store:G,params:F}}}else if(b!==null){const F=Z(z,q,b,Q);if(F!==null)return F.params[J]=z.substring(D,Q),F}}}if(v.wildcardStore!==null)return{store:v.wildcardStore,params:{\"*\":z.substring(D,q)}};return null},T=Y;export{T as default,Y as Memoirist};\n\n//# debugId=1E61A6F427AA7FBE64756e2164756e21\n",
    "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-constant-condition */\nimport type { Handler, HookContainer, LifeCycleStore } from './types'\n\nexport namespace Sucrose {\n\texport interface Inference {\n\t\tquery: boolean\n\t\theaders: boolean\n\t\tbody: boolean\n\t\tcookie: boolean\n\t\tset: boolean\n\t\tserver: boolean\n\t}\n\n\texport interface LifeCycle extends Partial<LifeCycleStore> {\n\t\thandler?: Handler\n\t}\n}\n\nexport const hasReturn = (fn: string | HookContainer<any> | Function) => {\n\tconst fnLiteral =\n\t\ttypeof fn === 'object'\n\t\t\t? fn.fn.toString()\n\t\t\t: typeof fn === 'string'\n\t\t\t\t? fn.toString()\n\t\t\t\t: fn\n\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\treturn true\n\t}\n\n\treturn fnLiteral.includes('return')\n}\n\n/**\n * Separate stringified function body and paramter\n *\n * @example\n * ```typescript\n * separateFunction('async ({ hello }) => { return hello }') // => ['({ hello })', '{ return hello }']\n * ```\n */\nexport const separateFunction = (\n\tcode: string\n): [string, string, { isArrowReturn: boolean }] => {\n\tif (code.startsWith('async')) code = code.slice(6)\n\n\tlet index = -1\n\n\t// Starts with '(', is an arrow function\n\tif (code.charCodeAt(0) === 40) {\n\t\tindex = code.indexOf('=>', code.indexOf(')'))\n\n\t\tif (index !== -1) {\n\t\t\tlet bracketEndIndex = index\n\t\t\t// Walk back to find bracket end\n\t\t\twhile (bracketEndIndex > 0)\n\t\t\t\tif (code.charCodeAt(--bracketEndIndex) === 41) break\n\n\t\t\tlet body = code.slice(index + 2)\n\t\t\tif (body.charCodeAt(0) === 32) body = body.trimLeft()\n\n\t\t\treturn [\n\t\t\t\tcode.slice(1, bracketEndIndex),\n\t\t\t\tbody,\n\t\t\t\t{\n\t\t\t\t\tisArrowReturn: body.charCodeAt(0) !== 123\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t}\n\n\t// Using function keyword\n\tif (code.startsWith('function')) {\n\t\tindex = code.indexOf('(')\n\t\tconst end = code.indexOf(')')\n\n\t\treturn [\n\t\t\tcode.slice(index + 1, end),\n\t\t\tcode.slice(end + 2),\n\t\t\t{\n\t\t\t\tisArrowReturn: false\n\t\t\t}\n\t\t]\n\t}\n\n\t// Probably Declare as method\n\tconst start = code.indexOf('(')\n\n\tif (start !== -1) {\n\t\tconst sep = code.indexOf('\\n', 2)\n\t\tconst parameter = code.slice(0, sep)\n\t\tconst end = parameter.lastIndexOf(')') + 1\n\n\t\tconst body = code.slice(sep + 1)\n\n\t\treturn [\n\t\t\tparameter.slice(start, end),\n\t\t\t'{' + body,\n\t\t\t{\n\t\t\t\tisArrowReturn: false\n\t\t\t}\n\t\t]\n\t}\n\n\t// Unknown case\n\tconst x = code.split('\\n', 2)\n\n\treturn [x[0], x[1], { isArrowReturn: false }]\n}\n\n/**\n * Get range between bracket pair\n *\n * @example\n * ```typescript\n * bracketPairRange('hello: { world: { a } }, elysia') // [6, 20]\n * ```\n */\nexport const bracketPairRange = (parameter: string): [number, number] => {\n\tconst start = parameter.indexOf('{')\n\tif (start === -1) return [-1, 0]\n\n\tlet end = start + 1\n\tlet deep = 1\n\n\tfor (; end < parameter.length; end++) {\n\t\tconst char = parameter.charCodeAt(end)\n\n\t\t// Open bracket\n\t\tif (char === 123) deep++\n\t\t// Close bracket\n\t\telse if (char === 125) deep--\n\n\t\tif (deep === 0) break\n\t}\n\n\tif (deep !== 0) return [0, parameter.length]\n\n\treturn [start, end + 1]\n}\n\n/**\n * Similar to `bracketPairRange` but in reverse order\n * Get range between bracket pair from end to beginning\n *\n * @example\n * ```typescript\n * bracketPairRange('hello: { world: { a } }, elysia') // [6, 20]\n * ```\n */\nexport const bracketPairRangeReverse = (\n\tparameter: string\n): [number, number] => {\n\tconst end = parameter.lastIndexOf('}')\n\tif (end === -1) return [-1, 0]\n\n\tlet start = end - 1\n\tlet deep = 1\n\n\tfor (; start >= 0; start--) {\n\t\tconst char = parameter.charCodeAt(start)\n\n\t\t// Open bracket\n\t\tif (char === 125) deep++\n\t\t// Close bracket\n\t\telse if (char === 123) deep--\n\n\t\tif (deep === 0) break\n\t}\n\n\tif (deep !== 0) return [-1, 0]\n\n\treturn [start, end + 1]\n}\n\nconst removeColonAlias = (parameter: string) => {\n\twhile (true) {\n\t\tconst start = parameter.indexOf(':')\n\t\tif (start === -1) break\n\n\t\tlet end = parameter.indexOf(',', start)\n\t\tif (end === -1) end = parameter.indexOf('}', start) - 1\n\t\tif (end === 0) end = parameter.length\n\n\t\tparameter = parameter.slice(0, start) + parameter.slice(end)\n\t}\n\n\treturn parameter\n}\n\n/**\n * Retrieve only root paramters of a function\n *\n * @example\n * ```typescript\n * retrieveRootParameters('({ hello: { world: { a } }, elysia })') // => {\n *   parameters: ['hello', 'elysia'],\n *   hasParenthesis: true\n * }\n * ```\n */\nexport const retrieveRootParamters = (parameter: string) => {\n\tlet hasParenthesis = false\n\n\t// Remove () from parameter\n\tif (parameter.charCodeAt(0) === 40) parameter = parameter.slice(1, -1)\n\n\t// Remove {} from parameter\n\tif (parameter.charCodeAt(0) === 123) {\n\t\thasParenthesis = true\n\t\tparameter = parameter.slice(1, -1)\n\t}\n\n\tparameter = parameter.replace(/( |\\t|\\n)/g, '').trim()\n\tlet parameters = <string[]>[]\n\n\t// Object destructuring\n\twhile (true) {\n\t\t// eslint-disable-next-line prefer-const\n\t\tlet [start, end] = bracketPairRange(parameter)\n\t\tif (start === -1) break\n\n\t\t// Remove colon from object structuring cast\n\t\tparameters.push(parameter.slice(0, start - 1))\n\t\tif (parameter.charCodeAt(end) === 44) end++\n\t\tparameter = parameter.slice(end)\n\t}\n\n\tparameter = removeColonAlias(parameter)\n\n\tif (parameter) parameters = parameters.concat(parameter.split(','))\n\n\treturn {\n\t\thasParenthesis,\n\t\tparameters\n\t}\n}\n\n/**\n * Find inference from parameter\n *\n * @param parameter stringified parameter\n */\nexport const findParameterReference = (\n\tparameter: string,\n\tinference: Sucrose.Inference\n) => {\n\tconst { parameters, hasParenthesis } = retrieveRootParamters(parameter)\n\n\t// Check if root is an object destructuring\n\tif (!inference.query && parameters.includes('query')) inference.query = true\n\tif (!inference.headers && parameters.includes('headers'))\n\t\tinference.headers = true\n\tif (!inference.body && parameters.includes('body')) inference.body = true\n\tif (!inference.cookie && parameters.includes('cookie'))\n\t\tinference.cookie = true\n\tif (!inference.set && parameters.includes('set')) inference.set = true\n\tif (!inference.server && parameters.includes('server'))\n\t\tinference.server = true\n\n\tif (hasParenthesis) return `{ ${parameters.join(', ')} }`\n\n\treturn parameters.join(', ')\n}\n\nconst findEndIndex = (\n\ttype: string,\n\tcontent: string,\n\tindex?: number | undefined\n) => {\n\tconst newLineIndex = content.indexOf(type + '\\n', index)\n\tconst newTabIndex = content.indexOf(type + '\\t', index)\n\tconst commaIndex = content.indexOf(type + ',', index)\n\tconst semicolonIndex = content.indexOf(type + ';', index)\n\tconst emptyIndex = content.indexOf(type + ' ', index)\n\n\t// Pick the smallest index that is not -1 or 0\n\treturn (\n\t\t[newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex]\n\t\t\t.filter((i) => i > 0)\n\t\t\t.sort((a, b) => a - b)[0] || -1\n\t)\n}\n\nconst findEndQueryBracketIndex = (\n\ttype: string,\n\tcontent: string,\n\tindex?: number | undefined\n) => {\n\tconst bracketEndIndex = content.indexOf(type + ']', index)\n\tconst singleQuoteIndex = content.indexOf(type + \"'\", index)\n\tconst doubleQuoteIndex = content.indexOf(type + '\"', index)\n\n\t// Pick the smallest index that is not -1 or 0\n\treturn (\n\t\t[bracketEndIndex, singleQuoteIndex, doubleQuoteIndex]\n\t\t\t.filter((i) => i > 0)\n\t\t\t.sort((a, b) => a - b)[0] || -1\n\t)\n}\n\n/**\n * Find alias of variable from function body\n *\n * @example\n * ```typescript\n * findAlias('body', '{ const a = body, b = body }') // => ['a', 'b']\n * ```\n */\nexport const findAlias = (type: string, body: string, depth = 0) => {\n\tif (depth > 5) return []\n\n\tconst aliases: string[] = []\n\n\tlet content = body\n\n\twhile (true) {\n\t\tlet index = findEndIndex(' = ' + type, content)\n\n\t\tif (index === -1) {\n\t\t\t/**\n\t\t\t * Check if pattern is at the end of the string\n\t\t\t *\n\t\t\t * @example\n\t\t\t * ```typescript\n\t\t\t * 'const a = body' // true\n\t\t\t * ```\n\t\t\t **/\n\t\t\tconst lastIndex = content.indexOf(' = ' + type)\n\n\t\t\tif (lastIndex + 3 + type.length !== content.length) break\n\n\t\t\tindex = lastIndex\n\t\t}\n\n\t\tconst part = content.slice(0, index)\n\t\t/**\n\t\t * aliased variable last character\n\t\t *\n\t\t * @example\n\t\t * ```typescript\n\t\t * const { hello } = body // } is the last character\n\t\t * ```\n\t\t **/\n\t\tlet variable = part.slice(part.lastIndexOf(' ') + 1)\n\n\t\t// Variable is using object destructuring, find the bracket pair\n\t\tif (variable === '}') {\n\t\t\tconst [start, end] = bracketPairRangeReverse(part)\n\n\t\t\taliases.push(removeColonAlias(content.slice(start, end)))\n\n\t\t\tcontent = content.slice(index + 3 + type.length)\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Remove comma\n\t\twhile (variable.charCodeAt(0) === 44) variable = variable.slice(1)\n\t\twhile (variable.charCodeAt(0) === 9) variable = variable.slice(1)\n\n\t\tif (!variable.includes('(')) aliases.push(variable)\n\n\t\tcontent = content.slice(index + 3 + type.length)\n\t}\n\n\tfor (const alias of aliases) {\n\t\tif (alias.charCodeAt(0) === 123) continue\n\n\t\tconst deepAlias = findAlias(alias, body)\n\t\tif (deepAlias.length > 0) aliases.push(...deepAlias)\n\t}\n\n\treturn aliases\n}\n\n// ? This is normalized to dot notation in Bun\n// const accessor = <T extends string, P extends string>(parent: T, prop: P) =>\n// \t[\n// \t\tparent + '.' + prop,\n// \t\tparent + '[\"' + prop + '\"]',\n// \t\tparent + \"['\" + prop + \"']\"\n// \t] as const\n\nexport const extractMainParameter = (parameter: string) => {\n\tif (!parameter) return\n\n\tif (parameter.charCodeAt(0) !== 123) return parameter\n\n\tparameter = parameter.slice(2, -2)\n\n\tconst hasComma = parameter.includes(',')\n\tif (!hasComma) {\n\t\t// This happens when spread operator is used as the only parameter\n\t\tif (parameter.includes('...'))\n\t\t\treturn parameter.slice(parameter.indexOf('...') + 3)\n\n\t\treturn\n\t}\n\n\tconst spreadIndex = parameter.indexOf('...')\n\tif (spreadIndex === -1) return\n\n\t// Spread parameter is always the last parameter, no need for further checking\n\treturn parameter.slice(spreadIndex + 3).trimEnd()\n}\n\n/**\n * Analyze if context is mentioned in body\n */\nexport const inferBodyReference = (\n\tcode: string,\n\taliases: string[],\n\tinference: Sucrose.Inference\n) => {\n\tconst access = (type: string, alias: string) =>\n\t\tcode.includes(alias + '.' + type) ||\n\t\tcode.includes(alias + '[\"' + type + '\"]') ||\n\t\tcode.includes(alias + \"['\" + type + \"']\")\n\n\tfor (const alias of aliases) {\n\t\tif (!alias) continue\n\n\t\t// Scan object destructured property\n\t\tif (alias.charCodeAt(0) === 123) {\n\t\t\tconst parameters = retrieveRootParamters(alias).parameters\n\n\t\t\tif (!inference.query && parameters.includes('query'))\n\t\t\t\tinference.query = true\n\n\t\t\tif (!inference.headers && parameters.includes('headers'))\n\t\t\t\tinference.headers = true\n\n\t\t\tif (!inference.body && parameters.includes('body'))\n\t\t\t\tinference.body = true\n\n\t\t\tif (!inference.cookie && parameters.includes('cookie'))\n\t\t\t\tinference.cookie = true\n\n\t\t\tif (!inference.set && parameters.includes('set'))\n\t\t\t\tinference.set = true\n\n\t\t\tif (!inference.query && parameters.includes('server'))\n\t\t\t\tinference.server = true\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (!inference.query && access('query', alias)) inference.query = true\n\n\t\tif (\n\t\t\tcode.includes('return ' + alias) ||\n\t\t\tcode.includes('return ' + alias + '.query')\n\t\t)\n\t\t\tinference.query = true\n\n\t\tif (!inference.headers && access('headers', alias))\n\t\t\tinference.headers = true\n\n\t\tif (!inference.body && access('body', alias)) inference.body = true\n\n\t\tif (!inference.cookie && access('cookie', alias))\n\t\t\tinference.cookie = true\n\n\t\tif (!inference.set && access('set', alias)) inference.set = true\n\t\tif (!inference.server && access('server', alias))\n\t\t\tinference.server = true\n\n\t\tif (\n\t\t\tinference.query &&\n\t\t\tinference.headers &&\n\t\t\tinference.body &&\n\t\t\tinference.cookie &&\n\t\t\tinference.set &&\n\t\t\tinference.server\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn aliases\n}\n\nexport const removeDefaultParameter = (parameter: string) => {\n\twhile (true) {\n\t\tconst index = parameter.indexOf('=')\n\t\tif (index === -1) break\n\n\t\tconst commaIndex = parameter.indexOf(',', index)\n\t\tconst bracketIndex = parameter.indexOf('}', index)\n\n\t\tconst end =\n\t\t\t[commaIndex, bracketIndex]\n\t\t\t\t.filter((i) => i > 0)\n\t\t\t\t.sort((a, b) => a - b)[0] || -1\n\n\t\tif (end === -1) {\n\t\t\tparameter = parameter.slice(0, index)\n\n\t\t\tbreak\n\t\t}\n\n\t\tparameter = parameter.slice(0, index) + parameter.slice(end)\n\t}\n\n\treturn parameter\n\t\t.split(',')\n\t\t.map((i) => i.trim())\n\t\t.join(', ')\n}\n\nconst isContextPassToFunction = (\n\tcontext: string,\n\tbody: string,\n\tinference: Sucrose.Inference\n) => {\n\t// ! Function is passed to another function, assume as all is accessed\n\ttry {\n\t\tconst captureFunction = new RegExp(`(?:\\\\w)\\\\((?:.*)?${context}`, 'gs')\n\t\tcaptureFunction.test(body)\n\n\t\t/*\n\t\tSince JavaScript engine already format the code (removing whitespace, newline, etc.),\n\t\twe can safely assume that the next character is either a closing bracket or a comma\n\t\tif the function is passed to another function\n\t\t*/\n\t\tconst nextChar = body.charCodeAt(captureFunction.lastIndex)\n\n\t\tif (nextChar === 41 || nextChar === 44) {\n\t\t\tinference.query = true\n\t\t\tinference.headers = true\n\t\t\tinference.body = true\n\t\t\tinference.cookie = true\n\t\t\tinference.set = true\n\t\t\tinference.server = true\n\n\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t} catch (error) {\n\t\tconsole.log(\n\t\t\t'[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to the developer:'\n\t\t)\n\t\tconsole.log('--- body ---')\n\t\tconsole.log(body)\n\t\tconsole.log('--- context ---')\n\t\tconsole.log(context)\n\n\t\treturn true\n\t}\n}\n\nexport const sucrose = (\n\tlifeCycle: Sucrose.LifeCycle,\n\tinference: Sucrose.Inference = {\n\t\tquery: false,\n\t\theaders: false,\n\t\tbody: false,\n\t\tcookie: false,\n\t\tset: false,\n\t\tserver: false\n\t}\n): Sucrose.Inference => {\n\tconst events = []\n\n\tif (lifeCycle.handler && typeof lifeCycle.handler === 'function')\n\t\tevents.push(lifeCycle.handler)\n\n\tif (lifeCycle.request?.length) events.push(...lifeCycle.request)\n\tif (lifeCycle.beforeHandle?.length) events.push(...lifeCycle.beforeHandle)\n\tif (lifeCycle.parse?.length) events.push(...lifeCycle.parse)\n\tif (lifeCycle.error?.length) events.push(...lifeCycle.error)\n\tif (lifeCycle.transform?.length) events.push(...lifeCycle.transform)\n\tif (lifeCycle.afterHandle?.length) events.push(...lifeCycle.afterHandle)\n\tif (lifeCycle.mapResponse?.length) events.push(...lifeCycle.mapResponse)\n\tif (lifeCycle.afterResponse?.length) events.push(...lifeCycle.afterResponse)\n\n\tfor (const e of events) {\n\t\tif (!e) continue\n\n\t\tconst event = 'fn' in e ? e.fn : e\n\n\t\tconst [parameter, body, { isArrowReturn }] = separateFunction(\n\t\t\tevent.toString()\n\t\t)\n\n\t\tconst rootParameters = findParameterReference(parameter, inference)\n\t\tconst mainParameter = extractMainParameter(rootParameters)\n\n\t\tif (mainParameter) {\n\t\t\tconst aliases = findAlias(mainParameter, body)\n\t\t\taliases.splice(0, -1, mainParameter)\n\n\t\t\tif (!isContextPassToFunction(mainParameter, body, inference))\n\t\t\t\tinferBodyReference(body, aliases, inference)\n\n\t\t\tif (\n\t\t\t\t!inference.query &&\n\t\t\t\tbody.includes('return ' + mainParameter + '.query')\n\t\t\t)\n\t\t\t\tinference.query = true\n\t\t}\n\n\t\tif (\n\t\t\tinference.query &&\n\t\t\tinference.headers &&\n\t\t\tinference.body &&\n\t\t\tinference.cookie &&\n\t\t\tinference.set &&\n\t\t\tinference.server\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn inference\n}\n",
    "import type { TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport type { TypeCheck, ValueError } from '@sinclair/typebox/compiler'\n\nimport { StatusMap, InvertedStatusMap } from './utils'\n\n// ? Cloudflare worker support\nconst env =\n\ttypeof Bun !== 'undefined'\n\t\t? Bun.env\n\t\t: typeof process !== 'undefined'\n\t\t\t? process?.env\n\t\t\t: undefined\n\nexport const ERROR_CODE = Symbol('ElysiaErrorCode')\nexport type ERROR_CODE = typeof ERROR_CODE\n\nexport const ELYSIA_RESPONSE = Symbol('ElysiaResponse')\nexport type ELYSIA_RESPONSE = typeof ELYSIA_RESPONSE\n\nexport const isProduction = (env?.NODE_ENV ?? env?.ENV) === 'production'\n\nexport type ElysiaErrors =\n\t| InternalServerError\n\t| NotFoundError\n\t| ParseError\n\t| ValidationError\n\t| InvalidCookieSignature\n\nexport const error = <\n\tconst Code extends number | keyof StatusMap,\n\tconst T = Code extends keyof InvertedStatusMap\n\t\t? InvertedStatusMap[Code]\n\t\t: Code,\n\tconst Status extends Code extends keyof StatusMap\n\t\t? StatusMap[Code]\n\t\t: Code = Code extends keyof StatusMap ? StatusMap[Code] : Code\n>(\n\tcode: Code,\n\tresponse?: T\n): {\n\t[ELYSIA_RESPONSE]: Status\n\tresponse: T\n\t_type: {\n\t\t[ERROR_CODE in Status]: T\n\t}\n\terror: Error\n} => {\n\tconst res = response ??\n\t\t(code in InvertedStatusMap\n\t\t\t? // @ts-expect-error Always correct\n\t\t\t\tInvertedStatusMap[code]\n\t\t\t: code)\n\n\treturn {\n\t\t// @ts-expect-error trust me bro\n\t\t[ELYSIA_RESPONSE]: StatusMap[code] ?? code,\n\t\tresponse: res,\n\t\t_type: undefined as any,\n\t\terror: new Error(res)\n\t} as const\n}\n\nexport class InternalServerError extends Error {\n\tcode = 'INTERNAL_SERVER_ERROR'\n\tstatus = 500\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'INTERNAL_SERVER_ERROR')\n\t}\n}\n\nexport class NotFoundError extends Error {\n\tcode = 'NOT_FOUND'\n\tstatus = 404\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'NOT_FOUND')\n\t}\n}\n\nexport class ParseError extends Error {\n\tcode = 'PARSE'\n\tstatus = 400\n\n\tconstructor() {\n\t\tsuper('Failed to parse body')\n\t}\n}\n\nexport class InvalidCookieSignature extends Error {\n\tcode = 'INVALID_COOKIE_SIGNATURE'\n\tstatus = 400\n\n\tconstructor(\n\t\tpublic key: string,\n\t\tmessage?: string\n\t) {\n\t\tsuper(message ?? `\"${key}\" has invalid cookie signature`)\n\t}\n}\n\nexport const mapValueError = (error: ValueError) => {\n\tconst { message, path, value, type } = error\n\n\tconst property = path.slice(1).replaceAll('/', '.')\n\tconst isRoot = path === ''\n\n\tswitch (type) {\n\t\tcase 42:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should not be provided`\n\t\t\t\t\t: `Property '${property}' should not be provided`\n\t\t\t}\n\n\t\tcase 45:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value is missing`\n\t\t\t\t\t: `Property '${property}' is missing`\n\t\t\t}\n\n\t\tcase 50:\n\t\t\t// Expected string to match 'email' format\n\t\t\tconst quoteIndex = message.indexOf(\"'\")!\n\t\t\tconst format = message.slice(\n\t\t\t\tquoteIndex + 1,\n\t\t\t\tmessage.indexOf(\"'\", quoteIndex + 1)\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should be an email`\n\t\t\t\t\t: `Property '${property}' should be ${format}`\n\t\t\t}\n\n\t\tcase 54:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: `${message.slice(\n\t\t\t\t\t0,\n\t\t\t\t\t9\n\t\t\t\t)} property '${property}' to be ${message.slice(\n\t\t\t\t\t8\n\t\t\t\t)} but found: ${value}`\n\t\t\t}\n\n\t\tcase 62:\n\t\t\tconst union = error.schema.anyOf\n\t\t\t\t.map((x: Record<string, unknown>) => `'${x?.format ?? x.type}'`)\n\t\t\t\t.join(', ')\n\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should be one of ${union}`\n\t\t\t\t\t: `Property '${property}' should be one of: ${union}`\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn { summary: message, ...error }\n\t}\n}\n\nexport class ValidationError extends Error {\n\tcode = 'VALIDATION'\n\tstatus = 422\n\n\tconstructor(\n\t\tpublic type: string,\n\t\tpublic validator: TSchema | TypeCheck<any>,\n\t\tpublic value: unknown\n\t) {\n\t\tif (value && typeof value === 'object' && ELYSIA_RESPONSE in value)\n\t\t\t// @ts-expect-error\n\t\t\tvalue = value.response\n\n\t\tconst error = isProduction\n\t\t\t? undefined\n\t\t\t: 'Errors' in validator\n\t\t\t\t? validator.Errors(value).First()\n\t\t\t\t: Value.Errors(validator, value).First()\n\n\t\tconst customError =\n\t\t\terror?.schema.error !== undefined\n\t\t\t\t? typeof error.schema.error === 'function'\n\t\t\t\t\t? error.schema.error({\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\tvalidator,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tget errors() {\n\t\t\t\t\t\t\t\treturn [...validator.Errors(value)].map(\n\t\t\t\t\t\t\t\t\tmapValueError\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t: error.schema.error\n\t\t\t\t: undefined\n\n\t\tconst accessor = error?.path || 'root'\n\t\tlet message = ''\n\n\t\tif (customError !== undefined) {\n\t\t\tmessage =\n\t\t\t\ttypeof customError === 'object'\n\t\t\t\t\t? JSON.stringify(customError)\n\t\t\t\t\t: customError + ''\n\t\t} else if (isProduction) {\n\t\t\tmessage = JSON.stringify({\n\t\t\t\ttype: 'validation',\n\t\t\t\ton: type,\n\t\t\t\tsummary: mapValueError(error).summary,\n\t\t\t\tmessage: error?.message,\n\t\t\t\tfound: value\n\t\t\t})\n\t\t} else {\n\t\t\t// @ts-ignore private field\n\t\t\tconst schema = validator?.schema ?? validator\n\t\t\tconst errors =\n\t\t\t\t'Errors' in validator\n\t\t\t\t\t? [...validator.Errors(value)].map(mapValueError)\n\t\t\t\t\t: [...Value.Errors(validator, value)].map(mapValueError)\n\n\t\t\tlet expected\n\n\t\t\ttry {\n\t\t\t\texpected = Value.Create(schema)\n\t\t\t} catch (error) {\n\t\t\t\texpected = {\n\t\t\t\t\ttype: 'Could not create expected value',\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\terror\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = JSON.stringify(\n\t\t\t\t{\n\t\t\t\t\ttype: 'validation',\n\t\t\t\t\ton: type,\n\t\t\t\t\tsummary: errors[0]?.summary,\n\t\t\t\t\tproperty: accessor,\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\texpected,\n\t\t\t\t\tfound: value,\n\t\t\t\t\terrors\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\t2\n\t\t\t)\n\t\t}\n\n\t\tsuper(message)\n\n\t\tObject.setPrototypeOf(this, ValidationError.prototype)\n\t}\n\n\tget all() {\n\t\treturn 'Errors' in this.validator\n\t\t\t? [...this.validator.Errors(this.value)].map(mapValueError)\n\t\t\t: // @ts-ignore\n\t\t\t\t[...Value.Errors(this.validator, this.value)].map(mapValueError)\n\t}\n\n\tstatic simplifyModel(validator: TSchema | TypeCheck<any>) {\n\t\t// @ts-ignore\n\t\tconst model = 'schema' in validator ? validator.schema : validator\n\n\t\ttry {\n\t\t\treturn Value.Create(model)\n\t\t} catch {\n\t\t\treturn model\n\t\t}\n\t}\n\n\tget model() {\n\t\treturn ValidationError.simplifyModel(this.validator)\n\t}\n\n\ttoResponse(headers?: Record<string, any>) {\n\t\treturn new Response(this.message, {\n\t\t\tstatus: 400,\n\t\t\theaders: {\n\t\t\t\t...headers,\n\t\t\t\t'content-type': 'application/json'\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "import type { BunFile } from 'bun'\nimport { Kind, TransformKind, type TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport { t } from './type-system'\nimport { isNotEmpty } from './handler'\nimport type { Sucrose } from './sucrose'\n\nimport type { TraceHandler } from './trace'\nimport type {\n\tLifeCycleStore,\n\tLocalHook,\n\tMaybeArray,\n\tInputSchema,\n\tBaseMacro,\n\tLifeCycleType,\n\tHookContainer,\n\tGracefulHandler,\n\tPreHandler,\n\tBodyHandler,\n\tTransformHandler,\n\tOptionalHandler,\n\tAfterHandler,\n\tMapResponse,\n\tErrorHandler,\n\tReplace,\n\tAfterResponseHandler,\n\tSchemaValidator\n} from './types'\nimport type { CookieOptions } from './cookies'\nimport { mapValueError } from './error'\n\nexport const replaceUrlPath = (url: string, pathname: string) => {\n\tconst urlObject = new URL(url)\n\turlObject.pathname = pathname\n\treturn urlObject.toString()\n}\n\nexport const isClass = (v: Object) =>\n\t(typeof v === 'function' && /^\\s*class\\s+/.test(v.toString())) ||\n\t// Handle import * as Sentry from '@sentry/bun'\n\t// This also handle [object Date], [object Array]\n\t// and FFI value like [object Prisma]\n\t(v.toString().startsWith('[object ') &&\n\t\tv.toString() !== '[object Object]') ||\n\t// If object prototype is not pure, then probably a class-like object\n\tisNotEmpty(Object.getPrototypeOf(v))\n\nconst isObject = (item: any): item is Object =>\n\titem && typeof item === 'object' && !Array.isArray(item)\n\nexport const mergeDeep = <\n\tA extends Record<string, any>,\n\tB extends Record<string, any>\n>(\n\ttarget: A,\n\tsource: B,\n\t{\n\t\tskipKeys,\n\t\toverride = true\n\t}: {\n\t\tskipKeys?: string[]\n\t\toverride?: boolean\n\t} = {}\n): A & B => {\n\tif (!isObject(target) || !isObject(source)) return target as A & B\n\n\tfor (const [key, value] of Object.entries(source)) {\n\t\tif (skipKeys?.includes(key)) continue\n\n\t\tif (!isObject(value) || !(key in target) || isClass(value)) {\n\t\t\tif (override || !(key in target))\n\t\t\t\ttarget[key as keyof typeof target] = value\n\n\t\t\tcontinue\n\t\t}\n\n\t\ttarget[key as keyof typeof target] = mergeDeep(\n\t\t\t(target as any)[key] as any,\n\t\t\tvalue,\n\t\t\t{ skipKeys, override }\n\t\t)\n\t}\n\n\treturn target as A & B\n}\nexport const mergeCookie = <const A extends Object, const B extends Object>(\n\ta: A,\n\tb: B\n): A & B => {\n\t// @ts-ignore\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst { properties: _, ...target } = a ?? {}\n\n\t// @ts-ignore\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst { properties: __, ...source } = b ?? {}\n\n\treturn mergeDeep(target, source) as A & B\n}\n\nexport const mergeObjectArray = <T extends HookContainer>(\n\ta: T | T[] = [],\n\tb: T | T[] = []\n): T[] => {\n\tif (!a) return []\n\tif (!b) return a as any\n\n\t// ! Must copy to remove side-effect\n\tconst array = <T[]>[]\n\tconst checksums = <(number | undefined)[]>[]\n\n\tif (!Array.isArray(a)) a = [a]\n\tif (!Array.isArray(b)) b = [b]\n\n\tfor (const item of a) {\n\t\tarray.push(item)\n\n\t\tif (item.checksum) checksums.push(item.checksum)\n\t}\n\n\tfor (const item of b)\n\t\tif (!checksums.includes(item.checksum)) array.push(item)\n\n\treturn array\n}\n\nexport const primitiveHooks = [\n\t'start',\n\t'request',\n\t'parse',\n\t'transform',\n\t'resolve',\n\t'beforeHandle',\n\t'afterHandle',\n\t'mapResponse',\n\t'afterResponse',\n\t'trace',\n\t'error',\n\t'stop',\n\t'body',\n\t'headers',\n\t'params',\n\t'query',\n\t'response',\n\t'type',\n\t'detail'\n] as const\n\nconst primitiveHookMap = primitiveHooks.reduce(\n\t(acc, x) => ((acc[x] = true), acc),\n\t{} as Record<string, boolean>\n)\n\nexport const mergeResponse = (\n\ta: InputSchema['response'],\n\tb: InputSchema['response']\n) => {\n\t// If both are Record<number, ...> then merge them,\n\t// giving preference to b.\n\ttype RecordNumber = Record<number, any>\n\tconst isRecordNumber = (x: typeof a | typeof b): x is RecordNumber =>\n\t\ttypeof x === 'object' && Object.keys(x).every(isNumericString)\n\n\tif (isRecordNumber(a) && isRecordNumber(b))\n\t\treturn { ...(a as RecordNumber), ...(b as RecordNumber) }\n\n\treturn b ?? a\n}\n\nexport const mergeSchemaValidator = (\n\ta?: SchemaValidator | null,\n\tb?: SchemaValidator | null\n): SchemaValidator => {\n\treturn {\n\t\tbody: b?.body ?? a?.body,\n\t\theaders: b?.headers ?? a?.headers,\n\t\tparams: b?.params ?? a?.params,\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore ? This order is correct - SaltyAom\n\t\tresponse: mergeResponse(\n\t\t\t// @ts-ignore\n\t\t\ta?.response,\n\t\t\t// @ts-ignore\n\t\t\tb?.response\n\t\t)\n\t}\n}\n\nexport const mergeHook = (\n\ta?: LifeCycleStore,\n\tb?: LocalHook<any, any, any, any, any, any, any>\n\t// { allowMacro = false }: { allowMacro?: boolean } = {}\n): LifeCycleStore => {\n\t// In case if merging union is need\n\t// const customAStore: Record<string, unknown> = {}\n\t// const customBStore: Record<string, unknown> = {}\n\n\t// for (const [key, value] of Object.entries(a)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomAStore[key] = value\n\t// }\n\n\t// for (const [key, value] of Object.entries(b)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomBStore[key] = value\n\t// }\n\n\t// const unioned = Object.keys(customAStore).filter((x) =>\n\t// \tObject.keys(customBStore).includes(x)\n\t// )\n\n\t// // Must provide empty object to prevent reference side-effect\n\t// const customStore = Object.assign({}, customAStore, customBStore)\n\n\t// for (const union of unioned)\n\t// \tcustomStore[union] = mergeObjectArray(\n\t// \t\tcustomAStore[union],\n\t// \t\tcustomBStore[union]\n\t// \t)\n\n\treturn {\n\t\t...a,\n\t\t...b,\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// ? This order is correct - SaltyAom\n\t\tresponse: mergeResponse(\n\t\t\t// @ts-ignore\n\t\t\ta?.response,\n\t\t\t// @ts-ignore\n\t\t\tb?.response\n\t\t),\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray(a?.parse as any, b?.parse),\n\t\ttransform: mergeObjectArray(a?.transform, b?.transform),\n\t\tbeforeHandle: mergeObjectArray(a?.beforeHandle, b?.beforeHandle),\n\t\tafterHandle: mergeObjectArray(a?.afterHandle, b?.afterHandle),\n\t\tmapResponse: mergeObjectArray(a?.mapResponse, b?.mapResponse) as any,\n\t\tafterResponse: mergeObjectArray(\n\t\t\ta?.afterResponse,\n\t\t\tb?.afterResponse\n\t\t) as any,\n\t\ttrace: mergeObjectArray(a?.trace, b?.trace) as any,\n\t\terror: mergeObjectArray(a?.error, b?.error)\n\t}\n}\n\ninterface ReplaceSchemaTypeOptions {\n\tfrom: TSchema\n\tto(): TSchema\n\texcludeRoot?: boolean\n\t/**\n\t * Traverse until object is found except root object\n\t **/\n\tuntilObjectFound?: boolean\n}\n\nexport const replaceSchemaType = (\n\tschema: TSchema,\n\toptions: MaybeArray<ReplaceSchemaTypeOptions>,\n\troot = true\n) => {\n\tif (!Array.isArray(options))\n\t\treturn _replaceSchemaType(schema, options, root)\n\n\tfor (const option of options)\n\t\tschema = _replaceSchemaType(schema, option, root)\n\n\treturn schema\n}\n\nconst _replaceSchemaType = (\n\tschema: TSchema,\n\toptions: ReplaceSchemaTypeOptions,\n\troot = true\n) => {\n\tif (!schema) return schema\n\tif (options.untilObjectFound && !root && schema.type === 'object')\n\t\treturn schema\n\n\tconst fromSymbol = options.from[Kind]\n\n\tif (schema.oneOf) {\n\t\tfor (let i = 0; i < schema.oneOf.length; i++)\n\t\t\tschema.oneOf[i] = _replaceSchemaType(schema.oneOf[i], options, root)\n\n\t\treturn schema\n\t}\n\n\tif (schema.anyOf) {\n\t\tfor (let i = 0; i < schema.anyOf.length; i++)\n\t\t\tschema.anyOf[i] = _replaceSchemaType(schema.anyOf[i], options, root)\n\n\t\treturn schema\n\t}\n\n\tif (schema.allOf) {\n\t\tfor (let i = 0; i < schema.allOf.length; i++)\n\t\t\tschema.allOf[i] = _replaceSchemaType(schema.allOf[i], options, root)\n\n\t\treturn schema\n\t}\n\n\tif (schema.not) {\n\t\tfor (let i = 0; i < schema.not.length; i++)\n\t\t\tschema.not[i] = _replaceSchemaType(schema.not[i], options, root)\n\n\t\treturn schema\n\t}\n\n\tconst isRoot = root && !!options.excludeRoot\n\n\tif (schema[Kind] === fromSymbol) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tconst { anyOf, oneOf, allOf, not, properties, items, ...rest } = schema\n\t\tconst to = options.to()\n\n\t\t// If t.Transform is used, we need to re-calculate Encode, Decode\n\t\tlet transform\n\n\t\tconst composeProperties = (v: TSchema) => {\n\t\t\tif (properties && v.type === 'object') {\n\t\t\t\tconst newProperties = <Record<string, unknown>>{}\n\t\t\t\tfor (const [key, value] of Object.entries(properties))\n\t\t\t\t\tnewProperties[key] = _replaceSchemaType(\n\t\t\t\t\t\tvalue as TSchema,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\tfalse\n\t\t\t\t\t)\n\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\t...v,\n\t\t\t\t\tproperties: newProperties\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (items && v.type === 'array')\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\t...v,\n\t\t\t\t\titems: _replaceSchemaType(items, options, false)\n\t\t\t\t}\n\n\t\t\tconst value = {\n\t\t\t\t...rest,\n\t\t\t\t...v\n\t\t\t}\n\n\t\t\t// Remove required as it's not object\n\t\t\tdelete value['required']\n\n\t\t\t// Create default value for ObjectString\n\t\t\tif (\n\t\t\t\tproperties &&\n\t\t\t\tv.type === 'string' &&\n\t\t\t\tv.format === 'ObjectString' &&\n\t\t\t\tv.default === '{}'\n\t\t\t) {\n\t\t\t\ttransform = t.ObjectString(properties, rest)\n\t\t\t\tvalue.default = JSON.stringify(\n\t\t\t\t\tValue.Create(t.Object(properties))\n\t\t\t\t)\n\t\t\t\tvalue.properties = properties\n\t\t\t}\n\n\t\t\t// Create default value for ArrayString\n\t\t\tif (\n\t\t\t\titems &&\n\t\t\t\tv.type === 'string' &&\n\t\t\t\tv.format === 'ArrayString' &&\n\t\t\t\tv.default === '[]'\n\t\t\t) {\n\t\t\t\ttransform = t.ArrayString(items, rest)\n\t\t\t\tvalue.default = JSON.stringify(Value.Create(t.Array(items)))\n\t\t\t\tvalue.items = items\n\t\t\t}\n\n\t\t\treturn value\n\t\t}\n\n\t\tif (isRoot) {\n\t\t\tif (properties) {\n\t\t\t\tconst newProperties = <Record<string, unknown>>{}\n\t\t\t\tfor (const [key, value] of Object.entries(properties))\n\t\t\t\t\tnewProperties[key] = _replaceSchemaType(\n\t\t\t\t\t\tvalue as TSchema,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\tfalse\n\t\t\t\t\t)\n\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\tproperties: newProperties\n\t\t\t\t}\n\t\t\t} else if (items?.map)\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\titems: items.map((v: TSchema) =>\n\t\t\t\t\t\t_replaceSchemaType(v, options, false)\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\treturn rest\n\t\t}\n\n\t\tif (to.anyOf)\n\t\t\tfor (let i = 0; i < to.anyOf.length; i++)\n\t\t\t\tto.anyOf[i] = composeProperties(to.anyOf[i])\n\t\telse if (to.oneOf)\n\t\t\tfor (let i = 0; i < to.oneOf.length; i++)\n\t\t\t\tto.oneOf[i] = composeProperties(to.oneOf[i])\n\t\telse if (to.allOf)\n\t\t\tfor (let i = 0; i < to.allOf.length; i++)\n\t\t\t\tto.allOf[i] = composeProperties(to.allOf[i])\n\t\telse if (to.not)\n\t\t\tfor (let i = 0; i < to.not.length; i++)\n\t\t\t\tto.not[i] = composeProperties(to.not[i])\n\n\t\tif (transform) to[TransformKind as any] = transform[TransformKind]\n\n\t\tif (to.anyOf || to.oneOf || to.allOf || to.not) return to\n\n\t\tif (properties) {\n\t\t\tconst newProperties = <Record<string, unknown>>{}\n\t\t\tfor (const [key, value] of Object.entries(properties))\n\t\t\t\tnewProperties[key] = _replaceSchemaType(\n\t\t\t\t\tvalue as TSchema,\n\t\t\t\t\toptions,\n\t\t\t\t\tfalse\n\t\t\t\t)\n\n\t\t\treturn {\n\t\t\t\t...rest,\n\t\t\t\t...to,\n\t\t\t\tproperties: newProperties\n\t\t\t}\n\t\t} else if (items?.map)\n\t\t\treturn {\n\t\t\t\t...rest,\n\t\t\t\t...to,\n\t\t\t\titems: items.map((v: TSchema) =>\n\t\t\t\t\t_replaceSchemaType(v, options, false)\n\t\t\t\t)\n\t\t\t}\n\n\t\treturn {\n\t\t\t...rest,\n\t\t\t...to\n\t\t}\n\t}\n\n\tconst properties = schema?.properties as Record<string, TSchema>\n\n\tif (properties)\n\t\tfor (const [key, value] of Object.entries(properties)) {\n\t\t\tswitch (value[Kind]) {\n\t\t\t\tcase fromSymbol:\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\tconst { anyOf, oneOf, allOf, not, type, ...rest } = value\n\t\t\t\t\tconst to = options.to()\n\n\t\t\t\t\tif (to.anyOf)\n\t\t\t\t\t\tfor (let i = 0; i < to.anyOf.length; i++)\n\t\t\t\t\t\t\tto.anyOf[i] = { ...rest, ...to.anyOf[i] }\n\t\t\t\t\telse if (to.oneOf)\n\t\t\t\t\t\tfor (let i = 0; i < to.oneOf.length; i++)\n\t\t\t\t\t\t\tto.oneOf[i] = { ...rest, ...to.oneOf[i] }\n\t\t\t\t\telse if (to.allOf)\n\t\t\t\t\t\tfor (let i = 0; i < to.allOf.length; i++)\n\t\t\t\t\t\t\tto.allOf[i] = { ...rest, ...to.allOf[i] }\n\t\t\t\t\telse if (to.not)\n\t\t\t\t\t\tfor (let i = 0; i < to.not.length; i++)\n\t\t\t\t\t\t\tto.not[i] = { ...rest, ...to.not[i] }\n\n\t\t\t\t\tproperties[key] = {\n\t\t\t\t\t\t...rest,\n\t\t\t\t\t\t..._replaceSchemaType(rest, options, false)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'Object':\n\t\t\t\tcase 'Union':\n\t\t\t\t\tproperties[key] = _replaceSchemaType(value, options, false)\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (value.items)\n\t\t\t\t\t\tfor (let i = 0; i < value.items.length; i++) {\n\t\t\t\t\t\t\tvalue.items[i] = _replaceSchemaType(\n\t\t\t\t\t\t\t\tvalue.items[i],\n\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (\n\t\t\t\t\t\tvalue.anyOf ||\n\t\t\t\t\t\tvalue.oneOf ||\n\t\t\t\t\t\tvalue.allOf ||\n\t\t\t\t\t\tvalue.not\n\t\t\t\t\t)\n\t\t\t\t\t\tproperties[key] = _replaceSchemaType(\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\treturn schema\n}\n\nexport const getSchemaValidator = <T extends TSchema | string | undefined>(\n\ts: T,\n\t{\n\t\tmodels = {},\n\t\tdynamic = false,\n\t\tnormalize = false,\n\t\tadditionalProperties = false,\n\t\tcoerce = false,\n\t\tadditionalCoerce = []\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t\tnormalize?: boolean\n\t\tcoerce?: boolean\n\t\tadditionalCoerce?: MaybeArray<ReplaceSchemaTypeOptions>\n\t} = {}\n): T extends TSchema ? TypeCheck<TSchema> : undefined => {\n\tif (!s) return undefined as any\n\tif (typeof s === 'string' && !(s in models)) return undefined as any\n\n\tlet schema: TSchema = typeof s === 'string' ? models[s] : s\n\n\tif (coerce)\n\t\tschema = replaceSchemaType(schema, [\n\t\t\t{\n\t\t\t\tfrom: t.Number(),\n\t\t\t\tto: () => t.Numeric(),\n\t\t\t\tuntilObjectFound: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tfrom: t.Boolean(),\n\t\t\t\tto: () => t.BooleanString(),\n\t\t\t\tuntilObjectFound: true\n\t\t\t},\n\t\t\t...(Array.isArray(additionalCoerce)\n\t\t\t\t? additionalCoerce\n\t\t\t\t: [additionalCoerce])\n\t\t])\n\n\t// console.dir(schema, {\n\t// \tdepth: null\n\t// })\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tconst cleaner = (value: unknown) => Value.Clean(schema, value)\n\n\tif (dynamic) {\n\t\tconst validator = {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => '',\n\t\t\tClean: cleaner\n\t\t} as unknown as TypeCheck<TSchema>\n\n\t\tif (normalize && schema.additionalProperties === false)\n\t\t\t// @ts-ignore\n\t\t\tvalidator.Clean = cleaner\n\n\t\t// @ts-ignore\n\t\tif (schema.config) {\n\t\t\t// @ts-ignore\n\t\t\tvalidator.config = schema.config\n\n\t\t\t// @ts-ignore\n\t\t\tif (validator?.schema?.config)\n\t\t\t\t// @ts-ignore\n\t\t\t\tdelete validator.schema.config\n\t\t}\n\n\t\t// @ts-ignore\n\t\tvalidator.parse = (v) => {\n\t\t\ttry {\n\t\t\t\treturn validator.Decode(v)\n\t\t\t} catch (error) {\n\t\t\t\tthrow [...validator.Errors(v)].map(mapValueError)\n\t\t\t}\n\t\t}\n\n\t\t// @ts-ignore\n\t\tvalidator.safeParse = (v) => {\n\t\t\ttry {\n\t\t\t\treturn { success: true, data: validator.Decode(v), error: null }\n\t\t\t} catch (error) {\n\t\t\t\tconst errors = [...compiled.Errors(v)].map(mapValueError)\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tdata: null,\n\t\t\t\t\terror: errors[0]?.summary,\n\t\t\t\t\terrors\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn validator as any\n\t}\n\n\tconst compiled = TypeCompiler.Compile(schema, Object.values(models))\n\n\t// @ts-expect-error\n\tcompiled.Clean = cleaner\n\n\t// @ts-ignore\n\tif (schema.config) {\n\t\t// @ts-ignore\n\t\tcompiled.config = schema.config\n\n\t\t// @ts-ignore\n\t\tif (compiled?.schema?.config)\n\t\t\t// @ts-ignore\n\t\t\tdelete compiled.schema.config\n\t}\n\n\t// @ts-ignore\n\tcompiled.parse = (v) => {\n\t\ttry {\n\t\t\treturn compiled.Decode(v)\n\t\t} catch (error) {\n\t\t\tthrow [...compiled.Errors(v)].map(mapValueError)\n\t\t}\n\t}\n\n\t// @ts-ignore\n\tcompiled.safeParse = (v) => {\n\t\ttry {\n\t\t\treturn { success: true, data: compiled.Decode(v), error: null }\n\t\t} catch (error) {\n\t\t\tconst errors = [...compiled.Errors(v)].map(mapValueError)\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tdata: null,\n\t\t\t\terror: errors[0]?.summary,\n\t\t\t\terrors\n\t\t\t}\n\t\t}\n\t}\n\n\treturn compiled as any\n}\n\nexport const getResponseSchemaValidator = (\n\ts: InputSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tdynamic = false,\n\t\tnormalize = false,\n\t\tadditionalProperties = false\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t\tnormalize?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\tif (typeof s === 'string' && !(s in models)) return\n\n\tconst maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s\n\n\tconst compile = (schema: TSchema, references?: TSchema[]) => {\n\t\t// eslint-disable-next-line sonarjs/no-identical-functions\n\t\t// Sonar being delulu, schema is not identical\n\t\tconst cleaner = (value: unknown) => Value.Clean(schema, value)\n\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => ''\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\tconst compiledValidator = TypeCompiler.Compile(schema, references)\n\n\t\tif (normalize && schema.additionalProperties === false)\n\t\t\t// @ts-ignore\n\t\t\tcompiledValidator.Clean = cleaner\n\n\t\treturn compiledValidator\n\t}\n\n\tif (Kind in maybeSchemaOrRecord) {\n\t\tif ('additionalProperties' in maybeSchemaOrRecord === false)\n\t\t\tmaybeSchemaOrRecord.additionalProperties = additionalProperties\n\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord, Object.values(models))\n\t\t}\n\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[+status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] =\n\t\t\t\t\tKind in schema\n\t\t\t\t\t\t? compile(schema, Object.values(models))\n\t\t\t\t\t\t: schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema, Object.values(models))\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\nconst isBun = typeof Bun !== 'undefined'\nconst hasHash = isBun && typeof Bun.hash === 'function'\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tif (hasHash) return Bun.hash(s) as number\n\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const stringToStructureCoercions = [\n\t{\n\t\tfrom: t.Object({}),\n\t\tto: () => t.ObjectString({}),\n\t\texcludeRoot: true\n\t},\n\t{\n\t\tfrom: t.Array(t.Any()),\n\t\tto: () => t.ArrayString(t.Any())\n\t}\n] satisfies ReplaceSchemaTypeOptions[]\n\nexport const getCookieValidator = ({\n\tvalidator,\n\tdefaultConfig = {},\n\tconfig,\n\tdynamic,\n\tmodels\n}: {\n\tvalidator: TSchema | string | undefined\n\tdefaultConfig: CookieOptions | undefined\n\tconfig: CookieOptions\n\tdynamic: boolean\n\tmodels: Record<string, TSchema> | undefined\n}) => {\n\tlet cookieValidator = getSchemaValidator(validator, {\n\t\tdynamic,\n\t\tmodels,\n\t\tadditionalProperties: true,\n\t\tcoerce: true,\n\t\tadditionalCoerce: stringToStructureCoercions\n\t})\n\n\tif (isNotEmpty(defaultConfig)) {\n\t\tif (cookieValidator) {\n\t\t\t// @ts-expect-error private\n\t\t\tcookieValidator.config = mergeCookie(\n\t\t\t\t// @ts-expect-error private\n\t\t\t\tcookieValidator.config,\n\t\t\t\tconfig\n\t\t\t)\n\t\t} else {\n\t\t\tcookieValidator = getSchemaValidator(t.Cookie({}), {\n\t\t\t\tdynamic,\n\t\t\t\tmodels,\n\t\t\t\tadditionalProperties: true\n\t\t\t})\n\n\t\t\t// @ts-expect-error private\n\t\t\tcookieValidator.config = defaultConfig\n\t\t}\n\t}\n\n\treturn cookieValidator\n}\n\nexport const injectChecksum = (\n\tchecksum: number | undefined,\n\tx: MaybeArray<HookContainer> | undefined\n) => {\n\tif (!x) return\n\n\tif (!Array.isArray(x)) {\n\t\t// ? clone fn is required to prevent side-effect from changing hookType\n\t\tconst fn = x\n\n\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\n\t\treturn fn\n\t}\n\n\t// ? clone fns is required to prevent side-effect from changing hookType\n\tconst fns = [...x]\n\n\tfor (const fn of fns) {\n\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\n\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\t}\n\n\treturn fns\n}\n\nexport const mergeLifeCycle = (\n\ta: LifeCycleStore,\n\tb: LifeCycleStore | LocalHook<any, any, any, any, any, any, any>,\n\tchecksum?: number\n): LifeCycleStore => {\n\treturn {\n\t\t// ...a,\n\t\t// ...b,\n\t\tstart: mergeObjectArray(\n\t\t\ta.start,\n\t\t\tinjectChecksum(checksum, b?.start)\n\t\t) as HookContainer<GracefulHandler<any>>[],\n\t\trequest: mergeObjectArray(\n\t\t\ta.request,\n\t\t\tinjectChecksum(checksum, b?.request)\n\t\t) as HookContainer<PreHandler<any, any>>[],\n\t\tparse: mergeObjectArray(\n\t\t\ta.parse,\n\t\t\tinjectChecksum(checksum, b?.parse)\n\t\t) as HookContainer<BodyHandler<any, any>>[],\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform,\n\t\t\tinjectChecksum(checksum, b?.transform)\n\t\t) as HookContainer<TransformHandler<any, any>>[],\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\ta.beforeHandle,\n\t\t\tinjectChecksum(checksum, b?.beforeHandle)\n\t\t) as HookContainer<OptionalHandler<any, any>>[],\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle,\n\t\t\tinjectChecksum(checksum, b?.afterHandle)\n\t\t) as HookContainer<AfterHandler<any, any>>[],\n\t\tmapResponse: mergeObjectArray(\n\t\t\ta.mapResponse,\n\t\t\tinjectChecksum(checksum, b?.mapResponse)\n\t\t) as HookContainer<MapResponse<any, any>>[],\n\t\tafterResponse: mergeObjectArray(\n\t\t\ta.afterResponse,\n\t\t\tinjectChecksum(checksum, b?.afterResponse)\n\t\t) as HookContainer<AfterResponseHandler<any, any>>[],\n\t\t// Already merged on Elysia._use, also logic is more complicated, can't directly merge\n\t\ttrace: mergeObjectArray(\n\t\t\ta.trace,\n\t\t\tinjectChecksum(checksum, b?.trace)\n\t\t) as HookContainer<TraceHandler<any, any>>[],\n\t\terror: mergeObjectArray(\n\t\t\ta.error,\n\t\t\tinjectChecksum(checksum, b?.error)\n\t\t) as HookContainer<ErrorHandler<any, any, any>>[],\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop,\n\t\t\tinjectChecksum(checksum, b?.stop)\n\t\t) as HookContainer<GracefulHandler<any>>[]\n\t}\n}\n\nexport const asHookType = (\n\tfn: HookContainer,\n\tinject: LifeCycleType,\n\t{ skipIfHasType = false }: { skipIfHasType?: boolean } = {}\n) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn)) {\n\t\tif (skipIfHasType) fn.scope ??= inject\n\t\telse fn.scope = inject\n\n\t\treturn fn\n\t}\n\n\tfor (const x of fn)\n\t\tif (skipIfHasType) x.scope ??= inject\n\t\telse x.scope = inject\n\n\treturn fn\n}\n\nconst filterGlobal = (fn: MaybeArray<HookContainer>) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn))\n\t\tswitch (fn.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\treturn { ...fn }\n\n\t\t\tdefault:\n\t\t\t\treturn { fn }\n\t\t}\n\n\tconst array = <any>[]\n\n\tfor (const x of fn)\n\t\tswitch (x.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\tarray.push({\n\t\t\t\t\t...x\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t}\n\n\treturn array\n}\n\nexport const filterGlobalHook = (\n\thook: LocalHook<any, any, any, any, any, any, any>\n): LocalHook<any, any, any, any, any, any, any> => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tmapResponse: filterGlobal(hook?.mapResponse),\n\t\tafterResponse: filterGlobal(hook?.afterResponse),\n\t\terror: filterGlobal(hook?.error),\n\t\ttrace: filterGlobal(hook?.trace)\n\t} as LocalHook<any, any, any, any, any, any, any>\n}\n\nexport const StatusMap = {\n\tContinue: 100,\n\t'Switching Protocols': 101,\n\tProcessing: 102,\n\t'Early Hints': 103,\n\tOK: 200,\n\tCreated: 201,\n\tAccepted: 202,\n\t'Non-Authoritative Information': 203,\n\t'No Content': 204,\n\t'Reset Content': 205,\n\t'Partial Content': 206,\n\t'Multi-Status': 207,\n\t'Already Reported': 208,\n\t'Multiple Choices': 300,\n\t'Moved Permanently': 301,\n\tFound: 302,\n\t'See Other': 303,\n\t'Not Modified': 304,\n\t'Temporary Redirect': 307,\n\t'Permanent Redirect': 308,\n\t'Bad Request': 400,\n\tUnauthorized: 401,\n\t'Payment Required': 402,\n\tForbidden: 403,\n\t'Not Found': 404,\n\t'Method Not Allowed': 405,\n\t'Not Acceptable': 406,\n\t'Proxy Authentication Required': 407,\n\t'Request Timeout': 408,\n\tConflict: 409,\n\tGone: 410,\n\t'Length Required': 411,\n\t'Precondition Failed': 412,\n\t'Payload Too Large': 413,\n\t'URI Too Long': 414,\n\t'Unsupported Media Type': 415,\n\t'Range Not Satisfiable': 416,\n\t'Expectation Failed': 417,\n\t\"I'm a teapot\": 418,\n\t'Misdirected Request': 421,\n\t'Unprocessable Content': 422,\n\tLocked: 423,\n\t'Failed Dependency': 424,\n\t'Too Early': 425,\n\t'Upgrade Required': 426,\n\t'Precondition Required': 428,\n\t'Too Many Requests': 429,\n\t'Request Header Fields Too Large': 431,\n\t'Unavailable For Legal Reasons': 451,\n\t'Internal Server Error': 500,\n\t'Not Implemented': 501,\n\t'Bad Gateway': 502,\n\t'Service Unavailable': 503,\n\t'Gateway Timeout': 504,\n\t'HTTP Version Not Supported': 505,\n\t'Variant Also Negotiates': 506,\n\t'Insufficient Storage': 507,\n\t'Loop Detected': 508,\n\t'Not Extended': 510,\n\t'Network Authentication Required': 511\n} as const\n\nexport const InvertedStatusMap = Object.fromEntries(\n\tObject.entries(StatusMap).map(([k, v]) => [v, k])\n) as {\n\t[K in keyof StatusMap as StatusMap[K]]: K\n}\n\nexport type StatusMap = typeof StatusMap\nexport type InvertedStatusMap = typeof InvertedStatusMap\n\nfunction removeTrailingEquals(digest: string): string {\n\tlet trimmedDigest = digest\n\twhile (trimmedDigest.endsWith('=')) {\n\t\ttrimmedDigest = trimmedDigest.slice(0, -1)\n\t}\n\treturn trimmedDigest\n}\n\nconst encoder = new TextEncoder()\n\nexport const signCookie = async (val: string, secret: string | null) => {\n\tif (typeof val !== 'string')\n\t\tthrow new TypeError('Cookie value must be provided as a string.')\n\n\tif (secret === null) throw new TypeError('Secret key must be provided.')\n\n\tconst secretKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(secret),\n\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\tfalse,\n\t\t['sign']\n\t)\n\tconst hmacBuffer = await crypto.subtle.sign(\n\t\t'HMAC',\n\t\tsecretKey,\n\t\tencoder.encode(val)\n\t)\n\n\treturn (\n\t\tval +\n\t\t'.' +\n\t\tremoveTrailingEquals(Buffer.from(hmacBuffer).toString('base64'))\n\t)\n}\n\nexport const unsignCookie = async (input: string, secret: string | null) => {\n\tif (typeof input !== 'string')\n\t\tthrow new TypeError('Signed cookie string must be provided.')\n\n\tif (null === secret) throw new TypeError('Secret key must be provided.')\n\n\tconst tentativeValue = input.slice(0, input.lastIndexOf('.'))\n\tconst expectedInput = await signCookie(tentativeValue, secret)\n\n\treturn expectedInput === input ? tentativeValue : false\n}\n\nexport const traceBackMacro = (\n\textension: unknown,\n\tproperty: Record<string, unknown>\n) => {\n\tif (!extension || typeof extension !== 'object' || !property) return\n\n\tfor (const [key, value] of Object.entries(property)) {\n\t\tif (key in primitiveHookMap || !(key in extension)) continue\n\n\t\tconst v = extension[\n\t\t\tkey as unknown as keyof typeof extension\n\t\t] as BaseMacro[string]\n\n\t\tif (typeof v === 'function') {\n\t\t\tv(value)\n\t\t\tdelete property[key as unknown as keyof typeof extension]\n\t\t}\n\t}\n}\n\nexport const createMacroManager =\n\t({\n\t\tglobalHook,\n\t\tlocalHook\n\t}: {\n\t\tglobalHook: LifeCycleStore\n\t\tlocalHook: LocalHook<any, any, any, any, any, any, any>\n\t}) =>\n\t(stackName: keyof LifeCycleStore) =>\n\t(\n\t\ttype:\n\t\t\t| {\n\t\t\t\t\tinsert?: 'before' | 'after'\n\t\t\t\t\tstack?: 'global' | 'local'\n\t\t\t  }\n\t\t\t| MaybeArray<HookContainer>,\n\t\tfn?: MaybeArray<HookContainer>\n\t) => {\n\t\tif (typeof type === 'function')\n\t\t\ttype = {\n\t\t\t\tfn: type\n\t\t\t}\n\n\t\tif ('fn' in type || Array.isArray(type)) {\n\t\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\t\tif (typeof localHook[stackName] === 'function')\n\t\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\t\tif (Array.isArray(type))\n\t\t\t\tlocalHook[stackName] = (\n\t\t\t\t\tlocalHook[stackName] as unknown[]\n\t\t\t\t).concat(type) as any\n\t\t\telse localHook[stackName].push(type)\n\n\t\t\treturn\n\t\t}\n\n\t\tconst { insert = 'after', stack = 'local' } = type\n\n\t\tif (typeof fn === 'function') fn = { fn }\n\n\t\tif (stack === 'global') {\n\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t;(globalHook[stackName] as any[]).unshift(fn)\n\t\t\t\t} else {\n\t\t\t\t\t;(globalHook[stackName] as any[]).push(fn)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\tglobalHook[stackName] = fn.concat(\n\t\t\t\t\t\tglobalHook[stackName] as any\n\t\t\t\t\t) as any\n\t\t\t\t} else {\n\t\t\t\t\tglobalHook[stackName] = (\n\t\t\t\t\t\tglobalHook[stackName] as any[]\n\t\t\t\t\t).concat(fn)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\t\tif (typeof localHook[stackName] === 'function')\n\t\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t;(localHook[stackName] as any[]).unshift(fn)\n\t\t\t\t} else {\n\t\t\t\t\t;(localHook[stackName] as any[]).push(fn)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\tlocalHook[stackName] = fn.concat(localHook[stackName])\n\t\t\t\t} else {\n\t\t\t\t\tlocalHook[stackName] = localHook[stackName].concat(fn)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nconst parseNumericString = (message: string | number): number | null => {\n\tif (typeof message === 'number') return message\n\n\tif (message.length < 16) {\n\t\tif (message.trim().length === 0) return null\n\n\t\tconst length = Number(message)\n\t\tif (Number.isNaN(length)) return null\n\n\t\treturn length\n\t}\n\n\t// if 16 digit but less then 9,007,199,254,740,991 then can be parsed\n\tif (message.length === 16) {\n\t\tif (message.trim().length === 0) return null\n\n\t\tconst number = Number(message)\n\t\tif (Number.isNaN(number) || number.toString() !== message) return null\n\n\t\treturn number\n\t}\n\n\treturn null\n}\n\nexport const isNumericString = (message: string | number): boolean =>\n\tparseNumericString(message) !== null\n\nexport class PromiseGroup implements PromiseLike<void> {\n\troot: Promise<any> | null = null\n\tpromises: Promise<any>[] = []\n\n\tconstructor(public onError: (error: any) => void = console.error) {}\n\n\t/**\n\t * The number of promises still being awaited.\n\t */\n\tget size() {\n\t\treturn this.promises.length\n\t}\n\n\t/**\n\t * Add a promise to the group.\n\t * @returns The promise that was added.\n\t */\n\tadd<T>(promise: Promise<T>) {\n\t\tthis.promises.push(promise)\n\t\tthis.root ||= this.drain()\n\t\treturn promise\n\t}\n\n\tprivate async drain() {\n\t\twhile (this.promises.length > 0) {\n\t\t\ttry {\n\t\t\t\tawait this.promises[0]\n\t\t\t} catch (error) {\n\t\t\t\tthis.onError(error)\n\t\t\t}\n\t\t\tthis.promises.shift()\n\t\t}\n\t\tthis.root = null\n\t}\n\n\t// Allow the group to be awaited.\n\tthen<TResult1 = void, TResult2 = never>(\n\t\tonfulfilled?:\n\t\t\t| ((value: void) => TResult1 | PromiseLike<TResult1>)\n\t\t\t| undefined\n\t\t\t| null,\n\t\tonrejected?:\n\t\t\t| ((reason: any) => TResult2 | PromiseLike<TResult2>)\n\t\t\t| undefined\n\t\t\t| null\n\t): PromiseLike<TResult1 | TResult2> {\n\t\treturn (this.root ?? Promise.resolve()).then(onfulfilled, onrejected)\n\t}\n}\n\nexport const fnToContainer = (\n\tfn: MaybeArray<Function | HookContainer>\n): MaybeArray<HookContainer> => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn)) {\n\t\tif (typeof fn === 'function') return { fn }\n\t\telse if ('fn' in fn) return fn\n\t}\n\n\tconst fns = <HookContainer[]>[]\n\tfor (const x of fn) {\n\t\tif (typeof x === 'function') fns.push({ fn: x })\n\t\telse if ('fn' in x) fns.push(x)\n\t}\n\n\treturn fns\n}\n\nexport const localHookToLifeCycleStore = (\n\ta: LocalHook<any, any, any, any, any>\n): LifeCycleStore => {\n\treturn {\n\t\t...a,\n\t\tstart: fnToContainer(a?.start),\n\t\trequest: fnToContainer(a?.request),\n\t\tparse: fnToContainer(a?.parse),\n\t\ttransform: fnToContainer(a?.transform),\n\t\tbeforeHandle: fnToContainer(a?.beforeHandle),\n\t\tafterHandle: fnToContainer(a?.afterHandle),\n\t\tmapResponse: fnToContainer(a?.mapResponse),\n\t\tafterResponse: fnToContainer(a?.afterResponse),\n\t\ttrace: fnToContainer(a?.trace),\n\t\terror: fnToContainer(a?.error),\n\t\tstop: fnToContainer(a?.stop)\n\t}\n}\n\nexport const lifeCycleToFn = (\n\ta: LifeCycleStore\n): LocalHook<any, any, any, any, any, any, any> => {\n\treturn {\n\t\t...a,\n\t\tstart: a.start?.map((x) => x.fn),\n\t\trequest: a.request?.map((x) => x.fn),\n\t\tparse: a.parse?.map((x) => x.fn),\n\t\ttransform: a.transform?.map((x) => x.fn),\n\t\tbeforeHandle: a.beforeHandle?.map((x) => x.fn),\n\t\tafterHandle: a.afterHandle?.map((x) => x.fn),\n\t\tafterResponse: a.afterResponse?.map((x) => x.fn),\n\t\tmapResponse: a.mapResponse?.map((x) => x.fn),\n\t\ttrace: a.trace?.map((x) => x.fn),\n\t\terror: a.error?.map((x) => x.fn),\n\t\tstop: a.stop?.map((x) => x.fn)\n\t}\n}\n\nexport const cloneInference = (inference: Sucrose.Inference) => ({\n\tbody: inference.body,\n\tcookie: inference.cookie,\n\theaders: inference.headers,\n\tquery: inference.query,\n\tset: inference.set,\n\tserver: inference.server\n})\n\n/**\n *\n * @param url URL to redirect to\n * @param HTTP status code to send,\n */\nexport const redirect = (\n\turl: string,\n\tstatus: 301 | 302 | 303 | 307 | 308 = 302\n) => Response.redirect(url, status)\n\nexport type redirect = typeof redirect\n\nexport const ELYSIA_FORM_DATA = Symbol('ElysiaFormData')\nexport type ELYSIA_FORM_DATA = typeof ELYSIA_FORM_DATA\n\ntype ElysiaFormData<T extends Record<string | number, unknown>> = FormData & {\n\t[ELYSIA_FORM_DATA]: Replace<T, BunFile, File>\n}\n\nexport const ELYSIA_REQUEST_ID = Symbol('ElysiaRequestId')\nexport type ELYSIA_REQUEST_ID = typeof ELYSIA_REQUEST_ID\n\nexport const form = <const T extends Record<string | number, unknown>>(\n\titems: T\n): ElysiaFormData<T> => {\n\tconst formData = new FormData()\n\n\tfor (const [key, value] of Object.entries(items)) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (const v of value) {\n\t\t\t\tif (value instanceof File)\n\t\t\t\t\tformData.append(key, value, value.name)\n\n\t\t\t\tformData.append(key, v)\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (value instanceof File) formData.append(key, value, value.name)\n\t\tformData.append(key, value)\n\t}\n\n\treturn formData as any\n}\n\nexport const randomId = () => crypto.getRandomValues(new Uint32Array(1))[0]\n\n// ! Deduplicate current instance\nexport const deduplicateChecksum = <T extends Function>(\n\tarray: HookContainer<T>[]\n): HookContainer<T>[] => {\n\tconst hashes: number[] = []\n\n\tfor (let i = 0; i < array.length; i++) {\n\t\tconst item = array[i]\n\n\t\tif (item.checksum) {\n\t\t\tif (hashes.includes(item.checksum)) {\n\t\t\t\tarray.splice(i, 1)\n\t\t\t\ti--\n\t\t\t}\n\n\t\t\thashes.push(item.checksum)\n\t\t}\n\t}\n\n\treturn array\n}\n\n/**\n * Since it's a plugin, which means that ephemeral is demoted to volatile.\n * Which  means there's no volatile and all previous ephemeral become volatile\n * We can just promote back without worry\n */\nexport const promoteEvent = (\n\tevents: (HookContainer | Function)[],\n\tas: 'scoped' | 'global' = 'scoped'\n): void => {\n\tif (as === 'scoped') {\n\t\tfor (const event of events)\n\t\t\tif ('scope' in event && event.scope === 'local')\n\t\t\t\tevent.scope = 'scoped'\n\n\t\treturn\n\t}\n\n\tfor (const event of events) if ('scope' in event) event.scope = 'global'\n}\n",
    "import {\n\tArrayOptions,\n\tDateOptions,\n\tNumberOptions,\n\tTArray,\n\tTDate,\n\tTUnsafe,\n\tTypeRegistry\n} from '@sinclair/typebox'\nimport { TypeSystem } from '@sinclair/typebox/system'\nimport {\n\tType,\n\ttype SchemaOptions,\n\t// type TNull,\n\t// type TUnion,\n\ttype TSchema,\n\t// type TUndefined,\n\tTProperties,\n\tObjectOptions,\n\tTObject,\n\tTNumber,\n\tTBoolean,\n\tFormatRegistry\n} from '@sinclair/typebox'\n\nimport {\n\ttype ValueError,\n\ttype TypeCheck,\n\tTypeCompiler\n} from '@sinclair/typebox/compiler'\nimport { Value } from '@sinclair/typebox/value'\nimport { fullFormats } from './formats'\n\nimport type { CookieOptions } from './cookies'\nimport { ValidationError } from './error'\nimport type { MaybeArray } from './types'\n\nconst isISO8601 =\n\t/(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/\nconst isFormalDate =\n\t/(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s\\d{2}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}\\sGMT(?:\\+|-)\\d{4}\\s\\([^)]+\\)/\nconst isShortenDate =\n\t/^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:19|20)\\d{2})|(?:(?:19|20)\\d{2}[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\\s[AP]M)?)?$/\n\nconst _validateDate = fullFormats.date\nconst _validateDateTime = fullFormats['date-time']\n\nif (!FormatRegistry.Has('date'))\n\tTypeSystem.Format('date', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = value.replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDate(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nif (!FormatRegistry.Has('date-time'))\n\tTypeSystem.Format('date-time', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = value.replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDateTime(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nObject.entries(fullFormats).forEach((formatEntry) => {\n\tconst [formatName, formatValue] = formatEntry\n\n\tif (!FormatRegistry.Has(formatName)) {\n\t\tif (formatValue instanceof RegExp)\n\t\t\tTypeSystem.Format(formatName, (value) => formatValue.test(value))\n\t\telse if (typeof formatValue === 'function')\n\t\t\tTypeSystem.Format(formatName, formatValue)\n\t}\n})\n\nconst t = Object.assign({}, Type)\n\nexport namespace ElysiaTypeOptions {\n\texport type Numeric = NumberOptions\n\n\texport type FileUnit = number | `${number}${'k' | 'm'}`\n\n\texport type StrictFileType =\n\t\t| 'image'\n\t\t| 'image/*'\n\t\t| 'image/jpeg'\n\t\t| 'image/png'\n\t\t| 'image/gif'\n\t\t| 'image/tiff'\n\t\t| 'image/x-icon'\n\t\t| 'image/svg'\n\t\t| 'image/webp'\n\t\t| 'image/avif'\n\t\t| 'audio'\n\t\t| 'audio/*'\n\t\t| 'audio/aac'\n\t\t| 'audio/mpeg'\n\t\t| 'audio/x-ms-wma'\n\t\t| 'audio/vnd.rn-realaudio'\n\t\t| 'audio/x-wav'\n\t\t| 'video'\n\t\t| 'video/*'\n\t\t| 'video/mpeg'\n\t\t| 'video/mp4'\n\t\t| 'video/quicktime'\n\t\t| 'video/x-ms-wmv'\n\t\t| 'video/x-msvideo'\n\t\t| 'video/x-flv'\n\t\t| 'video/webm'\n\t\t| 'text'\n\t\t| 'text/*'\n\t\t| 'text/css'\n\t\t| 'text/csv'\n\t\t| 'text/html'\n\t\t| 'text/javascript'\n\t\t| 'text/plain'\n\t\t| 'text/xml'\n\t\t| 'application'\n\t\t| 'application/*'\n\t\t| 'application/graphql'\n\t\t| 'application/graphql-response+json'\n\t\t| 'application/ogg'\n\t\t| 'application/pdf'\n\t\t| 'application/xhtml'\n\t\t| 'application/xhtml+html'\n\t\t| 'application/xml-dtd'\n\t\t| 'application/html'\n\t\t| 'application/json'\n\t\t| 'application/ld+json'\n\t\t| 'application/xml'\n\t\t| 'application/zip'\n\t\t| 'font'\n\t\t| 'font/*'\n\t\t| 'font/woff2'\n\t\t| 'font/woff'\n\t\t| 'font/ttf'\n\t\t| 'font/otf'\n\n\texport type FileType = (string & {}) | StrictFileType\n\n\texport interface File extends SchemaOptions {\n\t\ttype?: MaybeArray<FileType>\n\t\tminSize?: FileUnit\n\t\tmaxSize?: FileUnit\n\t}\n\n\texport interface Files extends File {\n\t\tminItems?: number\n\t\tmaxItems?: number\n\t}\n\n\texport interface CookieValidatorOption<T extends Object = {}>\n\t\textends ObjectOptions,\n\t\t\tCookieOptions {\n\t\t/**\n\t\t * Secret key for signing cookie\n\t\t *\n\t\t * If array is passed, will use Key Rotation.\n\t\t *\n\t\t * Key rotation is when an encryption key is retired\n\t\t * and replaced by generating a new cryptographic key.\n\t\t */\n\t\tsecrets?: string | string[]\n\t\t/**\n\t\t * Specified cookie name to be signed globally\n\t\t */\n\t\tsign?: Readonly<(keyof T | (string & {}))[]>\n\t}\n}\n\nconst parseFileUnit = (size: ElysiaTypeOptions.FileUnit) => {\n\tif (typeof size === 'string')\n\t\tswitch (size.slice(-1)) {\n\t\t\tcase 'k':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1024\n\n\t\t\tcase 'm':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1048576\n\n\t\t\tdefault:\n\t\t\t\treturn +size\n\t\t}\n\n\treturn size\n}\n\nconst validateFile = (options: ElysiaTypeOptions.File, value: any) => {\n\tif (!(value instanceof Blob)) return false\n\n\tif (options.minSize && value.size < parseFileUnit(options.minSize))\n\t\treturn false\n\n\tif (options.maxSize && value.size > parseFileUnit(options.maxSize))\n\t\treturn false\n\n\tif (options.extension)\n\t\tif (typeof options.extension === 'string') {\n\t\t\tif (!value.type.startsWith(options.extension)) return false\n\t\t} else {\n\t\t\tfor (let i = 0; i < options.extension.length; i++)\n\t\t\t\tif (value.type.startsWith(options.extension[i])) return true\n\n\t\t\treturn false\n\t\t}\n\n\treturn true\n}\n\ntype ElysiaFile = (\n\toptions?: Partial<ElysiaTypeOptions.Files> | undefined\n) => TUnsafe<File>\n\nconst File: ElysiaFile =\n\t(TypeRegistry.Get('Files') as unknown as ElysiaFile) ??\n\tTypeSystem.Type<File, ElysiaTypeOptions.File>('File', validateFile)\n\ntype ElysiaFiles = (\n\toptions?: Partial<ElysiaTypeOptions.Files> | undefined\n) => TUnsafe<File[]>\n\nconst Files: ElysiaFiles =\n\t(TypeRegistry.Get('Files') as unknown as ElysiaFiles) ??\n\tTypeSystem.Type<File[], ElysiaTypeOptions.Files>(\n\t\t'Files',\n\t\t(options, value) => {\n\t\t\tif (!Array.isArray(value)) return validateFile(options, value)\n\n\t\t\tif (options.minItems && value.length < options.minItems)\n\t\t\t\treturn false\n\n\t\t\tif (options.maxItems && value.length > options.maxItems)\n\t\t\t\treturn false\n\n\t\t\tfor (let i = 0; i < value.length; i++)\n\t\t\t\tif (!validateFile(options, value[i])) return false\n\n\t\t\treturn true\n\t\t}\n\t)\n\nif (!FormatRegistry.Has('numeric'))\n\tFormatRegistry.Set('numeric', (value) => !!value && !isNaN(+value))\n\nif (!FormatRegistry.Has('boolean'))\n\tFormatRegistry.Set(\n\t\t'boolean',\n\t\t(value) => value === 'true' || value === 'false'\n\t)\n\nif (!FormatRegistry.Has('ObjectString'))\n\tFormatRegistry.Set('ObjectString', (value) => {\n\t\tlet start = value.charCodeAt(0)\n\n\t\t// If starts with ' ', '\\t', '\\n', then trim first\n\t\tif (start === 9 || start === 10 || start === 32)\n\t\t\tstart = value.trimStart().charCodeAt(0)\n\n\t\tif (start !== 123 && start !== 91) return false\n\n\t\ttry {\n\t\t\tJSON.parse(value)\n\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t})\n\nif (!FormatRegistry.Has('ArrayString'))\n\tFormatRegistry.Set('ArrayString', (value) => {\n\t\tlet start = value.charCodeAt(0)\n\n\t\t// If starts with ' ', '\\t', '\\n', then trim first\n\t\tif (start === 9 || start === 10 || start === 32)\n\t\t\tstart = value.trimStart().charCodeAt(0)\n\n\t\tif (start !== 123 && start !== 91) return false\n\n\t\ttry {\n\t\t\tJSON.parse(value)\n\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t})\n\nexport const ElysiaType = {\n\tNumeric: (property?: NumberOptions) => {\n\t\tconst schema = Type.Number(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'numeric',\n\t\t\t\t\t\t\tdefault: 0\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Number(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\t\t\t\tif (isNaN(number)) return value\n\n\t\t\t\tif (property && !Value.Check(schema, number))\n\t\t\t\t\tthrow new ValidationError('property', schema, number)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TNumber\n\t},\n\tDate: (property?: DateOptions) => {\n\t\tconst schema = Type.Date(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tType.Date(property),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date',\n\t\t\t\t\t\t\tdefault: new Date().toISOString()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date-time',\n\t\t\t\t\t\t\tdefault: new Date().toISOString()\n\t\t\t\t\t\t})\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (value instanceof Date) return value\n\n\t\t\t\tconst date = new Date(value)\n\n\t\t\t\tif (!Value.Check(schema, date))\n\t\t\t\t\tthrow new ValidationError('property', schema, date)\n\n\t\t\t\treturn date\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tif (typeof value === 'string') return new Date(value)\n\n\t\t\t\treturn value\n\t\t\t}) as any as TDate\n\t},\n\tBooleanString: (property?: SchemaOptions) => {\n\t\tconst schema = Type.Boolean(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'boolean',\n\t\t\t\t\t\t\tdefault: false\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Boolean(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') return value === 'true'\n\n\t\t\t\tif (property && !Value.Check(schema, value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TBoolean\n\t},\n\tObjectString: <T extends TProperties>(\n\t\tproperties: T,\n\t\toptions?: ObjectOptions\n\t) => {\n\t\tconst schema = t.Object(properties, options)\n\t\tconst defaultValue = JSON.stringify(Value.Create(schema))\n\n\t\tlet compiler: TypeCheck<TObject<T>>\n\t\ttry {\n\t\t\tcompiler = TypeCompiler.Compile(schema)\n\t\t} catch {\n\t\t\t// Nothing\n\t\t}\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union([\n\t\t\t\t\tt.String({\n\t\t\t\t\t\tformat: 'ObjectString',\n\t\t\t\t\t\tdefault: defaultValue\n\t\t\t\t\t}),\n\t\t\t\t\tschema\n\t\t\t\t])\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tif (value.charCodeAt(0) !== 123)\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (compiler) {\n\t\t\t\t\t\tif (!compiler.Check(value))\n\t\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\t\treturn compiler.Decode(value)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\treturn Value.Decode(schema, value)\n\t\t\t\t}\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t\t}\n\n\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn JSON.stringify(value)\n\t\t\t}) as any as TObject<T>\n\t},\n\tArrayString: <T extends TSchema>(\n\t\tchildren: T = {} as T,\n\t\toptions?: ArrayOptions\n\t) => {\n\t\tconst schema = t.Array(children, options)\n\t\tconst defaultValue = JSON.stringify(Value.Create(schema))\n\n\t\tlet compiler: TypeCheck<TArray<T>>\n\t\ttry {\n\t\t\tcompiler = TypeCompiler.Compile(schema)\n\t\t} catch {\n\t\t\t// Nothing\n\t\t}\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union([\n\t\t\t\t\tt.String({\n\t\t\t\t\t\tformat: 'ArrayString',\n\t\t\t\t\t\tdefault: defaultValue\n\t\t\t\t\t}),\n\t\t\t\t\tschema\n\t\t\t\t])\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tif (value.charCodeAt(0) !== 91)\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (compiler) {\n\t\t\t\t\t\tif (!compiler.Check(value))\n\t\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\t\treturn compiler.Decode(value)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\treturn Value.Decode(schema, value)\n\t\t\t\t}\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t\t}\n\n\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn JSON.stringify(value)\n\t\t\t}) as any as TObject<T>\n\t},\n\tFile,\n\tFiles: (options: ElysiaTypeOptions.Files = {}) =>\n\t\tt\n\t\t\t.Transform(Files(options))\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) return value\n\t\t\t\treturn [value]\n\t\t\t})\n\t\t\t.Encode((value) => value),\n\tNullable: <T extends TSchema>(schema: T) => t.Union([schema, t.Null()]),\n\t/**\n\t * Allow Optional, Nullable and Undefined\n\t */\n\tMaybeEmpty: <T extends TSchema>(schema: T) =>\n\t\tt.Union([schema, t.Null(), t.Undefined()]),\n\tCookie: <T extends TProperties>(\n\t\tproperties: T,\n\t\t{\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign,\n\t\t\t...options\n\t\t}: ElysiaTypeOptions.CookieValidatorOption<T> = {}\n\t) => {\n\t\tconst v = t.Object(properties, options)\n\n\t\tv.config = {\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign\n\t\t}\n\n\t\treturn v\n\t}\n} as const\n\nexport type TCookie = (typeof ElysiaType)['Cookie']\n\ndeclare module '@sinclair/typebox' {\n\tinterface JavaScriptTypeBuilder {\n\t\tBooleanString: typeof ElysiaType.BooleanString\n\t\tObjectString: typeof ElysiaType.ObjectString\n\t\tArrayString: typeof ElysiaType.ArrayString\n\t\t// @ts-ignore\n\t\tNumeric: typeof ElysiaType.Numeric\n\t\t// @ts-ignore\n\t\tFile: typeof ElysiaType.File\n\t\t// @ts-ignore\n\t\tFiles: typeof ElysiaType.Files\n\t\t// @ts-ignore\n\t\tNullable: typeof ElysiaType.Nullable\n\t\t// @ts-ignore\n\t\tMaybeEmpty: typeof ElysiaType.MaybeEmpty\n\t\tCookie: typeof ElysiaType.Cookie\n\t}\n\n\tinterface SchemaOptions {\n\t\terror?:\n\t\t\t| string\n\t\t\t| boolean\n\t\t\t| number\n\t\t\t| Object\n\t\t\t| ((validation: {\n\t\t\t\t\terrors: ValueError[]\n\t\t\t\t\ttype: string\n\t\t\t\t\tvalidator: TypeCheck<any>\n\t\t\t\t\tvalue: unknown\n\t\t\t  }) => string | boolean | number | Object | void)\n\t}\n}\n\n/**\n * A Boolean string\n *\n * Will be parse to Boolean\n */\nt.BooleanString = ElysiaType.BooleanString\nt.ObjectString = ElysiaType.ObjectString\nt.ArrayString = ElysiaType.ArrayString\n\n/**\n * A Numeric string\n *\n * Will be parse to Number\n */\nt.Numeric = ElysiaType.Numeric\n\nt.File = (arg = {}) =>\n\tElysiaType.File({\n\t\tdefault: 'File',\n\t\t...arg,\n\t\textension: arg?.type,\n\t\ttype: 'string',\n\t\tformat: 'binary'\n\t})\n\nt.Files = (arg = {}) =>\n\tElysiaType.Files({\n\t\t...arg,\n\t\telysiaMeta: 'Files',\n\t\tdefault: 'Files',\n\t\textension: arg?.type,\n\t\ttype: 'array',\n\t\titems: {\n\t\t\t...arg,\n\t\t\tdefault: 'Files',\n\t\t\ttype: 'string',\n\t\t\tformat: 'binary'\n\t\t}\n\t})\n\nt.Nullable = (schema) => ElysiaType.Nullable(schema)\nt.MaybeEmpty = ElysiaType.MaybeEmpty as any\n\nt.Cookie = ElysiaType.Cookie\nt.Date = ElysiaType.Date\n\nexport { t }\n\nexport {\n\tTypeSystemPolicy,\n\tTypeSystem,\n\tTypeSystemDuplicateFormat,\n\tTypeSystemDuplicateTypeKind\n} from '@sinclair/typebox/system'\nexport { TypeCompiler, TypeCheck } from '@sinclair/typebox/compiler'\n\n// type Template =\n// \t| string\n// \t| number\n// \t| bigint\n// \t| boolean\n// \t| StringConstructor\n// \t| NumberConstructor\n// \t| undefined\n\n// type Join<A> = A extends Readonly<[infer First, ...infer Rest]>\n// \t? (\n// \t\t\tFirst extends Readonly<Template[]>\n// \t\t\t\t? First[number]\n// \t\t\t\t: First extends StringConstructor\n// \t\t\t\t? string\n// \t\t\t\t: First extends NumberConstructor\n// \t\t\t\t? `${number}`\n// \t\t\t\t: First\n// \t  ) extends infer A\n// \t\t? Rest extends []\n// \t\t\t? A extends undefined\n// \t\t\t\t? NonNullable<A> | ''\n// \t\t\t\t: A\n// \t\t\t: // @ts-ignore\n// \t\t\tA extends undefined\n// \t\t\t? `${NonNullable<A>}${Join<Rest>}` | ''\n// \t\t\t: // @ts-ignore\n// \t\t\t  `${A}${Join<Rest>}`\n// \t\t: ''\n// \t: ''\n\n// const template = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): Join<T> => {\n// \treturn a as any\n// }\n\n// const create =\n// \t<const T extends string>(t: T): ((t: T) => void) =>\n// \t(t) =>\n// \t\tt\n\n// const optional = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): T | undefined => {\n// \treturn undefined\n// }\n\n// template.optional = optional\n\n// const hi = create(\n// \ttemplate(\n// \t\t['seminar', 'millennium'],\n// \t\t':',\n// \t\t['Rio', 'Yuuka', 'Noa', 'Koyuki'],\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki']))\n// \t)\n// )\n\n// hi(`seminar:Noa,Koyuki,Yuuka`)\n\n// const a = TypeCompiler.Compile(t.String())\n\n// console.log(v.Decode.toString())\n\n// const T = t.Transform(v.schema)\n// \t.Decode((value) => new Date(value)) // required: number to Date\n// \t.Encode((value) => value.getTime()) // required: Date to number\n\n// const decoded = Value.Decode(T, 0) // const decoded = Date(1970-01-01T00:00:00.000Z)\n// const encoded = Value.Encode(T, decoded)\n",
    "/**\n * ? Fork of ajv-formats without ajv as dependencies\n *\n * @see https://github.com/ajv-validator/ajv-formats/blob/master/src/formats.ts\n **/\n\n/* eslint-disable no-control-regex */\nexport type FormatName =\n\t| 'date'\n\t| 'time'\n\t| 'date-time'\n\t| 'iso-time'\n\t| 'iso-date-time'\n\t| 'duration'\n\t| 'uri'\n\t| 'uri-reference'\n\t| 'uri-template'\n\t| 'url'\n\t| 'email'\n\t| 'hostname'\n\t| 'ipv4'\n\t| 'ipv6'\n\t| 'regex'\n\t| 'uuid'\n\t| 'json-pointer'\n\t| 'json-pointer-uri-fragment'\n\t| 'relative-json-pointer'\n\t| 'byte'\n\t| 'int32'\n\t| 'int64'\n\t| 'float'\n\t| 'double'\n\t| 'password'\n\t| 'binary'\n\nexport const fullFormats = {\n\t// date: http://tools.ietf.org/html/rfc3339#section-5.6\n\tdate,\n\t// date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n\ttime: getTime(true),\n\t'date-time': getDateTime(true),\n\t'iso-time': getTime(false),\n\t'iso-date-time': getDateTime(false),\n\t// duration: https://tools.ietf.org/html/rfc3339#appendix-A\n\tduration:\n\t\t/^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n\turi,\n\t'uri-reference':\n\t\t/^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n\t// uri-template: https://tools.ietf.org/html/rfc6570\n\t'uri-template':\n\t\t/^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n\t// For the source: https://gist.github.com/dperini/729294\n\t// For test cases: https://mathiasbynens.be/demo/url-regex\n\turl: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n\temail: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n\thostname:\n\t\t/^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n\t// optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n\tipv4: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/,\n\tipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n\tregex,\n\t// uuid: http://tools.ietf.org/html/rfc4122\n\tuuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n\t// JSON-pointer: https://tools.ietf.org/html/rfc6901\n\t// uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n\t'json-pointer': /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n\t'json-pointer-uri-fragment':\n\t\t/^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n\t// relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n\t'relative-json-pointer': /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n\t// the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n\t// byte: https://github.com/miguelmota/is-base64\n\tbyte,\n\t// signed 32 bit integer\n\tint32: { type: 'number', validate: validateInt32 },\n\t// signed 64 bit integer\n\tint64: { type: 'number', validate: validateInt64 },\n\t// C-type float\n\tfloat: { type: 'number', validate: validateNumber },\n\t// C-type double\n\tdouble: { type: 'number', validate: validateNumber },\n\t// hint to the UI to hide input strings\n\tpassword: true,\n\t// unchecked string payload\n\tbinary: true\n} as const\n\nfunction isLeapYear(year: number): boolean {\n\t// https://tools.ietf.org/html/rfc3339#appendix-C\n\treturn year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n}\n\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nfunction date(str: string): boolean {\n\t// full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n\tconst matches: string[] | null = DATE.exec(str)\n\tif (!matches) return false\n\tconst year: number = +matches[1]\n\tconst month: number = +matches[2]\n\tconst day: number = +matches[3]\n\treturn (\n\t\tmonth >= 1 &&\n\t\tmonth <= 12 &&\n\t\tday >= 1 &&\n\t\tday <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])\n\t)\n}\n\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d(?:\\.\\d+)?)(z|([+-])(\\d\\d)(?::?(\\d\\d))?)?$/i\n\nfunction getTime(strictTimeZone?: boolean): (str: string) => boolean {\n\treturn function time(str: string): boolean {\n\t\tconst matches: string[] | null = TIME.exec(str)\n\t\tif (!matches) return false\n\t\tconst hr: number = +matches[1]\n\t\tconst min: number = +matches[2]\n\t\tconst sec: number = +matches[3]\n\t\tconst tz: string | undefined = matches[4]\n\t\tconst tzSign: number = matches[5] === '-' ? -1 : 1\n\t\tconst tzH: number = +(matches[6] || 0)\n\t\tconst tzM: number = +(matches[7] || 0)\n\t\tif (tzH > 23 || tzM > 59 || (strictTimeZone && !tz)) return false\n\t\tif (hr <= 23 && min <= 59 && sec < 60) return true\n\t\t// leap second\n\t\tconst utcMin = min - tzM * tzSign\n\t\tconst utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0)\n\t\treturn (\n\t\t\t(utcHr === 23 || utcHr === -1) &&\n\t\t\t(utcMin === 59 || utcMin === -1) &&\n\t\t\tsec < 61\n\t\t)\n\t}\n}\n\nconst DATE_TIME_SEPARATOR = /t|\\s/i\nfunction getDateTime(strictTimeZone?: boolean): (str: string) => boolean {\n\tconst time = getTime(strictTimeZone)\n\n\treturn function date_time(str: string): boolean {\n\t\t// http://tools.ietf.org/html/rfc3339#section-5.6\n\t\tconst dateTime: string[] = str.split(DATE_TIME_SEPARATOR)\n\t\treturn dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1])\n\t}\n}\n\nconst NOT_URI_FRAGMENT = /\\/|:/\nconst URI =\n\t/^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i\n\nfunction uri(str: string): boolean {\n\t// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n\treturn NOT_URI_FRAGMENT.test(str) && URI.test(str)\n}\n\nconst BYTE =\n\t/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm\n\nfunction byte(str: string): boolean {\n\tBYTE.lastIndex = 0\n\treturn BYTE.test(str)\n}\n\nconst MIN_INT32 = -(2 ** 31)\nconst MAX_INT32 = 2 ** 31 - 1\n\nfunction validateInt32(value: number): boolean {\n\treturn Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32\n}\n\nfunction validateInt64(value: number): boolean {\n\t// JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n\treturn Number.isInteger(value)\n}\n\nfunction validateNumber(): boolean {\n\treturn true\n}\n\nconst Z_ANCHOR = /[^\\\\]\\\\Z/\nfunction regex(str: string): boolean {\n\tif (Z_ANCHOR.test(str)) return false\n\ttry {\n\t\tnew RegExp(str)\n\t\treturn true\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\n/**\n * @license\n * \n * MIT License\n * \n * Copyright (c) 2020 Evgeny Poberezkin\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n",
    "/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar __toString = Object.prototype.toString\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var dec = opt.decode || decode;\n\n  var index = 0\n  while (index < str.length) {\n    var eqIdx = str.indexOf('=', index)\n\n    // no more cookie pairs\n    if (eqIdx === -1) {\n      break\n    }\n\n    var endIdx = str.indexOf(';', index)\n\n    if (endIdx === -1) {\n      endIdx = str.length\n    } else if (endIdx < eqIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(';', eqIdx - 1) + 1\n      continue\n    }\n\n    var key = str.slice(index, eqIdx).trim()\n\n    // only assign once\n    if (undefined === obj[key]) {\n      var val = str.slice(eqIdx + 1, endIdx).trim()\n\n      // quoted values\n      if (val.charCodeAt(0) === 0x22) {\n        val = val.slice(1, -1)\n      }\n\n      obj[key] = tryDecode(val, dec);\n    }\n\n    index = endIdx + 1\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    var expires = opt.expires\n\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + expires.toUTCString()\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.partitioned) {\n    str += '; Partitioned'\n  }\n\n  if (opt.priority) {\n    var priority = typeof opt.priority === 'string'\n      ? opt.priority.toLowerCase()\n      : opt.priority\n\n    switch (priority) {\n      case 'low':\n        str += '; Priority=Low'\n        break\n      case 'medium':\n        str += '; Priority=Medium'\n        break\n      case 'high':\n        str += '; Priority=High'\n        break\n      default:\n        throw new TypeError('option priority is invalid')\n    }\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction decode (str) {\n  return str.indexOf('%') !== -1\n    ? decodeURIComponent(str)\n    : str\n}\n\n/**\n * URL-encode value.\n *\n * @param {string} val\n * @returns {string}\n */\n\nfunction encode (val) {\n  return encodeURIComponent(val)\n}\n\n/**\n * Determine if value is a Date.\n *\n * @param {*} val\n * @private\n */\n\nfunction isDate (val) {\n  return __toString.call(val) === '[object Date]' ||\n    val instanceof Date\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n",
    "import { parse } from 'cookie'\n\n// @ts-ignore\nimport decodeURIComponent from 'fast-decode-uri-component'\n\nimport { unsignCookie } from './utils'\nimport { InvalidCookieSignature } from './error'\n\nimport type { Context } from './context'\nimport type { Prettify } from './types'\n\nexport interface CookieOptions {\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.3|Domain Set-Cookie attribute}. By default, no\n\t * domain is set, and most clients will consider the cookie to apply to only\n\t * the current domain.\n\t */\n\tdomain?: string | undefined\n\n\t/**\n\t * Specifies the `Date` object to be the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.1|`Expires` `Set-Cookie` attribute}. By default,\n\t * no expiration is set, and most clients will consider this a \"non-persistent cookie\" and will delete\n\t * it on a condition like exiting a web browser application.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\texpires?: Date | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.6|`HttpOnly` `Set-Cookie` attribute}.\n\t * When truthy, the `HttpOnly` attribute is set, otherwise it is not. By\n\t * default, the `HttpOnly` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to true, as compliant clients will\n\t * not allow client-side JavaScript to see the cookie in `document.cookie`.\n\t */\n\thttpOnly?: boolean | undefined\n\t/**\n\t * Specifies the number (in seconds) to be the value for the `Max-Age`\n\t * `Set-Cookie` attribute. The given number will be converted to an integer\n\t * by rounding down. By default, no maximum age is set.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\tmaxAge?: number | undefined\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.4|`Path` `Set-Cookie` attribute}.\n\t * By default, the path is considered the \"default path\".\n\t */\n\tpath?: string | undefined\n\t/**\n\t * Specifies the `string` to be the value for the [`Priority` `Set-Cookie` attribute][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * - `'low'` will set the `Priority` attribute to `Low`.\n\t * - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.\n\t * - `'high'` will set the `Priority` attribute to `High`.\n\t *\n\t * More information about the different priority levels can be found in\n\t * [the specification][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * **note** This is an attribute that has not yet been fully standardized, and may change in the future.\n\t * This also means many clients may ignore this attribute until they understand it.\n\t */\n\tpriority?: 'low' | 'medium' | 'high' | undefined\n\t/**\n\t * Specifies the `boolean` value for the [`Partitioned` `Set-Cookie`](rfc-cutler-httpbis-partitioned-cookies)\n\t * attribute. When truthy, the `Partitioned` attribute is set, otherwise it is not. By default, the\n\t * `Partitioned` attribute is not set.\n\t *\n\t * **note** This is an attribute that has not yet been fully standardized, and may change in the future.\n\t * This also means many clients may ignore this attribute until they understand it.\n\t *\n\t * More information about can be found in [the proposal](https://github.com/privacycg/CHIPS)\n\t */\n\tpartitioned?: boolean | undefined\n\t/**\n\t * Specifies the boolean or string to be the value for the {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|`SameSite` `Set-Cookie` attribute}.\n\t *\n\t * - `true` will set the `SameSite` attribute to `Strict` for strict same\n\t * site enforcement.\n\t * - `false` will not set the `SameSite` attribute.\n\t * - `'lax'` will set the `SameSite` attribute to Lax for lax same site\n\t * enforcement.\n\t * - `'strict'` will set the `SameSite` attribute to Strict for strict same\n\t * site enforcement.\n\t *  - `'none'` will set the SameSite attribute to None for an explicit\n\t *  cross-site cookie.\n\t *\n\t * More information about the different enforcement levels can be found in {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|the specification}.\n\t *\n\t * *note* This is an attribute that has not yet been fully standardized, and may change in the future. This also means many clients may ignore this attribute until they understand it.\n\t */\n\tsameSite?: true | false | 'lax' | 'strict' | 'none' | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.5|`Secure` `Set-Cookie` attribute}. When truthy, the\n\t * `Secure` attribute is set, otherwise it is not. By default, the `Secure` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to `true`, as compliant clients will\n\t * not send the cookie back to the server in the future if the browser does\n\t * not have an HTTPS connection.\n\t */\n\tsecure?: boolean | undefined\n\n\t/**\n\t * Secret key for signing cookie\n\t *\n\t * If array is passed, will use Key Rotation.\n\t *\n\t * Key rotation is when an encryption key is retired\n\t * and replaced by generating a new cryptographic key.\n\t */\n\tsecrets?: string | string[]\n}\n\nexport type ElysiaCookie = Prettify<\n\tCookieOptions & {\n\t\tvalue?: unknown\n\t}\n>\n\ntype Updater<T> = T | ((value: T) => T)\n\nexport class Cookie<T> implements ElysiaCookie {\n\tconstructor(\n\t\tprivate name: string,\n\t\tprivate jar: Record<string, ElysiaCookie>,\n\t\tprivate initial: Partial<ElysiaCookie> = {}\n\t) {}\n\n\tget cookie() {\n\t\tif (!(this.name in this.jar)) return this.initial\n\n\t\treturn this.jar[this.name]\n\t}\n\n\tset cookie(jar: ElysiaCookie) {\n\t\tif (!(this.name in this.jar)) this.jar[this.name] = this.initial\n\n\t\tthis.jar[this.name] = jar\n\t}\n\n\tget value(): T {\n\t\treturn this.cookie.value as T\n\t}\n\n\tset value(value: T) {\n\t\tif (!(this.name in this.jar)) this.jar[this.name] = this.initial\n\n\t\tthis.jar[this.name].value = value\n\t}\n\n\tget expires() {\n\t\treturn this.cookie.expires\n\t}\n\n\tset expires(expires) {\n\t\tthis.cookie.expires = expires\n\t}\n\n\tget maxAge() {\n\t\treturn this.cookie.maxAge\n\t}\n\n\tset maxAge(maxAge) {\n\t\tthis.cookie.maxAge = maxAge\n\t}\n\n\tget domain() {\n\t\treturn this.cookie.domain\n\t}\n\n\tset domain(domain) {\n\t\tthis.cookie.domain = domain\n\t}\n\n\tget path() {\n\t\treturn this.cookie.path\n\t}\n\n\tset path(path) {\n\t\tthis.cookie.path = path\n\t}\n\n\tget secure() {\n\t\treturn this.cookie.secure\n\t}\n\n\tset secure(secure) {\n\t\tthis.cookie.secure = secure\n\t}\n\n\tget httpOnly() {\n\t\treturn this.cookie.httpOnly\n\t}\n\n\tset httpOnly(httpOnly) {\n\t\tthis.cookie.httpOnly = httpOnly\n\t}\n\n\tget sameSite() {\n\t\treturn this.cookie.sameSite\n\t}\n\n\tset sameSite(sameSite) {\n\t\tthis.cookie.sameSite = sameSite\n\t}\n\n\tget priority() {\n\t\treturn this.cookie.priority\n\t}\n\n\tset priority(priority) {\n\t\tthis.cookie.priority = priority\n\t}\n\n\tget partitioned() {\n\t\treturn this.cookie.partitioned\n\t}\n\n\tset partitioned(partitioned) {\n\t\tthis.cookie.partitioned = partitioned\n\t}\n\n\tget secrets() {\n\t\treturn this.cookie.secrets\n\t}\n\n\tset secrets(secrets) {\n\t\tthis.cookie.secrets = secrets\n\t}\n\n\tupdate(config: Updater<Partial<ElysiaCookie>>) {\n\t\tthis.cookie = Object.assign(\n\t\t\tthis.cookie,\n\t\t\ttypeof config === 'function' ? config(this.cookie) : config\n\t\t)\n\n\t\treturn this\n\t}\n\n\tset(config: Updater<Partial<ElysiaCookie>>) {\n\t\tthis.cookie = Object.assign(\n\t\t\t{\n\t\t\t\t...this.initial,\n\t\t\t\tvalue: this.value\n\t\t\t},\n\t\t\ttypeof config === 'function' ? config(this.cookie) : config\n\t\t)\n\n\t\treturn this\n\t}\n\n\tremove() {\n\t\tif (this.value === undefined) return\n\n\t\tthis.set({\n\t\t\texpires: new Date(0),\n\t\t\tmaxAge: 0,\n\t\t\tvalue: ''\n\t\t})\n\n\t\treturn this\n\t}\n\n\ttoString() {\n\t\treturn typeof this.value === 'object'\n\t\t\t? JSON.stringify(this.value)\n\t\t\t: this.value?.toString() ?? ''\n\t}\n}\n\nexport const createCookieJar = (\n\tset: Context['set'],\n\tstore: Record<string, ElysiaCookie>,\n\tinitial?: Partial<ElysiaCookie>\n): Record<string, Cookie<unknown>> => {\n\tif (!set.cookie) set.cookie = {}\n\n\treturn new Proxy(store, {\n\t\tget(_, key: string) {\n\t\t\tif (key in store)\n\t\t\t\treturn new Cookie(\n\t\t\t\t\tkey,\n\t\t\t\t\tset.cookie as Record<string, ElysiaCookie>,\n\t\t\t\t\tObject.assign({}, initial ?? {}, store[key])\n\t\t\t\t)\n\n\t\t\treturn new Cookie(\n\t\t\t\tkey,\n\t\t\t\tset.cookie as Record<string, ElysiaCookie>,\n\t\t\t\tObject.assign({}, initial)\n\t\t\t)\n\t\t}\n\t}) as Record<string, Cookie<unknown>>\n}\n\nexport const parseCookie = async (\n\tset: Context['set'],\n\tcookieString?: string | null,\n\t{\n\t\tsecrets,\n\t\tsign,\n\t\t...initial\n\t}: CookieOptions & {\n\t\tsign?: true | string | string[]\n\t} = {}\n) => {\n\tif (!cookieString) return createCookieJar(set, {}, initial)\n\n\tconst isStringKey = typeof secrets === 'string'\n\tif (sign && sign !== true && !Array.isArray(sign)) sign = [sign]\n\n\tconst jar: Record<string, ElysiaCookie> = {}\n\n\tconst cookies = parse(cookieString)\n\tfor (const [name, v] of Object.entries(cookies)) {\n\t\tlet value = decodeURIComponent(v)\n\n\t\tif (sign === true || sign?.includes(name)) {\n\t\t\tif (!secrets)\n\t\t\t\tthrow new Error('No secret is provided to cookie plugin')\n\n\t\t\tif (isStringKey) {\n\t\t\t\tconst temp = await unsignCookie(value as string, secrets)\n\t\t\t\tif (temp === false) throw new InvalidCookieSignature(name)\n\n\t\t\t\tvalue = temp\n\t\t\t} else {\n\t\t\t\tlet decoded = true\n\t\t\t\tfor (let i = 0; i < secrets.length; i++) {\n\t\t\t\t\tconst temp = await unsignCookie(value as string, secrets[i])\n\n\t\t\t\t\tif (temp !== false) {\n\t\t\t\t\t\tdecoded = true\n\t\t\t\t\t\tvalue = temp\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!decoded) throw new InvalidCookieSignature(name)\n\t\t\t}\n\t\t}\n\n\t\tjar[name] = {\n\t\t\tvalue\n\t\t}\n\t}\n\n\treturn createCookieJar(set, jar, initial)\n}\n",
    "/* eslint-disable sonarjs/no-nested-switch */\n/* eslint-disable sonarjs/no-duplicate-string */\nimport { serialize } from 'cookie'\nimport { StatusMap, form } from './utils'\n\nimport { Cookie } from './cookies'\nimport { ELYSIA_RESPONSE } from './error'\n\nimport type { Context } from './context'\n\nconst hasHeaderShorthand = 'toJSON' in new Headers()\n\ntype SetResponse = Omit<Context['set'], 'status'> & {\n\tstatus: number\n}\n\nexport const isNotEmpty = (obj?: Object) => {\n\tif (!obj) return false\n\n\tfor (const x in obj) return true\n\n\treturn false\n}\n\nconst handleFile = (response: File | Blob, set?: Context['set']) => {\n\tconst size = response.size\n\n\tif (\n\t\t(!set && size) ||\n\t\t(size &&\n\t\t\tset &&\n\t\t\tset.status !== 206 &&\n\t\t\tset.status !== 304 &&\n\t\t\tset.status !== 412 &&\n\t\t\tset.status !== 416)\n\t) {\n\t\tif (set) {\n\t\t\tif (set.headers instanceof Headers)\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\tset.headers = (set.headers as unknown as Headers).toJSON()\n\t\t\t\telse\n\t\t\t\t\tfor (const [key, value] of set.headers.entries())\n\t\t\t\t\t\tif (key in set.headers) set.headers[key] = value\n\n\t\t\treturn new Response(response as Blob, {\n\t\t\t\tstatus: set.status as number,\n\t\t\t\theaders: Object.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`\n\t\t\t\t\t},\n\t\t\t\t\tset.headers\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\n\t\treturn new Response(response as Blob, {\n\t\t\theaders: {\n\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`\n\t\t\t}\n\t\t})\n\t}\n\n\treturn new Response(response as Blob)\n}\n\nexport const parseSetCookies = (headers: Headers, setCookie: string[]) => {\n\tif (!headers) return headers\n\n\theaders.delete('set-cookie')\n\n\tfor (let i = 0; i < setCookie.length; i++) {\n\t\tconst index = setCookie[i].indexOf('=')\n\n\t\theaders.append(\n\t\t\t'set-cookie',\n\t\t\t`${setCookie[i].slice(0, index)}=${\n\t\t\t\tsetCookie[i].slice(index + 1) || ''\n\t\t\t}`\n\t\t)\n\t}\n\n\treturn headers\n}\n\nexport const serializeCookie = (cookies: Context['set']['cookie']) => {\n\tif (!cookies || !isNotEmpty(cookies)) return undefined\n\n\tconst set: string[] = []\n\n\tfor (const [key, property] of Object.entries(cookies)) {\n\t\tif (!key || !property) continue\n\n\t\tconst value = property.value\n\t\tif (value === undefined || value === null) continue\n\n\t\tset.push(\n\t\t\tserialize(\n\t\t\t\tkey,\n\t\t\t\ttypeof value === 'object' ? JSON.stringify(value) : value + '',\n\t\t\t\tproperty\n\t\t\t)\n\t\t)\n\t}\n\n\tif (set.length === 0) return undefined\n\tif (set.length === 1) return set[0]\n\n\treturn set\n}\n\n// const concatUint8Array = (a: Uint8Array, b: Uint8Array) => {\n// \tconst arr = new Uint8Array(a.length + b.length)\n// \tarr.set(a, 0)\n// \tarr.set(b, a.length)\n\n// \treturn arr\n// }\n\nconst handleStream = async (\n\tgenerator: Generator | AsyncGenerator,\n\tset?: Context['set'],\n\trequest?: Request\n) => {\n\tlet init = generator.next()\n\tif (init instanceof Promise) init = await init\n\n\tif (init.done) {\n\t\tif (set) return mapResponse(init.value, set, request)\n\t\treturn mapCompactResponse(init.value, request)\n\t}\n\n\treturn new Response(\n\t\tnew ReadableStream({\n\t\t\tasync start(controller) {\n\t\t\t\tlet end = false\n\n\t\t\t\trequest?.signal.addEventListener('abort', () => {\n\t\t\t\t\tend = true\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcontroller.close()\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// nothing\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tif (init.value !== undefined && init.value !== null)\n\t\t\t\t\tcontroller.enqueue(Buffer.from(init.value.toString()))\n\n\t\t\t\tfor await (const chunk of generator) {\n\t\t\t\t\tif (end) break\n\t\t\t\t\tif (chunk === undefined || chunk === null) continue\n\n\t\t\t\t\tcontroller.enqueue(Buffer.from(chunk.toString()))\n\n\t\t\t\t\t// Wait for the next event loop\n\t\t\t\t\t// Otherwise the data will be mixed up\n\t\t\t\t\tawait new Promise<void>((resolve) =>\n\t\t\t\t\t\tsetTimeout(() => resolve(), 0)\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tcontroller.close()\n\t\t\t\t} catch {\n\t\t\t\t\t// nothing\n\t\t\t\t}\n\t\t\t}\n\t\t}),\n\t\t{\n\t\t\t...(set as ResponseInit),\n\t\t\theaders: {\n\t\t\t\t// Manually set transfer-encoding for direct response, eg. app.handle, eden\n\t\t\t\t'transfer-encoding': 'chunked',\n\t\t\t\t'content-type': 'text/event-stream; charset=utf-8',\n\t\t\t\t...set?.headers\n\t\t\t}\n\t\t}\n\t)\n}\n\nexport const mapResponse = (\n\tresponse: unknown,\n\tset: Context['set'],\n\trequest?: Request\n): Response => {\n\tif (\n\t\tisNotEmpty(set.headers) ||\n\t\tset.status !== 200 ||\n\t\tset.redirect ||\n\t\tset.cookie\n\t) {\n\t\tif (typeof set.status === 'string') set.status = StatusMap[set.status]\n\n\t\tif (set.redirect) {\n\t\t\tset.headers.Location = set.redirect\n\t\t\tif (!set.status || set.status < 300 || set.status >= 400)\n\t\t\t\tset.status = 302\n\t\t}\n\n\t\tif (set.cookie && isNotEmpty(set.cookie)) {\n\t\t\tconst cookie = serializeCookie(set.cookie)\n\n\t\t\tif (cookie) set.headers['set-cookie'] = cookie\n\t\t}\n\n\t\tif (\n\t\t\tset.headers['set-cookie'] &&\n\t\t\tArray.isArray(set.headers['set-cookie'])\n\t\t) {\n\t\t\tset.headers = parseSetCookies(\n\t\t\t\tnew Headers(set.headers) as Headers,\n\t\t\t\tset.headers['set-cookie']\n\t\t\t) as any\n\t\t}\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string, set as SetResponse)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'Object':\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst status = response[ELYSIA_RESPONSE]\n\t\t\t\tif (status) {\n\t\t\t\t\tset.status = status\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn mapResponse(response.response, set, request)\n\t\t\t\t}\n\n\t\t\t\tfor (const value in Object.values(response as Object)) {\n\t\t\t\t\tswitch (value?.constructor?.name) {\n\t\t\t\t\t\tcase 'Blob':\n\t\t\t\t\t\tcase 'File':\n\t\t\t\t\t\tcase 'ArrayBuffer':\n\t\t\t\t\t\tcase 'FileRef':\n\t\t\t\t\t\t\treturn new Response(form(response as any))\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\trequest?.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (!request?.signal.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel(request)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(\n\t\t\t\t\tresponse as ReadableStream,\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('', set as SetResponse)\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'Response':\n\t\t\t\tlet isCookieSet = false\n\n\t\t\t\tif (set.headers instanceof Headers)\n\t\t\t\t\tfor (const key of set.headers.keys()) {\n\t\t\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\t\t\tif (isCookieSet) continue\n\n\t\t\t\t\t\t\tisCookieSet = true\n\n\t\t\t\t\t\t\tfor (const cookie of set.headers.getSetCookie()) {\n\t\t\t\t\t\t\t\t;(response as Response).headers.append(\n\t\t\t\t\t\t\t\t\t'set-cookie',\n\t\t\t\t\t\t\t\t\tcookie\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t(response as Response).headers.append(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tset.headers?.get(key) ?? ''\n\t\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfor (const key in set.headers)\n\t\t\t\t\t\t(response as Response).headers.append(\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tset.headers[key]\n\t\t\t\t\t\t)\n\n\t\t\t\tif ((response as Response).status !== set.status)\n\t\t\t\t\tset.status = (response as Response).status\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Promise':\n\t\t\t\treturn (response as Promise<any>).then((x) =>\n\t\t\t\t\tmapResponse(x, set)\n\t\t\t\t) as any\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapResponse((response as Function)(), set)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData, set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) {\n\t\t\t\t\tlet isCookieSet = false\n\n\t\t\t\t\tif (set.headers instanceof Headers)\n\t\t\t\t\t\tfor (const key of set.headers.keys()) {\n\t\t\t\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\t\t\t\tif (isCookieSet) continue\n\n\t\t\t\t\t\t\t\tisCookieSet = true\n\n\t\t\t\t\t\t\t\tfor (const cookie of set.headers.getSetCookie()) {\n\t\t\t\t\t\t\t\t\t;(response as Response).headers.append(\n\t\t\t\t\t\t\t\t\t\t'set-cookie',\n\t\t\t\t\t\t\t\t\t\tcookie\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t(response as Response).headers.append(\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\tset.headers?.get(key) ?? ''\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfor (const key in set.headers)\n\t\t\t\t\t\t\t(response as Response).headers.append(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tset.headers[key]\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\t\tset.headers = (\n\t\t\t\t\t\t\t(response as Response).headers as Headers\n\t\t\t\t\t\t).toJSON()\n\t\t\t\t\telse\n\t\t\t\t\t\tfor (const [key, value] of (\n\t\t\t\t\t\t\tresponse as Response\n\t\t\t\t\t\t).headers.entries())\n\t\t\t\t\t\t\tif (key in set.headers) set.headers[key] = value\n\n\t\t\t\t\treturn response as Response\n\t\t\t\t}\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn handleStream(response as any, set, request)\n\n\t\t\t\tif ('toResponse' in (response as any))\n\t\t\t\t\treturn mapResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any, set as SetResponse)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response)\n\n\t\t\tcase 'Object':\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst status = response[ELYSIA_RESPONSE]\n\t\t\t\tif (status) {\n\t\t\t\t\tset.status = status\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn mapResponse(response.response, set, request)\n\t\t\t\t}\n\n\t\t\t\tfor (const value in Object.values(response as Object)) {\n\t\t\t\t\tswitch (value?.constructor?.name) {\n\t\t\t\t\t\tcase 'Blob':\n\t\t\t\t\t\tcase 'File':\n\t\t\t\t\t\tcase 'ArrayBuffer':\n\t\t\t\t\t\tcase 'FileRef':\n\t\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\t\tform(response as any),\n\t\t\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\trequest?.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (!request?.signal.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel(request)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as any as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapCompactResponse(x, request)\n\n\t\t\t\t\tif (r !== undefined) return r\n\n\t\t\t\t\treturn new Response('')\n\t\t\t\t})\n\n\t\t\t// ? Maybe response or Blob\n\t\t\tcase 'Function':\n\t\t\t\treturn mapCompactResponse((response as Function)(), request)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData, set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response)\n\t\t\t\t\treturn new Response(response.body, {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn handleStream(response as any, set, request)\n\n\t\t\t\tif ('toResponse' in (response as any))\n\t\t\t\t\treturn mapResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any)\n\t\t}\n}\n\nexport const mapEarlyResponse = (\n\tresponse: unknown,\n\tset: Context['set'],\n\trequest?: Request\n): Response | undefined => {\n\tif (response === undefined || response === null) return\n\n\tif (\n\t\tisNotEmpty(set.headers) ||\n\t\tset.status !== 200 ||\n\t\tset.redirect ||\n\t\tset.cookie\n\t) {\n\t\tif (typeof set.status === 'string') set.status = StatusMap[set.status]\n\n\t\tif (set.redirect) {\n\t\t\tset.headers.Location = set.redirect\n\n\t\t\tif (!set.status || set.status < 300 || set.status >= 400)\n\t\t\t\tset.status = 302\n\t\t}\n\n\t\tif (set.cookie && isNotEmpty(set.cookie)) {\n\t\t\tconst cookie = serializeCookie(set.cookie)\n\n\t\t\tif (cookie) set.headers['set-cookie'] = cookie\n\t\t}\n\n\t\tif (\n\t\t\tset.headers['set-cookie'] &&\n\t\t\tArray.isArray(set.headers['set-cookie'])\n\t\t)\n\t\t\tset.headers = parseSetCookies(\n\t\t\t\tnew Headers(set.headers) as Headers,\n\t\t\t\tset.headers['set-cookie']\n\t\t\t) as any\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string, set as SetResponse)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'Object':\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst status = response[ELYSIA_RESPONSE]\n\t\t\t\tif (status) {\n\t\t\t\t\tset.status = status\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn mapEarlyResponse(response.response, set, request)\n\t\t\t\t}\n\n\t\t\t\tfor (const value in Object.values(response as Object)) {\n\t\t\t\t\tswitch (value?.constructor?.name) {\n\t\t\t\t\t\tcase 'Blob':\n\t\t\t\t\t\tcase 'File':\n\t\t\t\t\t\tcase 'ArrayBuffer':\n\t\t\t\t\t\tcase 'FileRef':\n\t\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\t\tform(response as any),\n\t\t\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\trequest?.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (!request?.signal.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel(request)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(\n\t\t\t\t\tresponse as ReadableStream,\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'Response':\n\t\t\t\tlet isCookieSet = false\n\n\t\t\t\tif (set.headers instanceof Headers)\n\t\t\t\t\tfor (const key of set.headers.keys()) {\n\t\t\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\t\t\tif (isCookieSet) continue\n\n\t\t\t\t\t\t\tisCookieSet = true\n\n\t\t\t\t\t\t\tfor (const cookie of set.headers.getSetCookie()) {\n\t\t\t\t\t\t\t\t;(response as Response).headers.append(\n\t\t\t\t\t\t\t\t\t'set-cookie',\n\t\t\t\t\t\t\t\t\tcookie\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t(response as Response).headers.append(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tset.headers?.get(key) ?? ''\n\t\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfor (const key in set.headers)\n\t\t\t\t\t\t(response as Response).headers.append(\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tset.headers[key]\n\t\t\t\t\t\t)\n\n\t\t\t\tif ((response as Response).status !== set.status)\n\t\t\t\t\tset.status = (response as Response).status\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\t\t\t\t\tif (r !== undefined) return r\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapEarlyResponse((response as Function)(), set)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as SetResponse\n\t\t\t\t)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) {\n\t\t\t\t\tlet isCookieSet = false\n\n\t\t\t\t\tif (set.headers instanceof Headers)\n\t\t\t\t\t\tfor (const key of set.headers.keys()) {\n\t\t\t\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\t\t\t\tif (isCookieSet) continue\n\n\t\t\t\t\t\t\t\tisCookieSet = true\n\n\t\t\t\t\t\t\t\tfor (const cookie of set.headers.getSetCookie()) {\n\t\t\t\t\t\t\t\t\t;(response as Response).headers.append(\n\t\t\t\t\t\t\t\t\t\t'set-cookie',\n\t\t\t\t\t\t\t\t\t\tcookie\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t(response as Response).headers.append(\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\tset.headers?.get(key) ?? ''\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfor (const key in set.headers)\n\t\t\t\t\t\t\t(response as Response).headers.append(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tset.headers[key]\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\tif ((response as Response).status !== set.status)\n\t\t\t\t\t\tset.status = (response as Response).status\n\n\t\t\t\t\treturn response as Response\n\t\t\t\t}\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn handleStream(response as any, set, request)\n\n\t\t\t\tif ('toResponse' in (response as any))\n\t\t\t\t\treturn mapEarlyResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any, set as SetResponse)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'Array':\n\t\t\t\treturn Response.json(response)\n\n\t\t\tcase 'Object':\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst status = response[ELYSIA_RESPONSE]\n\t\t\t\tif (status) {\n\t\t\t\t\tset.status = status\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn mapEarlyResponse(response.response, set, request)\n\t\t\t\t}\n\n\t\t\t\tfor (const value in Object.values(response as Object)) {\n\t\t\t\t\tswitch (value?.constructor?.name) {\n\t\t\t\t\t\tcase 'Blob':\n\t\t\t\t\t\tcase 'File':\n\t\t\t\t\t\tcase 'ArrayBuffer':\n\t\t\t\t\t\tcase 'FileRef':\n\t\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\t\tform(response as any),\n\t\t\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Response.json(response, set as SetResponse)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\trequest?.signal.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (!request?.signal.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel(request)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\t\t\t\t\tif (r !== undefined) return r\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapCompactResponse((response as Function)(), request)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as SetResponse)\n\n\t\t\t\treturn new Response(response?.toString(), set as SetResponse)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response)\n\t\t\t\t\treturn new Response(response.body, {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn handleStream(response as any, set, request)\n\n\t\t\t\tif ('toResponse' in (response as any))\n\t\t\t\t\treturn mapEarlyResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as SetResponse\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any)\n\t\t}\n}\n\nexport const mapCompactResponse = (\n\tresponse: unknown,\n\trequest?: Request\n): Response => {\n\tswitch (response?.constructor?.name) {\n\t\tcase 'String':\n\t\t\treturn new Response(response as string)\n\n\t\tcase 'Blob':\n\t\t\treturn handleFile(response as File | Blob)\n\n\t\tcase 'Array':\n\t\t\treturn Response.json(response)\n\n\t\tcase 'Object':\n\t\t\t// @ts-ignore\n\t\t\tif (response[ELYSIA_RESPONSE])\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn mapResponse(response.response, {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tstatus: response[ELYSIA_RESPONSE],\n\t\t\t\t\theaders: {}\n\t\t\t\t})\n\n\t\t\tform: for (const value of Object.values(response as Object))\n\t\t\t\tswitch (value?.constructor?.name) {\n\t\t\t\t\tcase 'Blob':\n\t\t\t\t\tcase 'File':\n\t\t\t\t\tcase 'ArrayBuffer':\n\t\t\t\t\tcase 'FileRef':\n\t\t\t\t\t\treturn new Response(form(response as any))\n\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tbreak form\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\treturn Response.json(response)\n\n\t\tcase 'ReadableStream':\n\t\t\trequest?.signal.addEventListener(\n\t\t\t\t'abort',\n\t\t\t\t{\n\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\tif (!request?.signal.aborted)\n\t\t\t\t\t\t\t(response as ReadableStream).cancel(request)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tonce: true\n\t\t\t\t}\n\t\t\t)\n\n\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase undefined:\n\t\t\tif (!response) return new Response('')\n\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'Response':\n\t\t\treturn response as Response\n\n\t\tcase 'Error':\n\t\t\treturn errorToResponse(response as Error)\n\n\t\tcase 'Promise':\n\t\t\t// @ts-ignore\n\t\t\treturn (response as any as Promise<unknown>).then((x) =>\n\t\t\t\tmapCompactResponse(x, request)\n\t\t\t)\n\n\t\t// ? Maybe response or Blob\n\t\tcase 'Function':\n\t\t\treturn mapCompactResponse((response as Function)(), request)\n\n\t\tcase 'Number':\n\t\tcase 'Boolean':\n\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\tcase 'FormData':\n\t\t\treturn new Response(response as FormData)\n\n\t\tdefault:\n\t\t\tif (response instanceof Response)\n\t\t\t\treturn new Response(response.body, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tif (response instanceof Promise)\n\t\t\t\treturn response.then((x) =>\n\t\t\t\t\tmapCompactResponse(x, request)\n\t\t\t\t) as any\n\n\t\t\tif (response instanceof Error)\n\t\t\t\treturn errorToResponse(response as Error)\n\n\t\t\t// @ts-expect-error\n\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t// @ts-expect-error\n\t\t\t\treturn handleStream(response as any, undefined, request)\n\n\t\t\tif ('toResponse' in (response as any))\n\t\t\t\treturn mapCompactResponse((response as any).toResponse())\n\n\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as any\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new Response(response as any)\n\t}\n}\n\nexport const errorToResponse = (error: Error, set?: Context['set']) =>\n\tnew Response(\n\t\tJSON.stringify({\n\t\t\tname: error?.name,\n\t\t\tmessage: error?.message,\n\t\t\tcause: error?.cause\n\t\t}),\n\t\t{\n\t\t\tstatus:\n\t\t\t\tset?.status !== 200 ? ((set?.status as number) ?? 500) : 500,\n\t\t\theaders: set?.headers\n\t\t}\n\t)\n",
    "import type { ServerWebSocket, WebSocketHandler } from 'bun'\n\nimport type { TSchema } from '@sinclair/typebox'\nimport type { TypeCheck } from '@sinclair/typebox/compiler'\n\nimport { ValidationError } from '../error'\nimport type { Context } from '../context'\n\nimport type { SingletonBase, RouteSchema, Prettify } from '../types'\nimport { randomId } from '../utils'\n\nexport const websocket: WebSocketHandler<any> = {\n\topen(ws) {\n\t\tws.data.open?.(ws)\n\t},\n\tmessage(ws, message) {\n\t\tws.data.message?.(ws, message)\n\t},\n\tdrain(ws) {\n\t\tws.data.drain?.(ws)\n\t},\n\tclose(ws, code, reason) {\n\t\tws.data.close?.(ws, code, reason)\n\t}\n}\n\nexport class ElysiaWS<\n\tWS extends ServerWebSocket<{\n\t\tid?: string\n\t\tvalidator?: TypeCheck<TSchema>\n\t}>,\n\tRoute extends RouteSchema = RouteSchema,\n\tSingleton extends SingletonBase = {\n\t\tdecorator: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t}\n> {\n\tvalidator?: TypeCheck<TSchema>\n\t_validator?: Prettify<Route>\n\n\tconstructor(\n\t\tpublic raw: WS,\n\t\tpublic data: Context<Route, Singleton>\n\t) {\n\t\tthis.validator = raw.data.validator\n\t\tif (raw.data.id) {\n\t\t\tthis.id = raw.data.id\n\t\t} else {\n\t\t\tthis.id = randomId().toString()\n\t\t}\n\t}\n\n\tget id() {\n\t\treturn this.raw.data.id!\n\t}\n\n\tset id(newID: string) {\n\t\tthis.raw.data.id = newID\n\t}\n\n\tget publish() {\n\t\treturn (\n\t\t\ttopic: string,\n\t\t\tdata: Route['response'] = undefined,\n\t\t\tcompress?: boolean\n\t\t) => {\n\t\t\tif (this.validator?.Check(data) === false)\n\t\t\t\tthrow new ValidationError('message', this.validator, data)\n\n\t\t\tif (typeof data === 'object') data = JSON.stringify(data)\n\n\t\t\tthis.raw.publish(topic, data as unknown as string, compress)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget send() {\n\t\treturn (\n\t\t\tdata: {} extends Route['response']\n\t\t\t\t? unknown\n\t\t\t\t: Route['response'] extends Record<200, unknown>\n\t\t\t\t\t? Route['response'][200]\n\t\t\t\t\t: unknown\n\t\t) => {\n\t\t\tif (this.validator?.Check(data) === false)\n\t\t\t\tthrow new ValidationError('message', this.validator, data)\n\n\t\t\tif (Buffer.isBuffer(data)) {\n\t\t\t\tthis.raw.send(data as unknown as Buffer)\n\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\tif (typeof data === 'object') data = JSON.stringify(data)\n\n\t\t\tthis.raw.send(data as unknown as string)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget subscribe() {\n\t\treturn (room: string) => {\n\t\t\tthis.raw.subscribe(room)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget unsubscribe() {\n\t\treturn (room: string) => {\n\t\t\tthis.raw.unsubscribe(room)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget cork() {\n\t\treturn (callback: () => this) => {\n\t\t\tthis.raw.cork(callback as any)\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget close() {\n\t\treturn () => {\n\t\t\tthis.raw.close()\n\n\t\t\treturn this\n\t\t}\n\t}\n\n\tget terminate() {\n\t\treturn this.raw.terminate.bind(this.raw)\n\t}\n\n\tget isSubscribed() {\n\t\treturn this.raw.isSubscribed.bind(this.raw)\n\t}\n\n\tget remoteAddress() {\n\t\treturn this.raw.remoteAddress\n\t}\n}\n",
    "import { type Elysia } from '.'\n\nimport { Value } from '@sinclair/typebox/value'\nimport type { TAnySchema, TSchema } from '@sinclair/typebox'\n\nimport { parseQuery } from './fast-querystring'\n\n// @ts-ignore\nimport decodeURIComponent from 'fast-decode-uri-component'\n\nimport {\n\tELYSIA_REQUEST_ID,\n\tgetCookieValidator,\n\tlifeCycleToFn,\n\trandomId,\n\tredirect,\n\tsignCookie\n} from './utils'\nimport { ParseError, error } from './error'\n\nimport {\n\tmapEarlyResponse,\n\tmapResponse,\n\tmapCompactResponse,\n\tisNotEmpty\n} from './handler'\nimport {\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tERROR_CODE,\n\tELYSIA_RESPONSE\n} from './error'\nimport { ELYSIA_TRACE, type TraceHandler } from './trace'\n\nimport { Sucrose, hasReturn, sucrose } from './sucrose'\nimport { parseCookie, type CookieOptions } from './cookies'\n\nimport type { TraceEvent } from './trace'\nimport type {\n\tComposedHandler,\n\tHandler,\n\tHookContainer,\n\tLifeCycleStore,\n\tSchemaValidator\n} from './types'\nimport type { TypeCheck } from './type-system'\n\nconst headersHasToJSON = (new Headers() as Headers).toJSON\n\nconst TypeBoxSymbol = {\n\toptional: Symbol.for('TypeBox.Optional'),\n\tkind: Symbol.for('TypeBox.Kind')\n} as const\n\nconst isOptional = (validator?: TypeCheck<any>) => {\n\tif (!validator) return false\n\n\t// @ts-expect-error\n\tconst schema = validator?.schema\n\n\treturn !!schema && TypeBoxSymbol.optional in schema\n}\n\nexport const hasAdditionalProperties = (\n\t_schema: TAnySchema | TypeCheck<any>\n) => {\n\tif (!_schema) return false\n\n\t// @ts-expect-error private property\n\tconst schema: TAnySchema = (_schema as TypeCheck<any>)?.schema ?? _schema\n\n\tif (schema.anyOf) return schema.anyOf.some(hasAdditionalProperties)\n\tif (schema.someOf) return schema.someOf.some(hasAdditionalProperties)\n\tif (schema.allOf) return schema.allOf.some(hasAdditionalProperties)\n\tif (schema.not) return schema.not.some(hasAdditionalProperties)\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tif ('additionalProperties' in schema) return schema.additionalProperties\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasAdditionalProperties(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasAdditionalProperties(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\treturn property.additionalProperties\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn false\n}\n\nconst createReport = ({\n\tcontext = 'c',\n\ttrace,\n\taddFn\n}: {\n\tcontext?: string\n\ttrace: (TraceHandler | HookContainer<TraceHandler>)[]\n\taddFn(string: string): void\n}) => {\n\tif (!trace.length)\n\t\treturn () => {\n\t\t\treturn {\n\t\t\t\tresolveChild() {\n\t\t\t\t\treturn () => {}\n\t\t\t\t},\n\t\t\t\tresolve() {}\n\t\t\t}\n\t\t}\n\n\tfor (let i = 0; i < trace.length; i++)\n\t\taddFn(\n\t\t\t`let report${i}, reportChild${i}, reportErr${i}, reportErrChild${i}; let trace${i} = ${context}[ELYSIA_TRACE]?.[${i}] ?? trace[${i}](${context});\\n`\n\t\t)\n\n\treturn (\n\t\tevent: TraceEvent,\n\t\t{\n\t\t\tname,\n\t\t\ttotal = 0\n\t\t}: {\n\t\t\tname?: string\n\t\t\tattribute?: string\n\t\t\ttotal?: number\n\t\t} = {}\n\t) => {\n\t\t// ? For debug specific event\n\t\t// if (event !== 'mapResponse')\n\t\t// \treturn {\n\t\t// \t\tresolveChild() {\n\t\t// \t\t\treturn () => {}\n\t\t// \t\t},\n\t\t// \t\tresolve() {}\n\t\t// \t}\n\n\t\tif (!name) name = 'anonymous'\n\n\t\tconst reporter = event === 'error' ? 'reportErr' : 'report'\n\n\t\tfor (let i = 0; i < trace.length; i++)\n\t\t\taddFn(\n\t\t\t\t`\\n${reporter}${i} = trace${i}.${event}({` +\n\t\t\t\t\t`id,` +\n\t\t\t\t\t`event: '${event}',` +\n\t\t\t\t\t`name: '${name}',` +\n\t\t\t\t\t`begin: performance.now(),` +\n\t\t\t\t\t`total: ${total}` +\n\t\t\t\t\t`})\\n`\n\t\t\t)\n\n\t\treturn {\n\t\t\tresolve() {\n\t\t\t\tfor (let i = 0; i < trace.length; i++)\n\t\t\t\t\taddFn(`\\n${reporter}${i}.resolve()\\n`)\n\t\t\t},\n\t\t\tresolveChild(name: string) {\n\t\t\t\tfor (let i = 0; i < trace.length; i++)\n\t\t\t\t\taddFn(\n\t\t\t\t\t\t`${reporter}Child${i} = ${reporter}${i}.resolveChild?.shift()?.({` +\n\t\t\t\t\t\t\t`id,` +\n\t\t\t\t\t\t\t`event: '${event}',` +\n\t\t\t\t\t\t\t`name: '${name}',` +\n\t\t\t\t\t\t\t`begin: performance.now()` +\n\t\t\t\t\t\t\t`})\\n`\n\t\t\t\t\t)\n\n\t\t\t\treturn (binding?: string) => {\n\t\t\t\t\tfor (let i = 0; i < trace.length; i++) {\n\t\t\t\t\t\tif (binding)\n\t\t\t\t\t\t\t// Don't report error because HTTP response is expected and not an actual error to look for\n\t\t\t\t\t\t\t// if (${binding} && typeof ${binding} === \"object\" && ELYSIA_RESPONSE in ${binding}) {\n\t\t\t\t\t\t\t//     ${reporter}Child${i}?.(${binding}.error)\n\t\t\t\t\t\t\t//     ${reporter}Child${i}?.()\\n\n\t\t\t\t\t\t\t// } else\n\t\t\t\t\t\t\taddFn(`\n                             \tif (${binding} instanceof Error)\n                    \t\t\t\t${reporter}Child${i}?.(${binding})\n                           \t\telse\n                             \t\t${reporter}Child${i}?.()\\n`)\n\t\t\t\t\t\telse addFn(`${reporter}Child${i}?.()\\n`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst composeValidationFactory = ({\n\tinjectResponse = '',\n\tnormalize = false,\n\tvalidator\n}: {\n\tinjectResponse?: string\n\tnormalize?: boolean\n\tvalidator: SchemaValidator\n}) => ({\n\tcomposeValidation: (type: string, value = `c.${type}`) =>\n\t\t`c.set.status = 422; throw new ValidationError('${type}', validator.${type}, ${value})`,\n\tcomposeResponseValidation: (name = 'r') => {\n\t\tlet code = '\\n' + injectResponse + '\\n'\n\n\t\tcode += `if(typeof ${name} === \"object\" && ${name} && ELYSIA_RESPONSE in ${name}) {\n\t\t\tc.set.status = ${name}[ELYSIA_RESPONSE]\n\t\t\t${name} = ${name}.response\n\t\t}\n\n\t\tconst isResponse = ${name} instanceof Response\\n\\n`\n\n\t\tcode += `switch(c.set.status) {\\n`\n\n\t\tfor (const [status, value] of Object.entries(\n\t\t\tvalidator.response as Record<string, TypeCheck<any>>\n\t\t)) {\n\t\t\tcode += `\\tcase ${status}:\n\t\t\t\tif (!isResponse) {\\n`\n\n\t\t\tif (\n\t\t\t\tnormalize &&\n\t\t\t\t'Clean' in value &&\n\t\t\t\t!hasAdditionalProperties(value as any)\n\t\t\t)\n\t\t\t\tcode += `${name} = validator.response['${status}'].Clean(${name})\\n`\n\n\t\t\tcode += `if(validator.response['${status}'].Check(${name}) === false) {\n\t\t\t\t\tc.set.status = 422\n\n\t\t\t\t\tthrow new ValidationError('response', validator.response['${status}'], ${name})\n\t\t\t\t}\n\n\t\t\t\tc.set.status = ${status}\n\t\t\t}\n\n\t\t\tbreak\\n\\n`\n\t\t}\n\n\t\tcode += '\\n}\\n'\n\n\t\treturn code\n\t}\n})\n\nconst KindSymbol = Symbol.for('TypeBox.Kind')\n\nexport const hasType = (type: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (KindSymbol in schema && schema[KindSymbol] === type) return true\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasType(type, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasType(type, property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tif (KindSymbol in property && property[KindSymbol] === type)\n\t\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tschema.properties &&\n\t\tKindSymbol in schema.properties &&\n\t\tschema.properties[KindSymbol] === type\n\t)\n}\n\nexport const hasProperty = (expectedProperty: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tif (!properties) return false\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (expectedProperty in property) return true\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasProperty(expectedProperty, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++) {\n\t\t\t\t\tif (hasProperty(expectedProperty, property.anyOf[i]))\n\t\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn expectedProperty in schema\n}\n\nconst TransformSymbol = Symbol.for('TypeBox.Transform')\n\nexport const hasTransform = (schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object' && schema.properties) {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasTransform(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasTransform(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tconst hasTransformSymbol = TransformSymbol in property\n\t\t\tif (hasTransformSymbol) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tTransformSymbol in schema ||\n\t\t(schema.properties && TransformSymbol in schema.properties)\n\t)\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\n// const getUnionedType = (validator: TypeCheck<any> | undefined) => {\n// \tif (!validator) return\n\n// \t// @ts-ignore\n// \tconst schema = validator?.schema\n\n// \tif (schema && 'anyOf' in schema) {\n// \t\tlet foundDifference = false\n// \t\tconst type: string = schema.anyOf[0].type\n\n// \t\tfor (const validator of schema.anyOf as { type: string }[]) {\n// \t\t\tif (validator.type !== type) {\n// \t\t\t\tfoundDifference = true\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t}\n\n// \t\tif (!foundDifference) return type\n// \t}\n\n// \t// @ts-ignore\n// \treturn validator.schema?.type\n// }\n\nconst matchFnReturn = /(?:return|=>) \\S+\\(/g\n\nexport const isAsyncName = (v: Function | HookContainer) => {\n\t// @ts-ignore\n\tconst fn = v?.fn ?? v\n\n\treturn fn.constructor.name === 'AsyncFunction'\n}\n\nexport const isAsync = (v: Function | HookContainer) => {\n\t// @ts-ignore\n\tconst fn = v?.fn ?? v\n\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\tconst literal = fn.toString()\n\tif (literal.includes('=> response.clone(')) return false\n\tif (literal.includes('await')) return true\n\tif (literal.includes('async')) return true\n\n\treturn !!literal.match(matchFnReturn)\n}\n\nexport const isGenerator = (v: Function | HookContainer) => {\n\t// @ts-ignore\n\tconst fn = v?.fn ?? v\n\n\treturn (\n\t\tfn.constructor.name === 'AsyncGeneratorFunction' ||\n\t\tfn.constructor.name === 'GeneratorFunction'\n\t)\n}\n\nexport const composeHandler = ({\n\tapp,\n\tpath,\n\tmethod,\n\tlocalHook,\n\thooks,\n\tvalidator,\n\thandler,\n\tallowMeta = false,\n\tinference\n}: {\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n\tpath: string\n\tmethod: string\n\thooks: LifeCycleStore\n\tlocalHook: LifeCycleStore\n\tvalidator: SchemaValidator\n\thandler: unknown | Handler<any, any>\n\tallowMeta?: boolean\n\tinference: Sucrose.Inference\n}): ComposedHandler => {\n\tconst isHandleFn = typeof handler === 'function'\n\n\tif (!isHandleFn)\n\t\thandler = mapResponse(handler, {\n\t\t\t// @ts-expect-error private property\n\t\t\theaders: app.setHeaders ?? {}\n\t\t})\n\n\tconst handle = isHandleFn ? `handler(c)` : `handler`\n\tconst hasAfterResponse = hooks.afterResponse.length > 0\n\n\tconst hasTrace = hooks.trace.length > 0\n\tlet fnLiteral = ''\n\n\tinference = sucrose(\n\t\tObject.assign(localHook, {\n\t\t\thandler: handler as any\n\t\t}),\n\t\tinference\n\t)\n\n\tif (inference.server)\n\t\tfnLiteral += `\\nObject.defineProperty(c, 'server', {\n\t\t\tget: function() { return getServer() }\n\t\t})\\n`\n\n\tif (inference.body) fnLiteral += `let isParsing = false\\n`\n\n\tvalidator.createBody?.()\n\tvalidator.createQuery?.()\n\tvalidator.createHeaders?.()\n\tvalidator.createParams?.()\n\tvalidator.createCookie?.()\n\tvalidator.createResponse?.()\n\n\tconst hasQuery = inference.query || !!validator.query\n\n\tconst hasBody =\n\t\tmethod !== '$INTERNALWS' &&\n\t\tmethod !== 'GET' &&\n\t\tmethod !== 'HEAD' &&\n\t\t(inference.body || !!validator.body || hooks.parse.length)\n\n\t// @ts-expect-error private\n\tconst defaultHeaders = app.setHeaders\n\tconst hasDefaultHeaders =\n\t\tdefaultHeaders && !!Object.keys(defaultHeaders).length\n\n\t// ? defaultHeaders doesn't imply that user will use headers in handler\n\tconst hasHeaders = inference.headers || validator.headers\n\tconst hasCookie = inference.cookie || !!validator.cookie\n\n\tconst cookieValidator = hasCookie\n\t\t? getCookieValidator({\n\t\t\t\tvalidator: validator.cookie as any,\n\t\t\t\tdefaultConfig: app.config.cookie,\n\t\t\t\tdynamic: !!app.config.aot,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tconfig: validator.cookie?.config ?? {},\n\t\t\t\t// @ts-expect-error\n\t\t\t\tmodels: app.definitions.type\n\t\t\t})\n\t\t: undefined\n\n\t// @ts-ignore private property\n\tconst cookieMeta = cookieValidator?.config as {\n\t\tsecrets?: string | string[]\n\t\tsign: string[] | true\n\t\tproperties: { [x: string]: Object }\n\t}\n\n\tlet encodeCookie = ''\n\n\tif (cookieMeta?.sign) {\n\t\tif (!cookieMeta.secrets)\n\t\t\tthrow new Error(\n\t\t\t\t`t.Cookie required secret which is not set in (${method}) ${path}.`\n\t\t\t)\n\n\t\tconst secret = !cookieMeta.secrets\n\t\t\t? undefined\n\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t? cookieMeta.secrets\n\t\t\t\t: cookieMeta.secrets[0]\n\n\t\tencodeCookie += `const _setCookie = c.set.cookie\n\t\tif(_setCookie) {`\n\n\t\tif (cookieMeta.sign === true) {\n\t\t\tencodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {\n\t\t\t\tc.set.cookie[key].value = await signCookie(cookie.value, '${secret}')\n\t\t\t}`\n\t\t} else\n\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\tencodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }\\n`\n\t\t\t}\n\n\t\tencodeCookie += '}\\n'\n\t}\n\n\tconst normalize = app.config.normalize\n\n\tconst { composeValidation, composeResponseValidation } =\n\t\tcomposeValidationFactory({\n\t\t\tnormalize,\n\t\t\tvalidator\n\t\t})\n\n\tif (hasHeaders) {\n\t\t// This function is Bun specific\n\t\t// @ts-ignore\n\t\tfnLiteral += headersHasToJSON\n\t\t\t? `c.headers = c.request.headers.toJSON()\\n`\n\t\t\t: `c.headers = {}\n                for (const [key, value] of c.request.headers.entries())\n\t\t\t\t\tc.headers[key] = value\n\t\t\t\t`\n\t}\n\n\tif (hasCookie) {\n\t\tconst get = (name: keyof CookieOptions, defaultValue?: unknown) => {\n\t\t\t// @ts-ignore\n\t\t\tconst value = cookieMeta?.[name] ?? defaultValue\n\t\t\tif (!value)\n\t\t\t\treturn typeof defaultValue === 'string'\n\t\t\t\t\t? `${name}: \"${defaultValue}\",`\n\t\t\t\t\t: `${name}: ${defaultValue},`\n\n\t\t\tif (typeof value === 'string') return `${name}: '${value}',`\n\t\t\tif (value instanceof Date)\n\t\t\t\treturn `${name}: new Date(${value.getTime()}),`\n\n\t\t\treturn `${name}: ${value},`\n\t\t}\n\n\t\tconst options = cookieMeta\n\t\t\t? `{\n\t\t\tsecrets: ${\n\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t? `'${cookieMeta.secrets}'`\n\t\t\t\t\t\t: '[' +\n\t\t\t\t\t\t\tcookieMeta.secrets.reduce(\n\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t']'\n\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\tsign: ${\n\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t? true\n\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t? '[' +\n\t\t\t\t\t\t\tcookieMeta.sign.reduce(\n\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t']'\n\t\t\t\t\t\t: 'undefined'\n\t\t\t},\n\t\t\t${get('domain')}\n\t\t\t${get('expires')}\n\t\t\t${get('httpOnly')}\n\t\t\t${get('maxAge')}\n\t\t\t${get('path', '/')}\n\t\t\t${get('priority')}\n\t\t\t${get('sameSite')}\n\t\t\t${get('secure')}\n\t\t}`\n\t\t\t: 'undefined'\n\n\t\tif (hasHeaders)\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${options})\\n`\n\t\telse\n\t\t\tfnLiteral += `\\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})\\n`\n\t}\n\n\tif (hasQuery) {\n\t\tconst destructured = <\n\t\t\t{\n\t\t\t\tkey: string\n\t\t\t\tisArray: boolean\n\t\t\t\tisNestedObjectArray: boolean\n\t\t\t\tisObject: boolean\n\t\t\t\tanyOf: boolean\n\t\t\t}[]\n\t\t>[]\n\n\t\t// @ts-ignore\n\t\tif (validator.query && validator.query.schema.type === 'object') {\n\t\t\t// @ts-expect-error private property\n\t\t\tconst properties = validator.query.schema.properties\n\n\t\t\tif (!hasAdditionalProperties(validator.query as any))\n\t\t\t\t// eslint-disable-next-line prefer-const\n\t\t\t\tfor (let [key, _value] of Object.entries(properties)) {\n\t\t\t\t\tlet value = _value as TAnySchema\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalue &&\n\t\t\t\t\t\tTypeBoxSymbol.optional in value &&\n\t\t\t\t\t\tvalue.type === 'array' &&\n\t\t\t\t\t\tvalue.items\n\t\t\t\t\t)\n\t\t\t\t\t\tvalue = value.items\n\n\t\t\t\t\t// @ts-ignore unknown\n\t\t\t\t\tconst { type, anyOf } = value\n\t\t\t\t\tconst isArray =\n\t\t\t\t\t\ttype === 'array' ||\n\t\t\t\t\t\tanyOf?.some(\n\t\t\t\t\t\t\t(v: TSchema) =>\n\t\t\t\t\t\t\t\tv.type === 'string' &&\n\t\t\t\t\t\t\t\tv.format === 'ArrayString'\n\t\t\t\t\t\t)\n\n\t\t\t\t\tdestructured.push({\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tisArray,\n\t\t\t\t\t\tisNestedObjectArray:\n\t\t\t\t\t\t\t(isArray &&\n\t\t\t\t\t\t\t\t(value.items?.type === 'object' ||\n\t\t\t\t\t\t\t\t\t!!anyOf?.length)) ||\n\t\t\t\t\t\t\t!!value.items?.anyOf,\n\t\t\t\t\t\tisObject:\n\t\t\t\t\t\t\ttype === 'object' ||\n\t\t\t\t\t\t\tanyOf?.some(\n\t\t\t\t\t\t\t\t(v: TSchema) =>\n\t\t\t\t\t\t\t\t\tv.type === 'string' &&\n\t\t\t\t\t\t\t\t\tv.format === 'ArrayString'\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\tanyOf: !!anyOf\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t}\n\n\t\tif (!destructured.length) {\n\t\t\tfnLiteral += `if(c.qi === -1) {\n\t\t\t\tc.query = {}\n\t\t\t} else {\n\t\t\t\tc.query = parseQuery(c.url.slice(c.qi + 1))\n\t\t\t}`\n\t\t} else {\n\t\t\tfnLiteral += `if(c.qi !== -1) {\n\t\t\t\tlet url = '&' + c.url.slice(c.qi + 1)\n\n\t\t\t\t${destructured\n\t\t\t\t\t.map(\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t{ key, isArray, isObject, isNestedObjectArray },\n\t\t\t\t\t\t\tindex\n\t\t\t\t\t\t) => {\n\t\t\t\t\t\t\tconst init = `${\n\t\t\t\t\t\t\t\tindex === 0 ? 'let' : ''\n\t\t\t\t\t\t\t} memory = url.indexOf('&${key}=')\n\t\t\t\t\t\t\tlet a${index}\\n`\n\n\t\t\t\t\t\t\tif (isArray)\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\tinit +\n\t\t\t\t\t\t\t\t\t(isNestedObjectArray\n\t\t\t\t\t\t\t\t\t\t? `while (memory !== -1) {\n\t\t\t\t\t\t\t\t\t\t\tconst start = memory + ${key.length + 2}\n\t\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)\n\n\t\t\t\t\t\t\t\t\t\t\tif(a${index} === undefined)\n\t\t\t\t\t\t\t\t\t\t\t\ta${index} = ''\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\ta${index} += ','\n\n\t\t\t\t\t\t\t\t\t\t\tlet temp\n\n\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) temp = decodeURIComponent(url.slice(start))\n\t\t\t\t\t\t\t\t\t\t\telse temp = decodeURIComponent(url.slice(start, memory))\n\n\t\t\t\t\t\t\t\t\t\t\tconst charCode = temp.charCodeAt(0)\n\t\t\t\t\t\t\t\t\t\t\tif(charCode !== 91 && charCode !== 123)\n\t\t\t\t\t\t\t\t\t\t\t\ttemp = '\"' + temp + '\"'\n\n\t\t\t\t\t\t\t\t\t\t\ta${index} += temp\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t    if(a${index}.charCodeAt(0) === 91)\n\t\t\t\t\t\t\t\t\t\t\t\ta${index} = JSON.parse(a${index})\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\ta${index} = JSON.parse('[' + a${index} + ']')\n\t\t\t\t\t\t\t\t\t\t} catch {}\\n`\n\t\t\t\t\t\t\t\t\t\t: `while (memory !== -1) {\n\t\t\t\t\t\t\t\t\t\t\tconst start = memory + ${key.length + 2}\n\t\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)\n\n\t\t\t\t\t\t\t\t\t\t\tif(a${index} === undefined)\n\t\t\t\t\t\t\t\t\t\t\t\ta${index} = []\n\n\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) a${index}.push(decodeURIComponent(url.slice(start)))\n\t\t\t\t\t\t\t\t\t\t\telse a${index}.push(decodeURIComponent(url.slice(start, memory)))\n\t\t\t\t\t\t\t\t\t\t}\\n`)\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tif (isObject)\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\tinit +\n\t\t\t\t\t\t\t\t\t`if (memory !== -1) {\n\t\t\t\t\t\t\t\t\t\tconst start = memory + ${key.length + 2}\n\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)\n\n\t\t\t\t\t\t\t\t\t\tif(memory === -1) a${index} = decodeURIComponent(url.slice(start))\n\t\t\t\t\t\t\t\t\t\telse a${index} = decodeURIComponent(url.slice(start, memory))\n\n\t\t\t\t\t\t\t\t\t\tif (a${index} !== undefined) {\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\ta${index} = JSON.parse(a${index})\n\t\t\t\t\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t// Might be union primitive and array\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\tinit +\n\t\t\t\t\t\t\t\t`if (memory !== -1) {\n\t\t\t\t\t\t\t\t\t\tconst start = memory + ${key.length + 2}\n\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)\n\n\t\t\t\t\t\t\t\t\t\tif(memory === -1) a${index} = decodeURIComponent(url.slice(start))\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\ta${index} = decodeURIComponent(url.slice(start, memory))\n\n\t\t\t\t\t\t\t\t\t\t\tlet deepMemory = url.indexOf('&${key}=', memory)\n\n\t\t\t\t\t\t\t\t\t\t\tif(deepMemory !== -1) {\n\t\t\t\t\t\t\t\t\t\t\t\ta${index} = [a${index}]\n\t\t\t\t\t\t\t\t\t\t\t\tlet first = true\n\n\t\t\t\t\t\t\t\t\t\t\t\twhile(true) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst start = deepMemory + ${key.length + 2}\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(first)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfirst = false\n\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeepMemory = url.indexOf('&', start)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet value\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(deepMemory === -1) value = decodeURIComponent(url.slice(start))\n\t\t\t\t\t\t\t\t\t\t\t\t\telse value = decodeURIComponent(url.slice(start, deepMemory))\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst vStart = value.charCodeAt(0)\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst vEnd = value.charCodeAt(value.length - 1)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif((vStart === 91 && vEnd === 93) || (vStart === 123 && vEnd === 125))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ta${index}.push(JSON.parse(value))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \ta${index}.push(value)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(deepMemory === -1) break\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\t.join('\\n')}\n\n\t\t\t\tc.query = {\n\t\t\t\t\t${destructured.map(({ key }, index) => `'${key}': a${index}`).join(', ')}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tc.query = {}\n\t\t\t}`\n\t\t}\n\t}\n\n\tif (hasTrace) fnLiteral += '\\nconst id = c[ELYSIA_REQUEST_ID]\\n'\n\n\tconst report = createReport({\n\t\ttrace: hooks.trace,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral += '\\ntry {\\n'\n\tconst isAsyncHandler = typeof handler === 'function' && isAsync(handler)\n\n\tconst saveResponse =\n\t\thasTrace || hooks.afterResponse.length > 0 ? 'c.response = ' : ''\n\n\tconst maybeAsync =\n\t\thasCookie ||\n\t\thasBody ||\n\t\tisAsyncHandler ||\n\t\thooks.parse.length > 0 ||\n\t\thooks.afterHandle.some(isAsync) ||\n\t\thooks.beforeHandle.some(isAsync) ||\n\t\thooks.transform.some(isAsync) ||\n\t\thooks.mapResponse.some(isAsync)\n\n\tconst maybeStream =\n\t\t(typeof handler === 'function' ? isGenerator(handler as any) : false) ||\n\t\thooks.beforeHandle.some(isGenerator) ||\n\t\thooks.afterHandle.some(isGenerator) ||\n\t\thooks.transform.some(isGenerator)\n\n\tconst hasSet =\n\t\tinference.cookie ||\n\t\tinference.set ||\n\t\thasHeaders ||\n\t\thasTrace ||\n\t\tvalidator.response ||\n\t\t(isHandleFn && hasDefaultHeaders) ||\n\t\tmaybeStream\n\n\tconst requestMapper = `, c.request`\n\n\tfnLiteral += `c.route = \\`${path}\\`\\n`\n\n\tconst parseReporter = report('parse', {\n\t\ttotal: hooks.parse.length\n\t})\n\n\tif (hasBody) {\n\t\tconst hasBodyInference =\n\t\t\thooks.parse.length || inference.body || validator.body\n\n\t\tfnLiteral += 'isParsing = true\\n'\n\t\tif (hooks.type && !hooks.parse.length) {\n\t\t\tswitch (hooks.type) {\n\t\t\t\tcase 'json':\n\t\t\t\tcase 'application/json':\n\t\t\t\t\tfnLiteral += `c.body = await c.request.json()`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'text':\n\t\t\t\tcase 'text/plain':\n\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t}\\n`\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (hasBodyInference) {\n\t\t\tfnLiteral += '\\n'\n\t\t\tfnLiteral += hasHeaders\n\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\tfnLiteral += `\n\t\t\t\tif (contentType) {\n\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)\\n\n\t\t\t\t\tc.contentType = contentType\\n`\n\n\t\t\tif (hooks.parse.length) {\n\t\t\t\tfnLiteral += `let used = false\\n`\n\n\t\t\t\tconst reporter = report('parse', {\n\t\t\t\t\ttotal: hooks.parse.length\n\t\t\t\t})\n\n\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\tconst endUnit = reporter.resolveChild(\n\t\t\t\t\t\thooks.parse[i].fn.name\n\t\t\t\t\t)\n\n\t\t\t\t\tconst name = `bo${i}`\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `if(!used) {\\n`\n\n\t\t\t\t\tfnLiteral += `let ${name} = parse[${i}](c, contentType)\\n`\n\t\t\t\t\tfnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}\\n`\n\t\t\t\t\tfnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }\\n`\n\n\t\t\t\t\tendUnit()\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\t\t\t\t}\n\n\t\t\t\treporter.resolve()\n\t\t\t}\n\n\t\t\tfnLiteral += '\\ndelete c.contentType\\n'\n\n\t\t\tif (hooks.parse.length) fnLiteral += `if (!used) {`\n\n\t\t\tif (hooks.type && !Array.isArray(hooks.type)) {\n\t\t\t\tswitch (hooks.type) {\n\t\t\t\t\tcase 'json':\n\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.json()`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'text':\n\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.text()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\tfnLiteral += `c.body = parseQuery(await c.request.text())\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\tfnLiteral += `c.body = await c.request.arrayBuffer()\\n`\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'formdata':\n\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\tfnLiteral += `c.body = {}\n\n\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t}\\n`\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfnLiteral += `\n\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\tc.body = await c.request.json()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tc.body = await c.request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tc.body = parseQuery(await c.request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tc.body = await c.request.arrayBuffer();\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tc.body = {}\n\n\t\t\t\t\t\t\tconst form = await c.request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (c.body[key])\n\t\t\t\t\t\t\t\t\tcontinue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\tc.body[key] = value[0]\n\t\t\t\t\t\t\t\telse c.body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}`\n\t\t\t}\n\n\t\t\tif (hooks.parse.length) fnLiteral += `}`\n\n\t\t\tfnLiteral += '}\\n'\n\t\t}\n\n\t\tfnLiteral += '\\nisParsing = false\\n'\n\t}\n\n\tparseReporter.resolve()\n\n\tif (hooks?.transform) {\n\t\tconst reporter = report('transform', {\n\t\t\ttotal: hooks.transform.length\n\t\t})\n\n\t\tif (hooks.transform.length) fnLiteral += '\\nlet transformed\\n'\n\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\tconst endUnit = reporter.resolveChild(transform.fn.name)\n\n\t\t\tfnLiteral += isAsync(transform)\n\t\t\t\t? `transformed = await transform[${i}](c)\\n`\n\t\t\t\t: `transformed = transform[${i}](c)\\n`\n\n\t\t\tif (transform.subType === 'mapDerive')\n\t\t\t\tfnLiteral += `if(transformed?.[ELYSIA_RESPONSE])\n\t\t\t\t\tthrow transformed\n\t\t\t\telse {\n\t\t\t\t\ttransformed.request = c.request\n\t\t\t\t\ttransformed.store = c.store\n\t\t\t\t\ttransformed.qi = c.qi\n\t\t\t\t\ttransformed.path = c.path\n\t\t\t\t\ttransformed.url = c.url\n\t\t\t\t\ttransformed.redirect = c.redirect\n\t\t\t\t\ttransformed.set = c.set\n\t\t\t\t\ttransformed.error = c.error\n\n\t\t\t\t\tc = transformed\n\t\t\t}`\n\t\t\telse\n\t\t\t\tfnLiteral += `if(transformed?.[ELYSIA_RESPONSE])\n\t\t\t\t\tthrow transformed\n\t\t\t\telse\n\t\t\t\t\tObject.assign(c, transformed)\\n`\n\n\t\t\tendUnit()\n\t\t}\n\n\t\treporter.resolve()\n\t}\n\n\tif (validator) {\n\t\tfnLiteral += '\\n'\n\n\t\tif (validator.headers) {\n\t\t\tif (\n\t\t\t\tnormalize &&\n\t\t\t\t'Clean' in validator.headers &&\n\t\t\t\t!hasAdditionalProperties(validator.headers as any)\n\t\t\t)\n\t\t\t\tfnLiteral += 'c.headers = validator.headers.Clean(c.headers);\\n'\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.headers.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.headers.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t\t: value\n\n\t\t\t\t\tif (parsed !== undefined)\n\t\t\t\t\t\tfnLiteral += `c.headers['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tif (isOptional(validator.headers))\n\t\t\t\tfnLiteral += `if(isNotEmpty(c.headers)) {`\n\n\t\t\tfnLiteral += `if(validator.headers.Check(c.headers) === false) {\n\t\t\t\t${composeValidation('headers')}\n\t\t\t}`\n\n\t\t\t// @ts-expect-error private property\n\t\t\tif (hasTransform(validator.headers.schema))\n\t\t\t\tfnLiteral += `c.headers = validator.headers.Decode(c.headers)\\n`\n\n\t\t\tif (isOptional(validator.headers)) fnLiteral += '}'\n\t\t}\n\n\t\tif (validator.params) {\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.params.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.params.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t\t: value\n\n\t\t\t\t\tif (parsed !== undefined)\n\t\t\t\t\t\tfnLiteral += `c.params['${key}'] ??= ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral += `if(validator.params.Check(c.params) === false) {\n\t\t\t\t${composeValidation('params')}\n\t\t\t}`\n\n\t\t\t// @ts-expect-error private property\n\t\t\tif (hasTransform(validator.params.schema))\n\t\t\t\tfnLiteral += `\\nc.params = validator.params.Decode(c.params)\\n`\n\t\t}\n\n\t\tif (validator.query) {\n\t\t\tif (\n\t\t\t\tnormalize &&\n\t\t\t\t'Clean' in validator.query &&\n\t\t\t\t!hasAdditionalProperties(validator.query as any)\n\t\t\t)\n\t\t\t\tfnLiteral += 'c.query = validator.query.Clean(c.query);\\n'\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.query.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.query.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t\t: value\n\n\t\t\t\t\tif (parsed !== undefined)\n\t\t\t\t\t\tfnLiteral += `if(c.query['${key}'] === undefined) c.query['${key}'] = ${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tif (isOptional(validator.query))\n\t\t\t\tfnLiteral += `if(isNotEmpty(c.query)) {`\n\n\t\t\tfnLiteral += `if(validator.query.Check(c.query) === false) {\n          \t\t${composeValidation('query')}\n\t\t\t}`\n\n\t\t\t// @ts-expect-error private property\n\t\t\tif (hasTransform(validator.query.schema))\n\t\t\t\tfnLiteral += `\\nc.query = validator.query.Decode(Object.assign({}, c.query))\\n`\n\n\t\t\tif (isOptional(validator.query)) fnLiteral += `}`\n\t\t}\n\n\t\tif (validator.body) {\n\t\t\tif (\n\t\t\t\tnormalize &&\n\t\t\t\t'Clean' in validator.body &&\n\t\t\t\t!hasAdditionalProperties(validator.body as any)\n\t\t\t)\n\t\t\t\tfnLiteral += 'c.body = validator.body.Clean(c.body);\\n'\n\n\t\t\t// @ts-expect-error private property\n\t\t\tconst doesHaveTransform = hasTransform(validator.body.schema)\n\n\t\t\tif (doesHaveTransform || isOptional(validator.body))\n\t\t\t\tfnLiteral += `\\nconst isNotEmptyObject = c.body && (typeof c.body === \"object\" && isNotEmpty(c.body))\\n`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', validator.body.schema)) {\n\t\t\t\tconst value = Value.Default(\n\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\tvalidator.body.schema,\n\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\tvalidator.body.schema.type === 'object' ? {} : undefined\n\t\t\t\t)\n\n\t\t\t\tconst parsed =\n\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t: value\n\n\t\t\t\tfnLiteral += `if(validator.body.Check(c.body) === false) {\n\t\t\t\t\tif (typeof c.body === 'object') {\n\t\t\t\t\t\tc.body = Object.assign(${parsed}, c.body)\n\t\t\t\t\t} else { c.body = ${parsed} }`\n\n\t\t\t\tif (isOptional(validator.body))\n\t\t\t\t\tfnLiteral += `\n\t\t\t\t\t    if(isNotEmptyObject && validator.body.Check(c.body) === false) {\n            \t\t\t\t${composeValidation('body')}\n             \t\t\t}\n                    }`\n\t\t\t\telse\n\t\t\t\t\tfnLiteral += `\n    \t\t\t\tif(validator.body.Check(c.body) === false) {\n        \t\t\t\t${composeValidation('body')}\n         \t\t\t}\n                }`\n\t\t\t} else {\n\t\t\t\tif (isOptional(validator.body))\n\t\t\t\t\tfnLiteral += `if(isNotEmptyObject && validator.body.Check(c.body) === false) {\n         \t\t\t${composeValidation('body')}\n          \t\t}`\n\t\t\t\telse\n\t\t\t\t\tfnLiteral += `if(validator.body.Check(c.body) === false) {\n         \t\t\t${composeValidation('body')}\n          \t\t}`\n\t\t\t}\n\n\t\t\tif (doesHaveTransform)\n\t\t\t\tfnLiteral += `\\nif(isNotEmptyObject) c.body = validator.body.Decode(c.body)\\n`\n\t\t}\n\n\t\tif (\n\t\t\tisNotEmpty(\n\t\t\t\t// @ts-ignore\n\t\t\t\tcookieValidator?.schema?.properties ??\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tcookieValidator?.schema?.schema ??\n\t\t\t\t\t{}\n\t\t\t)\n\t\t) {\n\t\t\tfnLiteral += `const cookieValue = {}\n    \t\t\tfor(const [key, value] of Object.entries(c.cookie))\n    \t\t\t\tcookieValue[key] = value.value\\n`\n\n\t\t\t// @ts-ignore\n\t\t\tif (hasProperty('default', cookieValidator.schema))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tcookieValidator.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tfnLiteral += `cookieValue['${key}'] = ${\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: value\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\n\t\t\tif (isOptional(validator.cookie))\n\t\t\t\tfnLiteral += `if(isNotEmpty(c.cookie)) {`\n\n\t\t\tfnLiteral += `if(validator.cookie.Check(cookieValue) === false) {\n\t\t\t\t${composeValidation('cookie', 'cookieValue')}\n\t\t\t}`\n\n\t\t\t// @ts-expect-error private property\n\t\t\tif (hasTransform(validator.cookie.schema))\n\t\t\t\tfnLiteral += `\\nfor(const [key, value] of Object.entries(validator.cookie.Decode(cookieValue)))\n\t\t\t\t\tc.cookie[key].value = value\\n`\n\n\t\t\tif (isOptional(validator.cookie)) fnLiteral += `}`\n\t\t}\n\t}\n\n\tif (hooks?.beforeHandle) {\n\t\tconst reporter = report('beforeHandle', {\n\t\t\ttotal: hooks.beforeHandle.length\n\t\t})\n\n\t\tlet hasResolve = false\n\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst beforeHandle = hooks.beforeHandle[i]\n\n\t\t\tconst endUnit = reporter.resolveChild(beforeHandle.fn.name)\n\n\t\t\tconst returning = hasReturn(beforeHandle)\n\t\t\tconst isResolver =\n\t\t\t\tbeforeHandle.subType === 'resolve' ||\n\t\t\t\tbeforeHandle.subType === 'mapResolve'\n\n\t\t\tif (isResolver) {\n\t\t\t\tif (!hasResolve) {\n\t\t\t\t\thasResolve = true\n\t\t\t\t\tfnLiteral += '\\nlet resolved\\n'\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `resolved = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `resolved = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tif (beforeHandle.subType === 'mapResolve')\n\t\t\t\t\tfnLiteral += `if(resolved[ELYSIA_RESPONSE])\n\t\t\t\t\t\tthrow resolved\n\t\t\t\t\telse {\n\t\t\t\t\t\tresolved.request = c.request\n\t\t\t\t\t\tresolved.store = c.store\n\t\t\t\t\t\tresolved.qi = c.qi\n\t\t\t\t\t\tresolved.path = c.path\n\t\t\t\t\t\tresolved.url = c.url\n\t\t\t\t\t\tresolved.redirect = c.redirect\n\t\t\t\t\t\tresolved.set = c.set\n\t\t\t\t\t\tresolved.error = c.error\n\n\t\t\t\t\t\tc = resolved\n\t\t\t\t\t}`\n\t\t\t\telse\n\t\t\t\t\tfnLiteral += `if(resolved[ELYSIA_RESPONSE])\n\t\t\t\t\t\tthrow resolved\n\t\t\t\t\telse\n\t\t\t\t\t\tObject.assign(c, resolved)\\n`\n\t\t\t} else if (!returning) {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `be = await beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `be = beforeHandle[${i}](c);\\n`\n\n\t\t\t\tendUnit('be')\n\n\t\t\t\tfnLiteral += `if(be !== undefined) {\\n`\n\t\t\t\treporter.resolve()\n\n\t\t\t\tif (hooks.afterHandle?.length) {\n\t\t\t\t\treport('handle', {\n\t\t\t\t\t\tname: isHandleFn\n\t\t\t\t\t\t\t? (handler as Function).name\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t}).resolve()\n\n\t\t\t\t\tconst reporter = report('afterHandle', {\n\t\t\t\t\t\ttotal: hooks.afterHandle.length\n\t\t\t\t\t})\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst hook = hooks.afterHandle[i]\n\t\t\t\t\t\tconst returning = hasReturn(hook)\n\t\t\t\t\t\tconst endUnit = reporter.resolveChild(hook.fn.name)\n\n\t\t\t\t\t\tfnLiteral += `c.response = be\\n`\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `await afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t\t\t: `afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(af !== undefined) { c.response = be = af }\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit('af')\n\t\t\t\t\t}\n\t\t\t\t\treporter.resolve()\n\t\t\t\t}\n\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += composeResponseValidation('be')\n\n\t\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\t\ttotal: hooks.mapResponse.length\n\t\t\t\t})\n\n\t\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\t\tfnLiteral += `\\nc.response = be\\n`\n\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = ${isAsyncName(mapResponse) ? 'await' : ''} onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(mr !== undefined) be = c.response = mr\n\t\t\t\t\t\t}\\n`\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmapResponseReporter.resolve()\n\n\t\t\t\tfnLiteral += encodeCookie\n\t\t\t\tfnLiteral += `return mapEarlyResponse(${saveResponse} be, c.set ${requestMapper})}\\n`\n\t\t\t}\n\t\t}\n\n\t\treporter.resolve()\n\t}\n\n\tif (hooks?.afterHandle.length) {\n\t\tconst handleReporter = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (hooks.afterHandle.length)\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = c.response = await ${handle};\\n`\n\t\t\t\t: `let r = c.response = ${handle};\\n`\n\t\telse\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\thandleReporter.resolve()\n\n\t\tconst reporter = report('afterHandle', {\n\t\t\ttotal: hooks.afterHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst hook = hooks.afterHandle[i]\n\t\t\tconst returning = hasReturn(hook)\n\t\t\tconst endUnit = reporter.resolveChild(hook.fn.name)\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `af = await afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `af = afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit('af')\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\treporter.resolve()\n\n\t\t\t\t\tfnLiteral += composeResponseValidation('af')\n\n\t\t\t\t\tfnLiteral += `c.response = af }`\n\t\t\t\t} else {\n\t\t\t\t\tfnLiteral += `if(af !== undefined) {`\n\t\t\t\t\treporter.resolve()\n\n\t\t\t\t\tfnLiteral += `c.response = af}\\n`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treporter.resolve()\n\n\t\tfnLiteral += `r = c.response\\n`\n\n\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\tfnLiteral += encodeCookie\n\n\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\ttotal: hooks.mapResponse.length\n\t\t})\n\t\tif (hooks.mapResponse.length) {\n\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t)\n\n\t\t\t\tfnLiteral += `\\nmr = ${\n\t\t\t\t\tisAsyncName(mapResponse) ? 'await' : ''\n\t\t\t\t} onMapResponse[${i}](c)\n\t\t\t\tif(mr !== undefined) r = c.response = mr\\n`\n\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\t\tmapResponseReporter.resolve()\n\n\t\tif (hasSet)\n\t\t\tfnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})\\n`\n\t\telse\n\t\t\tfnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})\\n`\n\t} else {\n\t\tconst handleReporter = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (validator.response || hooks.mapResponse.length) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\thandleReporter.resolve()\n\n\t\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\t\treport('afterHandle').resolve()\n\n\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\ttotal: hooks.mapResponse.length\n\t\t\t})\n\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfnLiteral += '\\nc.response = r\\n'\n\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t)\n\n\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\tmr = ${isAsyncName(mapResponse) ? 'await' : ''} onMapResponse[${i}](c)\n    \t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t}\\n`\n\n\t\t\t\t\tendUnit()\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapResponseReporter.resolve()\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(\n\t\t\t\t\tisNotEmpty(c.set.headers) ||\n\t\t\t\t\tc.set.status !== 200 ||\n\t\t\t\t\tc.set.redirect ||\n\t\t\t\t\tc.set.cookie\n\t\t\t\t)\n\t\t\t\t\treturn mapResponse(${saveResponse} ${handle}.clone(), c.set ${requestMapper})\n\t\t\t\telse\n\t\t\t\t\treturn ${handle}.clone()`\n\t\t\t\t\t: `return ${handle}.clone()`\n\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t} else if (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})\\n`\n\t\t\telse\n\t\t\t\tfnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})\\n`\n\t\t} else if (hasCookie || hasTrace) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r = await ${handle};\\n`\n\t\t\t\t: `let r = ${handle};\\n`\n\n\t\t\thandleReporter.resolve()\n\n\t\t\treport('afterHandle').resolve()\n\n\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\ttotal: hooks.mapResponse.length\n\t\t\t})\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfnLiteral += '\\nc.response = r\\n'\n\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t)\n\n\t\t\t\t\tfnLiteral += `\\nif(mr === undefined) {\n\t\t\t\t\t\t\tmr = ${isAsyncName(mapResponse) ? 'await' : ''} onMapResponse[${i}](c)\n    \t\t\t\t\t\tif(mr !== undefined) r = c.response = mr\n\t\t\t\t\t\t}\\n`\n\n\t\t\t\t\tendUnit()\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapResponseReporter.resolve()\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})\\n`\n\t\t\telse\n\t\t\t\tfnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})\\n`\n\t\t} else {\n\t\t\thandleReporter.resolve()\n\n\t\t\tconst handled = isAsyncHandler ? `await ${handle}` : handle\n\n\t\t\treport('afterHandle').resolve()\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(\n\t\t\t\t\tisNotEmpty(c.set.headers) ||\n\t\t\t\t\tc.set.status !== 200 ||\n\t\t\t\t\tc.set.redirect ||\n\t\t\t\t\tc.set.cookie\n\t\t\t\t)\n\t\t\t\t\treturn mapResponse(${saveResponse} ${handle}.clone(), c.set ${requestMapper})\n\t\t\t\telse\n\t\t\t\t\treturn ${handle}.clone()`\n\t\t\t\t\t: `return ${handle}.clone()`\n\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t} else if (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(${saveResponse} ${handled}, c.set ${requestMapper})\\n`\n\t\t\telse\n\t\t\t\tfnLiteral += `return mapCompactResponse(${saveResponse} ${handled} ${requestMapper})\\n`\n\t\t}\n\t}\n\n\tfnLiteral += `\\n} catch(error) {`\n\n\tif (hasBody) fnLiteral += `\\nif(isParsing) error = new ParseError()\\n`\n\n\tif (!maybeAsync) fnLiteral += `\\nreturn (async () => {\\n`\n\tfnLiteral += `\\nconst set = c.set\\nif (!set.status || set.status < 300) set.status = error?.status || 500\\n`\n\n\tif (hasTrace)\n\t\tfor (let i = 0; i < hooks.trace.length; i++)\n\t\t\t// There's a case where the error is thrown before any trace is called\n\t\t\tfnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error);\\n`\n\n\tconst errorReporter = report('error', {\n\t\ttotal: hooks.error.length\n\t})\n\n\tif (hooks.error.length) {\n\t\tfnLiteral += `\n\t\t\t\tc.error = error\n\t\t\t\tc.code = error.code ?? error[ERROR_CODE] ?? \"UNKNOWN\"\n\t\t\t\tlet er\n\t\t\t`\n\n\t\tfor (let i = 0; i < hooks.error.length; i++) {\n\t\t\tconst endUnit = errorReporter.resolveChild(hooks.error[i].fn.name)\n\n\t\t\tif (isAsync(hooks.error[i]))\n\t\t\t\tfnLiteral += `\\ner = await handleErrors[${i}](c)\\n`\n\t\t\telse\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`\\ner = handleErrors[${i}](c)\\n` +\n\t\t\t\t\t`if (er instanceof Promise) er = await er\\n`\n\n\t\t\tendUnit()\n\n\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\ttotal: hooks.mapResponse.length\n\t\t\t})\n\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t)\n\n\t\t\t\t\tfnLiteral += `\\nc.response = er\\n\n\t\t\t\t\t\t\ter = ${isAsyncName(mapResponse) ? 'await' : ''} onMapResponse[${i}](c)\n\t\t\t\t\t\t\tif(er instanceof Promise) er = await er\\n`\n\n\t\t\t\t\tendUnit()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmapResponseReporter.resolve()\n\n\t\t\tfnLiteral += `er = mapEarlyResponse(er, set ${requestMapper})\\n`\n\t\t\tfnLiteral += `if (er) {`\n\n\t\t\tif (hasTrace) {\n\t\t\t\tfor (let i = 0; i < hooks.trace.length; i++)\n\t\t\t\t\tfnLiteral += `\\nreport${i}.resolve()\\n`\n\n\t\t\t\terrorReporter.resolve()\n\t\t\t}\n\n\t\t\tfnLiteral += `return er\\n}\\n`\n\t\t}\n\t}\n\n\terrorReporter.resolve()\n\n\tfnLiteral += `return handleError(c, error, true)\\n`\n\tif (!maybeAsync) fnLiteral += '})()'\n\tfnLiteral += '}'\n\n\tif (hasAfterResponse || hasTrace) {\n\t\tfnLiteral += ` finally { `\n\n\t\tif (!maybeAsync) fnLiteral += ';(async () => {'\n\n\t\tconst reporter = report('afterResponse', {\n\t\t\ttotal: hooks.afterResponse.length\n\t\t})\n\n\t\tif (hasAfterResponse) {\n\t\t\tfor (let i = 0; i < hooks.afterResponse.length; i++) {\n\t\t\t\tconst endUnit = reporter.resolveChild(\n\t\t\t\t\thooks.afterResponse[i].fn.name\n\t\t\t\t)\n\t\t\t\tfnLiteral += `\\nawait afterResponse[${i}](c);\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\treporter.resolve()\n\n\t\tif (!maybeAsync) fnLiteral += '})();'\n\n\t\tfnLiteral += `}`\n\t}\n\n\tfnLiteral = `const {\n\t\thandler,\n\t\thandleError,\n\t\thooks: {\n\t\t\ttransform,\n\t\t\tresolve,\n\t\t\tbeforeHandle,\n\t\t\tafterHandle,\n\t\t\tmapResponse: onMapResponse,\n\t\t\tparse,\n\t\t\terror: handleErrors,\n\t\t\tafterResponse,\n\t\t\ttrace: _trace\n\t\t},\n\t\tvalidator,\n\t\tutils: {\n\t\t\tmapResponse,\n\t\t\tmapCompactResponse,\n\t\t\tmapEarlyResponse,\n\t\t\tparseQuery,\n\t\t\tisNotEmpty\n\t\t},\n\t\terror: {\n\t\t\tNotFoundError,\n\t\t\tValidationError,\n\t\t\tInternalServerError,\n\t\t\tParseError\n\t\t},\n\t\tschema,\n\t\tdefinitions,\n\t\tERROR_CODE,\n\t\tparseCookie,\n\t\tsignCookie,\n\t\tdecodeURIComponent,\n\t\tELYSIA_RESPONSE,\n\t\tELYSIA_TRACE,\n\t\tELYSIA_REQUEST_ID,\n\t\tgetServer\n\t} = hooks\n\n\tconst trace = _trace.map(x => typeof x === 'function' ? x : x.fn)\n\n\treturn ${maybeAsync ? 'async' : ''} function handle(c) {\n\t\t${hooks.beforeHandle.length ? 'let be' : ''}\n\t\t${hooks.afterHandle.length ? 'let af' : ''}\n\t\t${hooks.mapResponse.length ? 'let mr' : ''}\n\n\t\t${allowMeta ? 'c.schema = schema; c.defs = definitions' : ''}\n\t\t${fnLiteral}\n\t}`\n\n\ttry {\n\t\treturn Function(\n\t\t\t'hooks',\n\t\t\tfnLiteral\n\t\t)({\n\t\t\thandler,\n\t\t\thooks: lifeCycleToFn(hooks),\n\t\t\tvalidator,\n\t\t\t// @ts-expect-error\n\t\t\thandleError: app.handleError,\n\t\t\tutils: {\n\t\t\t\tmapResponse,\n\t\t\t\tmapCompactResponse,\n\t\t\t\tmapEarlyResponse,\n\t\t\t\tparseQuery,\n\t\t\t\tisNotEmpty\n\t\t\t},\n\t\t\terror: {\n\t\t\t\tNotFoundError,\n\t\t\t\tValidationError,\n\t\t\t\tInternalServerError,\n\t\t\t\tParseError\n\t\t\t},\n\t\t\tschema: app.router.history,\n\t\t\t// @ts-expect-error\n\t\t\tdefinitions: app.definitions.type,\n\t\t\tERROR_CODE,\n\t\t\tparseCookie,\n\t\t\tsignCookie,\n\t\t\tdecodeURIComponent,\n\t\t\tELYSIA_RESPONSE,\n\t\t\tELYSIA_TRACE,\n\t\t\tELYSIA_REQUEST_ID,\n\t\t\t// @ts-expect-error private property\n\t\t\tgetServer: () => app.getServer()\n\t\t})\n\t} catch {\n\t\tconst debugHooks = lifeCycleToFn(hooks)\n\n\t\tconsole.log('[Composer] failed to generate optimized handler')\n\t\tconsole.log(\n\t\t\t'Please report the following to SaltyAom privately as it may include sensitive information about your codebase:'\n\t\t)\n\t\tconsole.log('---')\n\t\tconsole.log({\n\t\t\thandler:\n\t\t\t\ttypeof handler === 'function' ? handler.toString() : handler,\n\t\t\thooks: {\n\t\t\t\t...debugHooks,\n\t\t\t\t// @ts-expect-error\n\t\t\t\ttransform: debugHooks?.transform?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tresolve: debugHooks?.resolve?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tbeforeHandle: debugHooks?.beforeHandle?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tafterHandle: debugHooks?.afterHandle?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tmapResponse: debugHooks?.mapResponse?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tparse: debugHooks?.parse?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-expect-error\n\t\t\t\terror: debugHooks?.error?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tafterResponse: debugHooks?.afterResponse?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tstop: debugHooks?.stop?.map?.((x) => x.toString())\n\t\t\t},\n\t\t\tvalidator,\n\t\t\t// @ts-expect-error\n\t\t\tdefinitions: app.definitions.type\n\t\t})\n\t\tconsole.log('---')\n\n\t\tprocess.exit(1)\n\t}\n}\n\nexport const composeGeneralHandler = (\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n) => {\n\tlet decoratorsLiteral = ''\n\tlet fnLiteral = ''\n\n\t// @ts-expect-error private\n\tconst defaultHeaders = app.setHeaders\n\n\t// @ts-ignore\n\tfor (const key of Object.keys(app.singleton.decorator))\n\t\tdecoratorsLiteral += `,${key}: app.singleton.decorator.${key}`\n\n\tconst router = app.router\n\tconst hasTrace = app.event.trace.length > 0\n\n\tlet findDynamicRoute = `\n\tconst route = router.find(request.method, path) ${\n\t\trouter.http.root.ALL ? '?? router.find(\"ALL\", path)' : ''\n\t}\n\n\tif (route === null)\n\t\treturn ${\n\t\t\tapp.event.error.length\n\t\t\t\t? `app.handleError(ctx, notFound)`\n\t\t\t\t: app.event.request.length\n\t\t\t\t\t? `new Response(error404Message, {\n\t\t\t\t\tstatus: ctx.set.status === 200 ? 404 : ctx.set.status,\n\t\t\t\t\theaders: ctx.set.headers\n\t\t\t\t})`\n\t\t\t\t\t: `error404.clone()`\n\t\t}\n\n\tctx.params = route.params\\n`\n\n\tfindDynamicRoute += `if(route.store.handler) return route.store.handler(ctx)\n\treturn (route.store.handler = route.store.compile())(ctx)\\n`\n\n\tlet switchMap = ``\n\tfor (const [path, { code, all }] of Object.entries(router.static.http.map))\n\t\tswitchMap += `case '${path}':\\nswitch(request.method) {\\n${code}\\n${\n\t\t\tall ?? `default: break map`\n\t\t}}\\n\\n`\n\n\tconst maybeAsync = app.event.request.some(isAsync)\n\n\tfnLiteral += `const {\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\trandomId,\n\t\thandleError,\n\t\terror,\n\t\tredirect,\n\t\tELYSIA_TRACE,\n\t\tELYSIA_REQUEST_ID,\n\t\tgetServer\n\t} = data\n\n\tconst store = app.singleton.store\n\tconst staticRouter = app.router.static.http\n\tconst st = staticRouter.handlers\n\tconst wsRouter = app.router.ws\n\tconst router = app.router.http\n\tconst trace = app.event.trace.map(x => typeof x === 'function' ? x : x.fn)\n\n\tconst notFound = new NotFoundError()\n\tconst hoc = app.extender.higherOrderFunctions.map(x => x.fn)\n\n\t${\n\t\tapp.event.request.length\n\t\t\t? `const onRequest = app.event.request.map(x => x.fn)`\n\t\t\t: ''\n\t}\n\t${\n\t\tapp.event.error.length\n\t\t\t? ''\n\t\t\t: `\\nconst error404Message = notFound.message.toString()\n\tconst error404 = new Response(error404Message, { status: 404 });\\n`\n\t}\n\n\t${\n\t\tapp.event.trace.length\n\t\t\t? `const ${app.event.trace\n\t\t\t\t\t.map((_, i) => `tr${i} = app.event.trace[${i}].fn`)\n\t\t\t\t\t.join(',')}`\n\t\t\t: ''\n\t}\n\n\t${maybeAsync ? 'async' : ''} function map(request) {\\n`\n\n\tif (app.event.request.length) fnLiteral += `let re`\n\n\tfnLiteral += `\\nconst url = request.url\n\t\tconst s = url.indexOf('/', 11)\n\t\tconst qi = url.indexOf('?', s + 1)\n\t\tlet path\n\t\tif(qi === -1)\n\t\t\tpath = url.substring(s)\n\t\telse\n\t\t\tpath = url.substring(s, qi)\\n`\n\n\tfnLiteral += `${hasTrace ? 'const id = randomId()' : ''}\n\t\tconst ctx = {\n\t\t\trequest,\n\t\t\tstore,\n\t\t\tqi,\n\t\t\tpath,\n\t\t\turl,\n\t\t\tredirect,\n\t\t\tset: {\n\t\t\t\theaders: ${\n\t\t\t\t\tObject.keys(defaultHeaders ?? {}).length\n\t\t\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t\t\t: '{}'\n\t\t\t\t},\n\t\t\t\tstatus: 200\n\t\t\t},\n\t\t\terror\n\t\t\t${\n\t\t\t\t// @ts-expect-error private property\n\t\t\t\tapp.inference.server\n\t\t\t\t\t? `, get server() {\n\t\t\t\t\t\t\treturn getServer()\n\t\t\t\t\t\t}`\n\t\t\t\t\t: ''\n\t\t\t}\n\t\t\t${hasTrace ? ',[ELYSIA_REQUEST_ID]: id' : ''}\n\t\t\t${decoratorsLiteral}\n\t\t}\\n`\n\n\tif (app.event.trace.length)\n\t\tfnLiteral += `\\nctx[ELYSIA_TRACE] = [${app.event.trace\n\t\t\t.map((_, i) => `tr${i}(ctx)`)\n\t\t\t.join(',')}]\\n`\n\n\tconst report = createReport({\n\t\tcontext: 'ctx',\n\t\ttrace: app.event.trace,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tconst reporter = report('request', {\n\t\tattribute: 'ctx',\n\t\ttotal: app.event.request.length\n\t})\n\n\tif (app.event.request.length) {\n\t\tfnLiteral += `\\n try {\\n`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst hook = app.event.request[i]\n\t\t\tconst withReturn = hasReturn(hook)\n\t\t\tconst maybeAsync = isAsync(hook)\n\n\t\t\tconst endUnit = reporter.resolveChild(app.event.request[i].fn.name)\n\n\t\t\tif (withReturn) {\n\t\t\t\tfnLiteral += `re = mapEarlyResponse(\n\t\t\t\t\t${maybeAsync ? 'await' : ''} onRequest[${i}](ctx),\n\t\t\t\t\tctx.set,\n\t\t\t\t\trequest\n\t\t\t\t)\\n`\n\n\t\t\t\tendUnit('re')\n\t\t\t\tfnLiteral += `if(re !== undefined) return re\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += `${\n\t\t\t\t\tmaybeAsync ? 'await' : ''\n\t\t\t\t} onRequest[${i}](ctx)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += `} catch (error) {\n\t\t\treturn app.handleError(ctx, error)\n\t\t}`\n\t}\n\n\treporter.resolve()\n\n\tconst wsPaths = app.router.static.ws\n\tconst wsRouter = app.router.ws\n\n\tif (Object.keys(wsPaths).length || wsRouter.history.length) {\n\t\tfnLiteral += `\n\t\t\tif(request.method === 'GET') {\n\t\t\t\tswitch(path) {`\n\n\t\tfor (const [path, index] of Object.entries(wsPaths)) {\n\t\t\tfnLiteral += `\n\t\t\t\t\tcase '${path}':\n\t\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket')\n\t\t\t\t\t\t\treturn st[${index}](ctx)\n\n\t\t\t\t\t\tbreak`\n\t\t}\n\n\t\tfnLiteral += `\n\t\t\t\tdefault:\n\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket') {\n\t\t\t\t\t\tconst route = wsRouter.find('ws', path)\n\n\t\t\t\t\t\tif(route) {\n\t\t\t\t\t\t\tctx.params = route.params\n\n\t\t\t\t\t\t\tif(route.store.handler)\n\t\t\t\t\t\t\t    return route.store.handler(ctx)\n\n\t\t\t\t\t\t\treturn (route.store.handler = route.store.compile())(ctx)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\\n`\n\t}\n\n\tfnLiteral += `\n\t\tmap: switch(path) {\n\t\t\t${switchMap}\n\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\n\t\t${findDynamicRoute}\n\t}\\n`\n\n\t// @ts-expect-error private property\n\tif (app.extender.higherOrderFunctions.length) {\n\t\tlet handler = 'map'\n\t\t// @ts-expect-error private property\n\t\tfor (let i = 0; i < app.extender.higherOrderFunctions.length; i++)\n\t\t\thandler = `hoc[${i}](${handler}, request)`\n\n\t\tfnLiteral += `return function hocMap(request) { return ${handler}(request) }`\n\t} else fnLiteral += `return map`\n\n\t// console.log(fnLiteral)\n\n\tconst handleError = composeErrorHandler(app) as any\n\n\t// @ts-expect-error\n\tapp.handleError = handleError\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse,\n\t\tNotFoundError,\n\t\trandomId,\n\t\thandleError,\n\t\terror,\n\t\tredirect,\n\t\tELYSIA_TRACE,\n\t\tELYSIA_REQUEST_ID,\n\t\t// @ts-expect-error private property\n\t\tgetServer: () => app.getServer()\n\t})\n}\n\nexport const composeErrorHandler = (\n\tapp: Elysia<any, any, any, any, any, any, any, any>\n) => {\n\tconst hooks = app.event\n\tlet fnLiteral = ''\n\n\tfnLiteral += `const {\n\t\tapp: { event: { error: onErrorContainer, afterResponse: resContainer, mapResponse: _onMapResponse, trace: _trace } },\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE,\n\t\tELYSIA_TRACE,\n\t\tELYSIA_REQUEST_ID\n\t} = inject\n\n\tconst trace = _trace.map(x => typeof x === 'function' ? x : x.fn)\n\tconst onMapResponse = []\n\n\tfor(let i = 0; i < _onMapResponse.length; i++)\n\t\tonMapResponse.push(_onMapResponse[i].fn ?? _onMapResponse[i])\n\n\tdelete _onMapResponse\n\n\tconst onError = onErrorContainer.map(x => x.fn)\n\tconst res = resContainer.map(x => x.fn)\n\n\treturn ${\n\t\tapp.event.error.find(isAsync) || app.event.mapResponse.find(isAsync)\n\t\t\t? 'async'\n\t\t\t: ''\n\t} function(context, error, skipGlobal) {`\n\n\tconst hasTrace = app.event.trace.length > 0\n\n\tif (hasTrace) fnLiteral += '\\nconst id = context[ELYSIA_REQUEST_ID]\\n'\n\n\tconst report = createReport({\n\t\tcontext: 'context',\n\t\ttrace: hooks.trace,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral += `\n\t\tconst set = context.set\n\t\tlet r\n\n\t\tcontext.code = error.code\n\t\tcontext.error = error\n\n\t\tif(typeof error === \"object\" && error && ELYSIA_RESPONSE in error) {\n\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\terror.message = error.response\n\t\t}\\n`\n\n\tconst saveResponse =\n\t\thasTrace ||\n\t\thooks.afterResponse.length > 0 ||\n\t\thooks.afterResponse.length > 0\n\t\t\t? 'context.response = '\n\t\t\t: ''\n\n\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\tconst handler = app.event.error[i]\n\n\t\tconst response = `${\n\t\t\tisAsync(handler) ? 'await ' : ''\n\t\t}onError[${i}](context)`\n\n\t\tfnLiteral += '\\nif(skipGlobal !== true) {\\n'\n\n\t\tif (hasReturn(handler)) {\n\t\t\tfnLiteral += `r = ${response}; if(r !== undefined) {\n\t\t\t\tif(r instanceof Response) return r\n\n\t\t\t\tif(r[ELYSIA_RESPONSE]) {\n\t\t\t\t\terror.status = error[ELYSIA_RESPONSE]\n\t\t\t\t\terror.message = error.response\n\t\t\t\t}\n\n\t\t\t\tif(set.status === 200) set.status = error.status\\n`\n\n\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\ttotal: hooks.mapResponse.length,\n\t\t\t\tname: 'context'\n\t\t\t})\n\n\t\t\tif (hooks.mapResponse.length) {\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t)\n\n\t\t\t\t\tfnLiteral += `\\ncontext.response = r\n\t\t\t\t\t\tr = ${isAsyncName(mapResponse) ? 'await' : ''} onMapResponse[${i}](context)\\n`\n\n\t\t\t\t\tendUnit()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmapResponseReporter.resolve()\n\n\t\t\tfnLiteral += `return mapResponse(${saveResponse} r, set, context.request)}\\n`\n\t\t} else fnLiteral += response + '\\n'\n\n\t\tfnLiteral += '\\n}\\n'\n\t}\n\n\tfnLiteral += `if(error.constructor.name === \"ValidationError\" || error.constructor.name === \"TransformDecodeError\") {\n\t\tset.status = error.status ?? 422\n\t\treturn new Response(\n\t\t\terror.message,\n\t\t\t{\n\t\t\t\theaders: Object.assign(\n\t\t\t\t\t{ 'content-type': 'application/json'},\n\t\t\t\t\tset.headers\n\t\t\t\t),\n\t\t\t\tstatus: set.status\n\t\t\t}\n\t\t)\n\t} else {\n\t\tif(error.code && typeof error.status === \"number\")\n\t\t\treturn new Response(\n\t\t\t\terror.message,\n\t\t\t\t{ headers: set.headers, status: error.status }\n\t\t\t)\\n`\n\n\tconst mapResponseReporter = report('mapResponse', {\n\t\ttotal: hooks.mapResponse.length,\n\t\tname: 'context'\n\t})\n\n\tif (hooks.mapResponse.length) {\n\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\tmapResponse.fn.name\n\t\t\t)\n\n\t\t\tfnLiteral += `\\ncontext.response = error\n\t\t\terror = ${\n\t\t\t\tisAsyncName(mapResponse) ? 'await' : ''\n\t\t\t} onMapResponse[${i}](context)\\n`\n\n\t\t\tendUnit()\n\t\t}\n\t}\n\n\tmapResponseReporter.resolve()\n\n\tfnLiteral += `\\nreturn mapResponse(${saveResponse} error, set, context.request)\\n}\\n}`\n\n\t// console.log(fnLiteral)\n\n\treturn Function(\n\t\t'inject',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapResponse,\n\t\tERROR_CODE,\n\t\tELYSIA_RESPONSE,\n\t\tELYSIA_TRACE,\n\t\tELYSIA_REQUEST_ID\n\t})\n}\n",
    "/**\n@from https://github.com/anonrig/fast-querystring/tree/main\n\nCopyright (c) 2022 Yagiz Nizipli\n\nPermission is hereby granted, free of charge, to any\nperson obtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the\nSoftware without restriction, including without\nlimitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software\nis furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice\nshall be included in all copies or substantial portions\nof the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\nANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\nTO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\nSHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\nIN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n*/\n\n// @ts-ignore\nimport fastDecode from 'fast-decode-uri-component'\n\nconst plusRegex = /\\+/g\n\n/**\n * @callback parse\n * @param {string} input\n */\nexport function parseQuery(input: string) {\n\tconst result = <Record<string, string>>{}\n\n\tif (typeof input !== 'string') return result\n\n\tconst inputLength = input.length\n\tlet key = ''\n\tlet value = ''\n\tlet startingIndex = -1\n\tlet equalityIndex = -1\n\tlet shouldDecodeKey = false\n\tlet shouldDecodeValue = false\n\tlet keyHasPlus = false\n\tlet valueHasPlus = false\n\tlet hasBothKeyValuePair = false\n\tlet c = 0\n\n\t// Have a boundary of input.length + 1 to access last pair inside the loop.\n\tfor (let i = 0; i < inputLength + 1; i++) {\n\t\tc = i !== inputLength ? input.charCodeAt(i) : 38\n\n\t\t// Handle '&' and end of line to pass the current values to result\n\t\tif (c === 38) {\n\t\t\thasBothKeyValuePair = equalityIndex > startingIndex\n\n\t\t\t// Optimization: Reuse equality index to store the end of key\n\t\t\tif (!hasBothKeyValuePair) equalityIndex = i\n\n\t\t\tkey = input.slice(startingIndex + 1, equalityIndex)\n\n\t\t\t// Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n\t\t\tif (hasBothKeyValuePair || key.length > 0) {\n\t\t\t\t// Optimization: Replace '+' with space\n\t\t\t\tif (keyHasPlus) key = key.replace(plusRegex, ' ')\n\n\t\t\t\t// Optimization: Do not decode if it's not necessary.\n\t\t\t\tif (shouldDecodeKey) key = fastDecode(key) || key\n\n\t\t\t\tif (!result[key]) {\n\t\t\t\t\tif (hasBothKeyValuePair) {\n\t\t\t\t\t\tvalue = input.slice(equalityIndex + 1, i)\n\n\t\t\t\t\t\tif (valueHasPlus) value = value.replace(plusRegex, ' ')\n\n\t\t\t\t\t\tif (shouldDecodeValue)\n\t\t\t\t\t\t\tvalue = fastDecode(value) || value\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[key] = value\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Reset reading key value pairs\n\t\t\tvalue = ''\n\t\t\tstartingIndex = i\n\t\t\tequalityIndex = i\n\t\t\tshouldDecodeKey = false\n\t\t\tshouldDecodeValue = false\n\t\t\tkeyHasPlus = false\n\t\t\tvalueHasPlus = false\n\t\t}\n\t\t// Check '='\n\t\telse if (c === 61) {\n\t\t\tif (equalityIndex <= startingIndex) equalityIndex = i\n\t\t\t// If '=' character occurs again, we should decode the input.\n\t\t\telse shouldDecodeValue = true\n\t\t}\n\t\t// Check '+', and remember to replace it with empty space.\n\t\telse if (c === 43) {\n\t\t\tif (equalityIndex > startingIndex) valueHasPlus = true\n\t\t\telse keyHasPlus = true\n\t\t}\n\t\t// Check '%' character for encoding\n\t\telse if (c === 37) {\n\t\t\tif (equalityIndex > startingIndex) shouldDecodeValue = true\n\t\t\telse shouldDecodeKey = true\n\t\t}\n\t}\n\n\treturn result\n}\n",
    "import { ELYSIA_REQUEST_ID } from './utils'\n\nimport type { Context } from './context'\nimport type { Prettify, RouteSchema, SingletonBase } from './types'\n\nexport type TraceEvent =\n\t| 'request'\n\t| 'parse'\n\t| 'transform'\n\t| 'beforeHandle'\n\t| 'handle'\n\t| 'afterHandle'\n\t| 'mapResponse'\n\t| 'afterResponse'\n\t| 'error'\n\nexport type TraceStream = {\n\tid: number\n\tevent: TraceEvent\n\ttype: 'begin' | 'end'\n\tbegin: number\n\tname?: string\n\ttotal?: number\n}\n\ntype TraceEndDetail = {\n\t/**\n\t * Timestamp of a function after it's executed since the server start\n\t */\n\tend: TraceProcess<'end'>\n\t/**\n\t * Error that was thrown in the lifecycle\n\t */\n\terror: Error | null\n\t/**\n\t * Elapsed time of the lifecycle\n\t */\n\telapsed: number\n}\n\nexport type TraceProcess<\n\tType extends 'begin' | 'end' = 'begin' | 'end',\n\tWithChildren extends boolean = true\n> = Type extends 'begin'\n\t? Prettify<\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * Function name\n\t\t\t\t */\n\t\t\t\tname: string\n\t\t\t\t/**\n\t\t\t\t * Timestamp of a function is called since the server start\n\t\t\t\t */\n\t\t\t\tbegin: number\n\t\t\t\t/**\n\t\t\t\t * Timestamp of a function after it's executed since the server start\n\t\t\t\t */\n\t\t\t\tend: Promise<number>\n\t\t\t\t/**\n\t\t\t\t * Error that was thrown in the lifecycle\n\t\t\t\t */\n\t\t\t\terror: Promise<Error | null>\n\t\t\t\t/**\n\t\t\t\t * Listener to intercept the end of the lifecycle\n\t\t\t\t *\n\t\t\t\t * If you want to mutate the context, you must do it in this function\n\t\t\t\t * as there's a lock mechanism to ensure the context is mutate successfully\n\t\t\t\t */\n\t\t\t\tonStop(\n\t\t\t\t\t/**\n\t\t\t\t\t * A callback function that will be called when the function ends\n\t\t\t\t\t *\n\t\t\t\t\t * If you want to mutate the context, you must do it in this function\n\t\t\t\t\t * as there's a lock mechanism to ensure the context is mutate successfully\n\t\t\t\t\t */\n\t\t\t\t\tcallback?: (detail: TraceEndDetail) => unknown\n\t\t\t\t): Promise<void>\n\t\t\t} & (WithChildren extends true\n\t\t\t\t? {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * total number of lifecycle's children and\n\t\t\t\t\t\t * total number of `onEvent` will be called\n\t\t\t\t\t\t * if there were no early exists or error thrown\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttotal: number\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Listener to intercept each child lifecycle\n\t\t\t\t\t\t */\n\t\t\t\t\t\tonEvent(\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Callback function that will be called for when each child start\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tcallback?: (\n\t\t\t\t\t\t\t\tprocess: TraceProcess<'begin', false>\n\t\t\t\t\t\t\t) => unknown\n\t\t\t\t\t\t): Promise<void>\n\t\t\t\t\t}\n\t\t\t\t: {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Index of the child event\n\t\t\t\t\t\t */\n\t\t\t\t\t\tindex: number\n\t\t\t\t\t})\n\t\t>\n\t: number\n\nexport type TraceListener = (\n\tcallback?: (process: TraceProcess<'begin'>) => unknown\n) => Promise<TraceProcess<'begin'>>\n\nexport type TraceHandler<\n\tin out Route extends RouteSchema = {},\n\tin out Singleton extends SingletonBase = {\n\t\tdecorator: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t}\n> = {\n\t(\n\t\tlifecycle: Prettify<\n\t\t\t{\n\t\t\t\tid: number\n\t\t\t\tcontext: Context<Route, Singleton>\n\t\t\t\tset: Context['set']\n\t\t\t\ttime: number\n\t\t\t\tstore: Singleton['store']\n\t\t\t} & {\n\t\t\t\t[x in `on${Capitalize<TraceEvent>}`]: TraceListener\n\t\t\t}\n\t\t>\n\t): unknown\n}\n\nexport const ELYSIA_TRACE = Symbol('ElysiaTrace')\n\nconst createProcess = () => {\n\tconst { promise, resolve } = Promise.withResolvers<TraceProcess>()\n\tconst { promise: end, resolve: resolveEnd } =\n\t\tPromise.withResolvers<number>()\n\tconst { promise: error, resolve: resolveError } =\n\t\tPromise.withResolvers<Error | null>()\n\n\tconst callbacks = <Function[]>[]\n\tconst callbacksEnd = <Function[]>[]\n\n\treturn [\n\t\t(callback?: Function) => {\n\t\t\tif (callback) callbacks.push(callback)\n\n\t\t\treturn promise\n\t\t},\n\t\t(process: TraceStream) => {\n\t\t\tconst processes = <((callback?: Function) => Promise<void>)[]>[]\n\t\t\tconst resolvers = <((process: TraceStream) => () => void)[]>[]\n\n\t\t\t// When error is return but not thrown\n\t\t\tlet groupError: Error | null = null\n\n\t\t\tfor (let i = 0; i < (process.total ?? 0); i++) {\n\t\t\t\tconst { promise, resolve } = Promise.withResolvers<void>()\n\t\t\t\tconst { promise: end, resolve: resolveEnd } =\n\t\t\t\t\tPromise.withResolvers<number>()\n\t\t\t\tconst { promise: error, resolve: resolveError } =\n\t\t\t\t\tPromise.withResolvers<Error | null>()\n\n\t\t\t\tconst callbacks = <Function[]>[]\n\t\t\t\tconst callbacksEnd = <Function[]>[]\n\n\t\t\t\tprocesses.push((callback?: Function) => {\n\t\t\t\t\tif (callback) callbacks.push(callback)\n\n\t\t\t\t\treturn promise\n\t\t\t\t})\n\n\t\t\t\tresolvers.push((process: TraceStream) => {\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\t...process,\n\t\t\t\t\t\tend,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tonStop(callback?: Function) {\n\t\t\t\t\t\t\tif (callback) callbacksEnd.push(callback)\n\n\t\t\t\t\t\t\treturn end\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\n\t\t\t\t\tresolve(result)\n\t\t\t\t\tfor (let i = 0; i < callbacks.length; i++)\n\t\t\t\t\t\tcallbacks[i](result)\n\n\t\t\t\t\treturn (error: Error | null = null) => {\n\t\t\t\t\t\tconst end = performance.now()\n\n\t\t\t\t\t\t// Catch return error\n\t\t\t\t\t\tif (error) groupError = error\n\n\t\t\t\t\t\tconst detail = {\n\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\tget elapsed() {\n\t\t\t\t\t\t\t\treturn end - process.begin\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (let i = 0; i < callbacksEnd.length; i++)\n\t\t\t\t\t\t\tcallbacksEnd[i](detail)\n\n\t\t\t\t\t\tresolveEnd(end)\n\t\t\t\t\t\tresolveError(error)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tconst result = {\n\t\t\t\t...process,\n\t\t\t\tend,\n\t\t\t\terror,\n\t\t\t\tonEvent(callback?: Function) {\n\t\t\t\t\tfor (let i = 0; i < processes.length; i++)\n\t\t\t\t\t\tprocesses[i](callback)\n\t\t\t\t},\n\t\t\t\tonStop(callback?: Function) {\n\t\t\t\t\tif (callback) callbacksEnd.push(callback)\n\n\t\t\t\t\treturn end\n\t\t\t\t}\n\t\t\t} as any\n\n\t\t\tresolve(result)\n\t\t\tfor (let i = 0; i < callbacks.length; i++) callbacks[i](result)\n\n\t\t\treturn {\n\t\t\t\tresolveChild: resolvers,\n\t\t\t\tresolve(error: Error | null = null) {\n\t\t\t\t\tconst end = performance.now()\n\n\t\t\t\t\t// If error is return, parent group will not catch an error\n\t\t\t\t\t// but the child group will catch the error\n\t\t\t\t\tif (!error && groupError) error = groupError\n\n\t\t\t\t\tconst detail = {\n\t\t\t\t\t\tend,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tget elapsed() {\n\t\t\t\t\t\t\treturn end - process.begin\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < callbacksEnd.length; i++)\n\t\t\t\t\t\tcallbacksEnd[i](detail)\n\n\t\t\t\t\tresolveEnd(end)\n\t\t\t\t\tresolveError(error)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t] as const\n}\n\nexport const createTracer = (traceListener: TraceHandler) => {\n\treturn (context: Context) => {\n\t\tconst [onRequest, resolveRequest] = createProcess()\n\t\tconst [onParse, resolveParse] = createProcess()\n\t\tconst [onTransform, resolveTransform] = createProcess()\n\t\tconst [onBeforeHandle, resolveBeforeHandle] = createProcess()\n\t\tconst [onHandle, resolveHandle] = createProcess()\n\t\tconst [onAfterHandle, resolveAfterHandle] = createProcess()\n\t\tconst [onError, resolveError] = createProcess()\n\t\tconst [onMapResponse, resolveMapResponse] = createProcess()\n\t\tconst [onAfterResponse, resolveAfterResponse] = createProcess()\n\n\t\ttraceListener({\n\t\t\t// @ts-ignore\n\t\t\tid: context[ELYSIA_REQUEST_ID],\n\t\t\tcontext,\n\t\t\tset: context.set,\n\t\t\t// @ts-ignore\n\t\t\tonRequest,\n\t\t\t// @ts-ignore\n\t\t\tonParse,\n\t\t\t// @ts-ignore\n\t\t\tonTransform,\n\t\t\t// @ts-ignore\n\t\t\tonBeforeHandle,\n\t\t\t// @ts-ignore\n\t\t\tonHandle,\n\t\t\t// @ts-ignore\n\t\t\tonAfterHandle,\n\t\t\t// @ts-ignore\n\t\t\tonMapResponse,\n\t\t\t// @ts-ignore\n\t\t\tonAfterResponse,\n\t\t\t// @ts-ignore\n\t\t\tonError\n\t\t})\n\n\t\t// ? This is pass to compiler\n\t\treturn {\n\t\t\trequest: resolveRequest,\n\t\t\tparse: resolveParse,\n\t\t\ttransform: resolveTransform,\n\t\t\tbeforeHandle: resolveBeforeHandle,\n\t\t\thandle: resolveHandle,\n\t\t\tafterHandle: resolveAfterHandle,\n\t\t\terror: resolveError,\n\t\t\tmapResponse: resolveMapResponse,\n\t\t\tafterResponse: resolveAfterResponse\n\t\t}\n\t}\n}\n",
    "import type { Elysia } from '.'\n\nimport { mapEarlyResponse, mapResponse } from './handler'\nimport {\n\tELYSIA_RESPONSE,\n\tElysiaErrors,\n\tNotFoundError,\n\tValidationError\n} from './error'\n\nimport type { Context } from './context'\nimport { type error } from './error'\n\nimport { parseQuery } from './fast-querystring'\n\nimport { redirect, signCookie, StatusMap } from './utils'\nimport { parseCookie } from './cookies'\n\nimport type { Handler, LifeCycleStore, SchemaValidator } from './types'\n\n// JIT Handler\nexport type DynamicHandler = {\n\thandle: Handler<any, any>\n\tcontent?: string\n\thooks: LifeCycleStore\n\tvalidator?: SchemaValidator\n}\n\nexport const createDynamicHandler =\n\t(app: Elysia<any, any, any, any, any, any, any, any>) =>\n\tasync (request: Request): Promise<Response> => {\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tqi = url.indexOf('?', s + 1),\n\t\t\tpath = qi === -1 ? url.substring(s) : url.substring(s, qi)\n\n\t\tconst set: Context['set'] = {\n\t\t\tcookie: {},\n\t\t\tstatus: 200,\n\t\t\theaders: {}\n\t\t}\n\n\t\tconst context = Object.assign(\n\t\t\t{},\n\t\t\t// @ts-expect-error\n\t\t\tapp.singleton.decorator,\n\t\t\t{\n\t\t\t\tset,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tstore: app.singleton.store,\n\t\t\t\trequest,\n\t\t\t\tpath,\n\t\t\t\tqi,\n\t\t\t\tredirect\n\t\t\t}\n\t\t) as unknown as Context & {\n\t\t\tresponse: unknown\n\t\t}\n\n\t\ttry {\n\t\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\t\tconst onRequest = app.event.request[i].fn\n\t\t\t\tlet response = onRequest(context as any)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\tresponse = mapEarlyResponse(response, set)\n\t\t\t\tif (response) return (context.response = response)\n\t\t\t}\n\n\t\t\tconst handler =\n\t\t\t\tapp.router.dynamic.find(request.method, path) ??\n\t\t\t\tapp.router.dynamic.find('ALL', path)\n\n\t\t\tif (!handler) throw new NotFoundError()\n\n\t\t\tconst { handle, hooks, validator, content } = handler.store\n\n\t\t\tlet body: string | Record<string, any> | undefined\n\t\t\tif (request.method !== 'GET' && request.method !== 'HEAD') {\n\t\t\t\tif (content) {\n\t\t\t\t\tswitch (content) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\tbody = (await request.json()) as any\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1) body[key] = value[0]\n\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet contentType = request.headers.get('content-type')\n\n\t\t\t\t\tif (contentType) {\n\t\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\t\tif (index !== -1)\n\t\t\t\t\t\t\tcontentType = contentType.slice(0, index)\n\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tcontext.contentType = contentType\n\n\t\t\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\t\t\tconst hook = hooks.parse[i].fn\n\t\t\t\t\t\t\tlet temp = hook(context as any, contentType)\n\t\t\t\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\t\t\t\tif (temp) {\n\t\t\t\t\t\t\t\tbody = temp\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tdelete context.contentType\n\n\t\t\t\t\t\t// body might be empty string thus can't use !body\n\t\t\t\t\t\tif (body === undefined) {\n\t\t\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\t\tbody = (await request.json()) as any\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\t\tbody[key] = value[0]\n\t\t\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.body = body\n\t\t\t// @ts-expect-error\n\t\t\tcontext.params = handler?.params || undefined\n\t\t\tcontext.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1))\n\n\t\t\tcontext.headers = {}\n\t\t\tfor (const [key, value] of request.headers.entries())\n\t\t\t\tcontext.headers[key] = value\n\n\t\t\tconst cookieMeta = Object.assign(\n\t\t\t\t{},\n\t\t\t\tapp.config?.cookie,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvalidator?.cookie?.config\n\t\t\t) as {\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\tsign: string[] | true\n\t\t\t\tproperties: { [x: string]: Object }\n\t\t\t}\n\n\t\t\tconst cookieHeaderValue = request.headers.get('cookie')\n\n\t\t\tcontext.cookie = (await parseCookie(\n\t\t\t\tcontext.set,\n\t\t\t\tcookieHeaderValue,\n\t\t\t\tcookieMeta\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsecrets:\n\t\t\t\t\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.secrets.join(',')\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\tsign:\n\t\t\t\t\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t\t\t\t\t? typeof cookieMeta.sign === 'string'\n\t\t\t\t\t\t\t\t\t\t\t? cookieMeta.sign\n\t\t\t\t\t\t\t\t\t\t\t: cookieMeta.sign.join(',')\n\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined\n\t\t\t)) as any\n\n\t\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\t\tconst hook = hooks.transform[i]\n\t\t\t\tconst operation = hook.fn(context)\n\n\t\t\t\tif (hook.subType === 'derive') {\n\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t} else if (operation instanceof Promise) await operation\n\t\t\t}\n\n\t\t\tif (validator) {\n\t\t\t\tif (validator.createHeaders?.()) {\n\t\t\t\t\tconst _header: Record<string, string> = {}\n\t\t\t\t\tfor (const key in request.headers)\n\t\t\t\t\t\t_header[key] = request.headers.get(key)!\n\n\t\t\t\t\tif (validator.headers!.Check(_header) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'header',\n\t\t\t\t\t\t\tvalidator.headers!,\n\t\t\t\t\t\t\t_header\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.createParams?.()?.Check(context.params) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'params',\n\t\t\t\t\t\tvalidator.params!,\n\t\t\t\t\t\tcontext.params\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.createQuery?.()?.Check(context.query) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'query',\n\t\t\t\t\t\tvalidator.query!,\n\t\t\t\t\t\tcontext.query\n\t\t\t\t\t)\n\n\t\t\t\tif (validator.createCookie?.()) {\n\t\t\t\t\tconst cookieValue: Record<string, unknown> = {}\n\t\t\t\t\tfor (const [key, value] of Object.entries(context.cookie))\n\t\t\t\t\t\tcookieValue[key] = value.value\n\n\t\t\t\t\tif (validator.cookie!.Check(cookieValue) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'cookie',\n\t\t\t\t\t\t\tvalidator.cookie!,\n\t\t\t\t\t\t\tcookieValue\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (validator.createBody?.()?.Check(body) === false)\n\t\t\t\t\tthrow new ValidationError('body', validator.body!, body)\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\t\tlet response = hooks.beforeHandle[i].fn(context)\n\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\t// `false` is a falsey value, check for undefined instead\n\t\t\t\tif (response !== undefined) {\n\t\t\t\t\t;(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t).response = response\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i].fn(\n\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\tif (newResponse) response = newResponse\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = mapEarlyResponse(response, context.set)\n\t\t\t\t\tif (result) return (context.response = result)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet response = handle(context)\n\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\tif (!hooks.afterHandle.length) {\n\t\t\t\tconst status =\n\t\t\t\t\t(response as ReturnType<typeof error>)[ELYSIA_RESPONSE] ??\n\t\t\t\t\t(set.status\n\t\t\t\t\t\t? typeof set.status === 'string'\n\t\t\t\t\t\t\t? StatusMap[set.status]\n\t\t\t\t\t\t\t: set.status\n\t\t\t\t\t\t: 200)\n\n\t\t\t\tconst responseValidator =\n\t\t\t\t\tvalidator?.createResponse?.()?.[status]\n\n\t\t\t\tif (responseValidator?.Check(response) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'response',\n\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\tresponse\n\t\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t;(\n\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t}\n\t\t\t\t).response = response\n\n\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\tlet newResponse = hooks.afterHandle[i].fn(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\tconst result = mapEarlyResponse(newResponse, context.set)\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\t\tvalidator?.response?.[result.status]\n\n\t\t\t\t\t\tif (responseValidator?.Check(result) === false)\n\t\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn (context.response = result)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (context.set.cookie && cookieMeta?.sign) {\n\t\t\t\tconst secret = !cookieMeta.secrets\n\t\t\t\t\t? undefined\n\t\t\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t: cookieMeta.secrets[0]\n\n\t\t\t\tif (cookieMeta.sign === true)\n\t\t\t\t\tfor (const [key, cookie] of Object.entries(\n\t\t\t\t\t\tcontext.set.cookie\n\t\t\t\t\t))\n\t\t\t\t\t\tcontext.set.cookie[key].value = await signCookie(\n\t\t\t\t\t\t\tcookie.value as any,\n\t\t\t\t\t\t\t'${secret}'\n\t\t\t\t\t\t)\n\t\t\t\telse {\n\t\t\t\t\t// @ts-expect-error private\n\t\t\t\t\tconst properties = validator?.cookie?.schema?.properties\n\n\t\t\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\t\t\tif (!(name in properties)) continue\n\n\t\t\t\t\t\tif (context.set.cookie[name]?.value) {\n\t\t\t\t\t\t\tcontext.set.cookie[name].value = await signCookie(\n\t\t\t\t\t\t\t\tcontext.set.cookie[name].value as any,\n\t\t\t\t\t\t\t\tsecret as any\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (context.response = mapResponse(response, context.set))\n\t\t} catch (error) {\n\t\t\tif ((error as ElysiaErrors).status)\n\t\t\t\tset.status = (error as ElysiaErrors).status\n\n\t\t\t// @ts-expect-error private\n\t\t\treturn app.handleError(context, error)\n\t\t} finally {\n\t\t\tfor (const afterResponse of app.event.afterResponse)\n\t\t\t\tawait afterResponse.fn(context as any)\n\t\t}\n\t}\n\nexport const createDynamicErrorHandler =\n\t(app: Elysia<any, any, any, any, any, any, any, any>) =>\n\tasync (\n\t\tcontext: Context & {\n\t\t\tresponse: unknown\n\t\t},\n\t\terror: ElysiaErrors\n\t) => {\n\t\tconst errorContext = Object.assign(context, { error, code: error.code })\n\t\terrorContext.set = context.set\n\n\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\tconst hook = app.event.error[i]\n\t\t\tlet response = hook.fn(errorContext as any)\n\t\t\tif (response instanceof Promise) response = await response\n\t\t\tif (response !== undefined && response !== null)\n\t\t\t\treturn (context.response = mapResponse(response, context.set))\n\t\t}\n\n\t\treturn new Response(\n\t\t\ttypeof error.cause === 'string' ? error.cause : error.message,\n\t\t\t{\n\t\t\t\theaders: context.set.headers,\n\t\t\t\tstatus: error.status ?? 500\n\t\t\t}\n\t\t)\n\t}\n",
    "import type { Serve, Server, ServerWebSocket } from 'bun'\n\nimport { Memoirist } from 'memoirist'\nimport {\n\ttype TObject,\n\ttype Static,\n\ttype TSchema,\n\tPartial\n} from '@sinclair/typebox'\n\nimport type { Context } from './context'\n\nimport { t, TypeCheck } from './type-system'\nimport { sucrose, type Sucrose } from './sucrose'\n\nimport { ElysiaWS, websocket } from './ws'\nimport type { WS } from './ws/types'\n\nimport { version as _version } from '../package.json'\n\nimport { isNotEmpty } from './handler'\n\nimport {\n\tcloneInference,\n\tdeduplicateChecksum,\n\tfnToContainer,\n\tlocalHookToLifeCycleStore,\n\tmergeDeep,\n\tmergeSchemaValidator,\n\tPromiseGroup,\n\tpromoteEvent,\n\tstringToStructureCoercions\n} from './utils'\n\nimport {\n\tcomposeHandler,\n\tcomposeGeneralHandler,\n\tcomposeErrorHandler\n} from './compose'\n\nimport { createTracer } from './trace'\n\nimport {\n\tmergeHook,\n\tgetSchemaValidator,\n\tgetResponseSchemaValidator,\n\tchecksum,\n\tmergeLifeCycle,\n\tfilterGlobalHook,\n\tasHookType,\n\ttraceBackMacro,\n\treplaceUrlPath,\n\tisNumericString,\n\tcreateMacroManager,\n\tgetCookieValidator\n} from './utils'\n\nimport {\n\tcreateDynamicErrorHandler,\n\tcreateDynamicHandler,\n\ttype DynamicHandler\n} from './dynamic-handle'\n\nimport {\n\tERROR_CODE,\n\tisProduction,\n\tValidationError,\n\ttype ParseError,\n\ttype NotFoundError,\n\ttype InternalServerError\n} from './error'\n\nimport type { TraceHandler } from './trace'\n\nimport type {\n\tElysiaConfig,\n\tSingletonBase,\n\tDefinitionBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tAfterHandler,\n\tErrorHandler,\n\tLifeCycleStore,\n\tMaybePromise,\n\tPrettify,\n\tPrettify2,\n\tListenCallback,\n\tAddPrefix,\n\tAddSuffix,\n\tAddPrefixCapitalize,\n\tAddSuffixCapitalize,\n\tMaybeArray,\n\tGracefulHandler,\n\tMapResponse,\n\tChecksum,\n\tMacroManager,\n\tMacroToProperty,\n\tTransformHandler,\n\tMetadataBase,\n\tRouteBase,\n\tCreateEden,\n\tComposeElysiaResponse,\n\tInlineHandler,\n\tHookContainer,\n\tLifeCycleType,\n\tMacroQueue,\n\tEphemeralType,\n\tExcludeElysiaResponse,\n\tModelValidator,\n\tBaseMacroFn,\n\tContextAppendType,\n\tReconcile,\n\tAfterResponseHandler,\n\tHigherOrderFunction,\n\tResolvePath,\n\tJoinPath,\n\tValidatorLayer\n} from './types'\n\nexport type AnyElysia = Elysia<any, any, any, any, any, any, any, any>\n\n/**\n * ### Elysia Server\n * Main instance to create web server using Elysia\n *\n * ---\n * @example\n * ```typescript\n * import { Elysia } from 'elysia'\n *\n * new Elysia()\n *     .get(\"/\", () => \"Hello\")\n *     .listen(3000)\n * ```\n */\nexport default class Elysia<\n\tconst in out BasePath extends string = '',\n\tconst in out Scoped extends boolean = false,\n\tconst in out Singleton extends SingletonBase = {\n\t\tdecorator: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t},\n\tconst in out Definitions extends DefinitionBase = {\n\t\ttype: {}\n\t\terror: {}\n\t},\n\tconst in out Metadata extends MetadataBase = {\n\t\tschema: {}\n\t\tmacro: {}\n\t\tmacroFn: {}\n\t},\n\tconst out Routes extends RouteBase = {},\n\t// ? scoped\n\tconst in out Ephemeral extends EphemeralType = {\n\t\tderive: {}\n\t\tresolve: {}\n\t\tschema: {}\n\t},\n\t// ? local\n\tconst in out Volatile extends EphemeralType = {\n\t\tderive: {}\n\t\tresolve: {}\n\t\tschema: {}\n\t}\n> {\n\tconfig: ElysiaConfig<BasePath, Scoped>\n\n\tserver: Server | null = null\n\tprivate dependencies: Record<string, Checksum[]> = {}\n\n\t_routes: Routes = {} as any\n\n\t_types = {\n\t\tPrefix: '' as BasePath,\n\t\tScoped: false as Scoped,\n\t\tSingleton: {} as Singleton,\n\t\tDefinitions: {} as Definitions,\n\t\tMetadata: {} as Metadata\n\t}\n\n\t_ephemeral = {} as Ephemeral\n\t_volatile = {} as Volatile\n\n\tstatic version = _version\n\tversion = _version\n\n\tprotected singleton = {\n\t\tdecorator: {},\n\t\tstore: {},\n\t\tderive: {},\n\t\tresolve: {}\n\t} as Singleton\n\n\tget store(): Singleton['store'] {\n\t\treturn this.singleton.store\n\t}\n\n\tget decorator(): Singleton['decorator'] {\n\t\treturn this.singleton.decorator\n\t}\n\n\tget _scoped() {\n\t\treturn this.config.scoped as Scoped\n\t}\n\n\tprotected definitions = {\n\t\ttype: {} as Record<string, TSchema>,\n\t\terror: {} as Record<string, Error>\n\t}\n\n\tprotected extender = {\n\t\tmacros: <MacroQueue[]>[],\n\t\thigherOrderFunctions: <HookContainer<HigherOrderFunction>[]>[]\n\t}\n\n\tprotected validator: ValidatorLayer = {\n\t\tglobal: null,\n\t\tscoped: null,\n\t\tlocal: null,\n\t\tgetCandidate() {\n\t\t\treturn mergeSchemaValidator(\n\t\t\t\tmergeSchemaValidator(this.global, this.scoped),\n\t\t\t\tthis.local\n\t\t\t)\n\t\t}\n\t}\n\n\tevent: LifeCycleStore = {\n\t\tstart: [],\n\t\trequest: [],\n\t\tparse: [],\n\t\ttransform: [],\n\t\tbeforeHandle: [],\n\t\tafterHandle: [],\n\t\tmapResponse: [],\n\t\tafterResponse: [],\n\t\ttrace: [],\n\t\terror: [],\n\t\tstop: []\n\t}\n\n\tprotected telemetry = {\n\t\tstack: undefined as string | undefined\n\t}\n\n\trouter = {\n\t\thttp: new Memoirist<{\n\t\t\tcompile: Function\n\t\t\thandler?: ComposedHandler\n\t\t}>(),\n\t\tws: new Memoirist<{\n\t\t\tcompile: Function\n\t\t\thandler?: ComposedHandler\n\t\t}>(),\n\t\t// Use in non-AOT mode\n\t\tdynamic: new Memoirist<DynamicHandler>(),\n\t\tstatic: {\n\t\t\thttp: {\n\t\t\t\thandlers: [] as ComposedHandler[],\n\t\t\t\tmap: {} as Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tcode: string\n\t\t\t\t\t\tall?: string\n\t\t\t\t\t}\n\t\t\t\t>,\n\t\t\t\tall: ''\n\t\t\t},\n\t\t\t// Static WS Router is consists of pathname and websocket handler index to compose\n\t\t\tws: {} as Record<string, number>\n\t\t},\n\t\thistory: [] as InternalRoute[]\n\t}\n\n\tprotected routeTree = new Map<string, number>()\n\n\tget routes(): InternalRoute[] {\n\t\treturn this.router.history\n\t}\n\n\tprotected getGlobalRoutes(): InternalRoute[] {\n\t\treturn this.router.history\n\t}\n\n\tprotected inference: Sucrose.Inference = {\n\t\tbody: false,\n\t\tcookie: false,\n\t\theaders: false,\n\t\tquery: false,\n\t\tset: false,\n\t\tserver: false\n\t}\n\n\tprivate getServer() {\n\t\treturn this.server\n\t}\n\n\tprivate _promisedModules: PromiseGroup | undefined\n\tprivate get promisedModules() {\n\t\tif (!this._promisedModules) this._promisedModules = new PromiseGroup()\n\n\t\treturn this._promisedModules\n\t}\n\n\tconstructor(config?: ElysiaConfig<BasePath, Scoped>) {\n\t\tif (config?.tags) {\n\t\t\tif (!config.detail)\n\t\t\t\tconfig.detail = {\n\t\t\t\t\ttags: config.tags\n\t\t\t\t}\n\t\t\telse config.detail.tags = config.tags\n\t\t}\n\n\t\tthis.config = {}\n\t\tthis.applyConfig(config ?? {})\n\n\t\tif (config?.analytic && (config?.name || config?.seed !== undefined))\n\t\t\tthis.telemetry.stack = new Error().stack\n\t}\n\n\tenv(model: TObject<any>, env = Bun?.env ?? process.env) {\n\t\tconst validator = getSchemaValidator(model, {\n\t\t\tdynamic: true,\n\t\t\tadditionalProperties: true,\n\t\t\tcoerce: true\n\t\t})\n\n\t\tif (validator.Check(env) === false) {\n\t\t\tconst error = new ValidationError('env', model, env)\n\n\t\t\tthrow new Error(error.all.map((x) => x.summary).join('\\n'))\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * @private DO_NOT_USE_OR_YOU_WILL_BE_FIRE\n\t *\n\t * ! Do not use unless you now exactly what you are doing\n\t * ? Add Higher order function to Elysia.fetch\n\t */\n\twrap(fn: HigherOrderFunction) {\n\t\tthis.extender.higherOrderFunctions.push({\n\t\t\tchecksum: checksum(\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tname: this.config.name,\n\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\tcontent: fn.toString()\n\t\t\t\t})\n\t\t\t),\n\t\t\tfn\n\t\t})\n\n\t\treturn this\n\t}\n\n\tprivate applyMacro(\n\t\tlocalHook: LocalHook<any, any, any, any, any, any, any>\n\t) {\n\t\tif (this.extender.macros.length) {\n\t\t\tconst manage = createMacroManager({\n\t\t\t\tglobalHook: this.event,\n\t\t\t\tlocalHook\n\t\t\t})\n\n\t\t\tconst manager: MacroManager = {\n\t\t\t\tevents: {\n\t\t\t\t\tglobal: this.event,\n\t\t\t\t\tlocal: localHook\n\t\t\t\t},\n\t\t\t\tonParse: manage('parse') as any,\n\t\t\t\tonTransform: manage('transform') as any,\n\t\t\t\tonBeforeHandle: manage('beforeHandle') as any,\n\t\t\t\tonAfterHandle: manage('afterHandle') as any,\n\t\t\t\tmapResponse: manage('mapResponse') as any,\n\t\t\t\tonAfterResponse: manage('afterResponse') as any,\n\t\t\t\tonError: manage('error') as any\n\t\t\t}\n\n\t\t\tfor (const macro of this.extender.macros)\n\t\t\t\ttraceBackMacro(macro.fn(manager), localHook)\n\t\t}\n\t}\n\n\tapplyConfig(config: ElysiaConfig<BasePath, Scoped>) {\n\t\tthis.config = {\n\t\t\tprefix: '',\n\t\t\taot: true,\n\t\t\tstrictPath: false,\n\t\t\tglobal: false,\n\t\t\tanalytic: false,\n\t\t\tnormalize: true,\n\t\t\t...config,\n\t\t\tcookie: {\n\t\t\t\tpath: '/',\n\t\t\t\t...config?.cookie\n\t\t\t},\n\t\t\texperimental: config?.experimental ?? {},\n\t\t\tseed: config?.seed === undefined ? '' : config?.seed\n\t\t} as any\n\n\t\treturn this\n\t}\n\n\tget models(): {\n\t\t[K in keyof Definitions['type']]: ModelValidator<\n\t\t\t// @ts-ignore Trust me bro\n\t\t\tDefinitions['type'][K]\n\t\t>\n\t} {\n\t\tconst models: Record<string, TypeCheck<TSchema>> = {}\n\n\t\tfor (const [name, schema] of Object.entries(this.definitions.type))\n\t\t\tmodels[name] = getSchemaValidator(\n\t\t\t\tschema as any\n\t\t\t) as TypeCheck<TSchema>\n\n\t\treturn models as any\n\t}\n\n\tprivate add(\n\t\tmethod: HTTPMethod,\n\t\tpath: string,\n\t\thandle: Handler<any, any, any> | any,\n\t\tlocalHook?: LocalHook<any, any, any, any, any, any>,\n\t\t{ allowMeta = false, skipPrefix = false } = {\n\t\t\tallowMeta: false as boolean | undefined,\n\t\t\tskipPrefix: false as boolean | undefined\n\t\t}\n\t) {\n\t\tlocalHook = localHookToLifeCycleStore(localHook)\n\n\t\tif (path !== '' && path.charCodeAt(0) !== 47) path = '/' + path\n\n\t\tif (this.config.prefix && !skipPrefix && !this.config.scoped)\n\t\t\tpath = this.config.prefix + path\n\n\t\tif (localHook?.type)\n\t\t\tswitch (localHook.type) {\n\t\t\t\tcase 'text':\n\t\t\t\t\tlocalHook.type = 'text/plain'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'json':\n\t\t\t\t\tlocalHook.type = 'application/json'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\t\tlocalHook.type = 'multipart/form-data'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tlocalHook.type = 'application/x-www-form-urlencoded'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tlocalHook.type = 'application/octet-stream'\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\tconst models = this.definitions.type\n\n\t\t// ? Clone is need because of JIT, so the context doesn't switch between instance\n\t\tconst dynamic = !this.config.aot\n\n\t\tconst instanceValidator = { ...this.validator.getCandidate() }\n\n\t\tconst cloned = {\n\t\t\tbody: localHook?.body ?? (instanceValidator?.body as any),\n\t\t\theaders: localHook?.headers ?? (instanceValidator?.headers as any),\n\t\t\tparams: localHook?.params ?? (instanceValidator?.params as any),\n\t\t\tquery: localHook?.query ?? (instanceValidator?.query as any),\n\t\t\tcookie: localHook?.cookie ?? (instanceValidator?.cookie as any),\n\t\t\tresponse:\n\t\t\t\tlocalHook?.response ?? (instanceValidator?.response as any)\n\t\t}\n\n\t\tconst cookieValidator = () =>\n\t\t\tcloned.cookie\n\t\t\t\t? getCookieValidator({\n\t\t\t\t\t\tvalidator: cloned.cookie,\n\t\t\t\t\t\tdefaultConfig: this.config.cookie,\n\t\t\t\t\t\tconfig: cloned.cookie?.config ?? {},\n\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\tmodels\n\t\t\t\t\t})\n\t\t\t\t: undefined\n\n\t\tconst normalize = this.config.normalize\n\n\t\tconst validator =\n\t\t\tthis.config.precompile === true ||\n\t\t\t(typeof this.config.precompile === 'object' &&\n\t\t\t\tthis.config.precompile.schema === true)\n\t\t\t\t? {\n\t\t\t\t\t\tbody: getSchemaValidator(cloned.body, {\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize\n\t\t\t\t\t\t}),\n\t\t\t\t\t\theaders: getSchemaValidator(cloned.headers, {\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tadditionalProperties: !this.config.normalize,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tparams: getSchemaValidator(cloned.params, {\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tquery: getSchemaValidator(cloned.query, {\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tcookie: cookieValidator(),\n\t\t\t\t\t\tresponse: getResponseSchemaValidator(cloned.response, {\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t: ({\n\t\t\t\t\t\tcreateBody() {\n\t\t\t\t\t\t\tif (this.body) return this.body\n\n\t\t\t\t\t\t\treturn (this.body = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.body,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tnormalize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateHeaders() {\n\t\t\t\t\t\t\tif (this.headers) return this.headers\n\n\t\t\t\t\t\t\treturn (this.headers = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.headers,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tadditionalProperties: !normalize,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateParams() {\n\t\t\t\t\t\t\tif (this.params) return this.params\n\n\t\t\t\t\t\t\treturn (this.params = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.params,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateQuery() {\n\t\t\t\t\t\t\tif (this.query) return this.query\n\n\t\t\t\t\t\t\treturn (this.query = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.query,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateCookie() {\n\t\t\t\t\t\t\tif (this.cookie) return this.cookie\n\n\t\t\t\t\t\t\treturn (this.cookie = cookieValidator())\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateResponse() {\n\t\t\t\t\t\t\tif (this.response) return this.response\n\n\t\t\t\t\t\t\treturn (this.response = getResponseSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.response,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tnormalize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any)\n\n\t\tconst loosePath = path.endsWith('/')\n\t\t\t? path.slice(0, path.length - 1)\n\t\t\t: path + '/'\n\n\t\t// ! Init default [] for hooks if undefined\n\t\tlocalHook = mergeHook(localHook, instanceValidator)\n\n\t\tif (localHook.tags) {\n\t\t\tif (!localHook.detail)\n\t\t\t\tlocalHook.detail = {\n\t\t\t\t\ttags: localHook.tags\n\t\t\t\t}\n\t\t\telse localHook.detail.tags = localHook.tags\n\t\t}\n\n\t\tif (isNotEmpty(this.config.detail))\n\t\t\tlocalHook.detail = mergeDeep(\n\t\t\t\tObject.assign({}, this.config.detail!),\n\t\t\t\tlocalHook.detail\n\t\t\t)\n\n\t\tthis.applyMacro(localHook)\n\n\t\tconst hooks = mergeHook(this.event, localHook)\n\n\t\tif (this.config.aot === false) {\n\t\t\tthis.router.dynamic.add(method, path, {\n\t\t\t\tvalidator,\n\t\t\t\thooks,\n\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\thandle\n\t\t\t})\n\n\t\t\tif (this.config.strictPath === false) {\n\t\t\t\tthis.router.dynamic.add(method, loosePath, {\n\t\t\t\t\tvalidator,\n\t\t\t\t\thooks,\n\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\thandle\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tthis.router.history.push({\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tcomposed: null,\n\t\t\t\thandler: handle,\n\t\t\t\thooks: hooks as any\n\t\t\t})\n\n\t\t\treturn\n\t\t}\n\n\t\tconst shouldPrecompile =\n\t\t\tthis.config.precompile === true ||\n\t\t\t(typeof this.config.precompile === 'object' &&\n\t\t\t\tthis.config.precompile.compose === true)\n\n\t\tconst inference = cloneInference(this.inference)\n\n\t\tconst compile = () =>\n\t\t\tcomposeHandler({\n\t\t\t\tapp: this,\n\t\t\t\tpath,\n\t\t\t\tmethod,\n\t\t\t\tlocalHook: mergeHook(localHook),\n\t\t\t\thooks,\n\t\t\t\tvalidator,\n\t\t\t\thandler: handle,\n\t\t\t\tallowMeta,\n\t\t\t\tinference\n\t\t\t})\n\n\t\tconst mainHandler = shouldPrecompile\n\t\t\t? compile()\n\t\t\t: (((context: Context) => {\n\t\t\t\t\treturn compile()(context)\n\t\t\t\t}) as ComposedHandler)\n\n\t\tconst routeIndex = this.router.history.length\n\n\t\tif (this.routeTree.has(method + path))\n\t\t\tfor (let i = 0; i < this.router.history.length; i++) {\n\t\t\t\tconst route = this.router.history[i]\n\t\t\t\tif (route.path === path && route.method === method) {\n\t\t\t\t\tconst removed = this.router.history.splice(i, 1)[0]\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tremoved &&\n\t\t\t\t\t\tthis.routeTree.has(removed?.method + removed?.path)\n\t\t\t\t\t)\n\t\t\t\t\t\tthis.routeTree.delete(removed.method + removed.path)\n\t\t\t\t}\n\t\t\t}\n\t\telse this.routeTree.set(method + path, routeIndex)\n\n\t\tthis.router.history.push({\n\t\t\tmethod,\n\t\t\tpath,\n\t\t\tcomposed: mainHandler,\n\t\t\thandler: handle,\n\t\t\thooks: hooks as any\n\t\t})\n\n\t\tconst staticRouter = this.router.static.http\n\n\t\tconst handler = {\n\t\t\thandler: shouldPrecompile ? mainHandler : undefined,\n\t\t\tcompile\n\t\t}\n\n\t\tif (method === '$INTERNALWS') {\n\t\t\tconst loose = this.config.strictPath\n\t\t\t\t? undefined\n\t\t\t\t: path.endsWith('/')\n\t\t\t\t\t? path.slice(0, path.length - 1)\n\t\t\t\t\t: path + '/'\n\n\t\t\tif (path.indexOf(':') === -1 && path.indexOf('*') === -1) {\n\t\t\t\tconst index = staticRouter.handlers.length\n\t\t\t\tstaticRouter.handlers.push((ctx) =>\n\t\t\t\t\t(\n\t\t\t\t\t\t(staticRouter.handlers[index] =\n\t\t\t\t\t\t\tcompile()) as ComposedHandler\n\t\t\t\t\t)(ctx)\n\t\t\t\t)\n\n\t\t\t\tthis.router.static.ws[path] = index\n\t\t\t\tif (loose) this.router.static.ws[loose] = index\n\t\t\t} else {\n\t\t\t\tthis.router.ws.add('ws', path, handler)\n\t\t\t\tif (loose) this.router.ws.add('ws', loose, handler)\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tif (path.indexOf(':') === -1 && path.indexOf('*') === -1) {\n\t\t\tconst index = staticRouter.handlers.length\n\t\t\tstaticRouter.handlers.push((ctx) =>\n\t\t\t\t((staticRouter.handlers[index] = compile()) as ComposedHandler)(\n\t\t\t\t\tctx\n\t\t\t\t)\n\t\t\t)\n\n\t\t\tif (!staticRouter.map[path])\n\t\t\t\tstaticRouter.map[path] = {\n\t\t\t\t\tcode: ''\n\t\t\t\t}\n\n\t\t\tif (method === 'ALL')\n\t\t\t\tstaticRouter.map[path].all =\n\t\t\t\t\t`default: return st[${index}](ctx)\\n`\n\t\t\telse\n\t\t\t\tstaticRouter.map[path].code =\n\t\t\t\t\t`case '${method}': return st[${index}](ctx)\\n${staticRouter.map[path].code}`\n\n\t\t\tif (!this.config.strictPath) {\n\t\t\t\tif (!staticRouter.map[loosePath])\n\t\t\t\t\tstaticRouter.map[loosePath] = {\n\t\t\t\t\t\tcode: ''\n\t\t\t\t\t}\n\n\t\t\t\tif (method === 'ALL')\n\t\t\t\t\tstaticRouter.map[loosePath].all =\n\t\t\t\t\t\t`default: return st[${index}](ctx)\\n`\n\t\t\t\telse\n\t\t\t\t\tstaticRouter.map[loosePath].code =\n\t\t\t\t\t\t`case '${method}': return st[${index}](ctx)\\n${staticRouter.map[loosePath].code}`\n\t\t\t}\n\t\t} else {\n\t\t\tthis.router.http.add(method, path, handler)\n\n\t\t\tif (!this.config.strictPath)\n\t\t\t\tthis.router.http.add(\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath.endsWith('/')\n\t\t\t\t\t\t? path.slice(0, path.length - 1)\n\t\t\t\t\t\t: path + '/',\n\t\t\t\t\thandler\n\t\t\t\t)\n\t\t}\n\t}\n\n\tprivate setHeaders?: Context['set']['headers']\n\theaders(header: Context['set']['headers'] | undefined) {\n\t\tif (!header) return this\n\n\t\tif (!this.setHeaders) this.setHeaders = {}\n\n\t\tthis.setHeaders = mergeDeep(this.setHeaders, header)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### start | Life cycle event\n\t * Called after server is ready for serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStart(({ url, port }) => {\n\t *         console.log(\"Running at ${url}:${port}\")\n\t *     })\n\t *     .listen(3000)\n\t * ```\n\t */\n\tonStart(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('start', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### request | Life cycle event\n\t * Called on every new request is accepted\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onRequest(({ method, url }) => {\n\t *         saveToAnalytic({ method, url })\n\t *     })\n\t * ```\n\t */\n\tonRequest<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tPreHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: {}\n\t\t\t\t\tresolve: {}\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t) {\n\t\tthis.on('request', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse<const Schema extends RouteSchema>(\n\t\tparser: MaybeArray<\n\t\t\tBodyHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\tresolve: {}\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse<const Schema extends RouteSchema, const Type extends LifeCycleType>(\n\t\toptions: { as?: Type },\n\t\tparser: MaybeArray<\n\t\t\tBodyHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\t'global' extends Type\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tPartial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t}\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\tonParse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('parse', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'parse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tTransformHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\tresolve: {}\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tTransformHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\t'global' extends Type\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t}\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\tonTransform(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('transform', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'transform',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tresolve<\n\t\tconst Resolver extends Record<string, unknown>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tresolver: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tSingleton &\n\t\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Resolver | void>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] & ExcludeElysiaResponse<Resolver>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Resolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Resolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tresolve<const Resolver extends Record<string, unknown> | void>(\n\t\tresolver: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tSingleton & {\n\t\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t},\n\t\t\t\t\tBasePath\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Resolver | void>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: Prettify<\n\t\t\t\tVolatile['resolve'] & ExcludeElysiaResponse<Resolver>\n\t\t\t>\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\tresolve(\n\t\toptionsOrResolve: { as?: LifeCycleType } | Function,\n\t\tresolve?: Function\n\t) {\n\t\tif (!resolve) {\n\t\t\tresolve = optionsOrResolve as any\n\t\t\toptionsOrResolve = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'resolve',\n\t\t\tfn: resolve!\n\t\t}\n\n\t\treturn this.onBeforeHandle(optionsOrResolve as any, hook as any) as any\n\t}\n\n\tmapResolve<const NewResolver extends Record<string, unknown>>(\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewResolver | void>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: NewResolver\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\tmapResolve<\n\t\tconst NewResolver extends Record<string, unknown>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t) => MaybePromise<NewResolver | void>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Awaited<NewResolver>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewResolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewResolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tmapResolve(\n\t\toptionsOrResolve: Function | { as?: LifeCycleType },\n\t\tmapper?: Function\n\t) {\n\t\tif (!mapper) {\n\t\t\tmapper = optionsOrResolve as any\n\t\t\toptionsOrResolve = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'mapResolve',\n\t\t\tfn: mapper!\n\t\t}\n\n\t\treturn this.onBeforeHandle(optionsOrResolve as any, hook as any) as any\n\t}\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Execute after validation and before the main route handler.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Execute after validation and before the main route handler.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t}),\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\tonBeforeHandle(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('beforeHandle', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'beforeHandle',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tAfterHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: LifeCycleType },\n\t\thandler: MaybeArray<\n\t\t\tAfterHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonAfterHandle(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('afterHandle', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'afterHandle',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .mapResponse((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tmapResponse<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tMapResponse<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .mapResponse((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tmapResponse<const Schema extends RouteSchema, Type extends LifeCycleType>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tMapResponse<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tmapResponse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('mapResponse', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'mapResponse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### response | Life cycle event\n\t * Call AFTER main handler is executed\n\t * Good for analytic metrics\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterResponse(() => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonAfterResponse<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tAfterResponseHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### response | Life cycle event\n\t * Call AFTER main handler is executed\n\t * Good for analytic metrics\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterResponse(() => {\n\t *         cleanup()\n\t * \t   })\n\t * ```\n\t */\n\n\tonAfterResponse<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tAfterResponseHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonAfterResponse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('afterResponse', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'afterResponse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<TraceHandler<Schema, Singleton>>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<const Schema extends RouteSchema>(\n\t\toptions: { as?: LifeCycleType },\n\t\thandler: MaybeArray<TraceHandler<Schema, Singleton>>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) {\n\t\t\thandler = options as MaybeArray<Function>\n\t\t\toptions = { as: 'local' }\n\t\t}\n\n\t\tif (!Array.isArray(handler)) handler = [handler] as Function[]\n\n\t\tfor (const fn of handler)\n\t\t\tthis.on(\n\t\t\t\toptions as { as?: LifeCycleType },\n\t\t\t\t'trace',\n\t\t\t\tcreateTracer(fn as any) as any\n\t\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<\n\t\tconst Errors extends Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tprototype: Error\n\t\t\t}\n\t\t>\n\t>(\n\t\terrors: Errors\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[K in keyof Errors]: Errors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: Errors[K]\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error({\n\t *         CUSTOM_ERROR: CustomError\n\t *     })\n\t * ```\n\t */\n\terror<\n\t\tName extends string,\n\t\tconst CustomError extends {\n\t\t\tprototype: Error\n\t\t}\n\t>(\n\t\tname: Name,\n\t\terrors: CustomError\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[name in Name]: CustomError extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: CustomError\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<const NewErrors extends Record<string, Error>>(\n\t\tmapper: (decorators: Definitions['error']) => NewErrors\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: Definitions['type']\n\t\t\terror: {\n\t\t\t\t[K in keyof NewErrors]: NewErrors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: never\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\terror(\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tname:\n\t\t\t| string\n\t\t\t| Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tprototype: Error\n\t\t\t\t\t}\n\t\t\t  >\n\t\t\t| Function,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\terror?: {\n\t\t\tprototype: Error\n\t\t}\n\t): AnyElysia {\n\t\tswitch (typeof name) {\n\t\t\tcase 'string':\n\t\t\t\t// @ts-ignore\n\t\t\t\terror.prototype[ERROR_CODE] = name\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis.definitions.error[name] = error\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tthis.definitions.error = name(this.definitions.error)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\tfor (const [code, error] of Object.entries(name)) {\n\t\t\t// @ts-ignore\n\t\t\terror.prototype[ERROR_CODE] = code as any\n\n\t\t\tthis.definitions.error[code] = error as any\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tErrorHandler<\n\t\t\t\tDefinitions['error'],\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tSingleton,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Scope extends LifeCycleType\n\t>(\n\t\toptions: { as?: Scope },\n\t\thandler: MaybeArray<\n\t\t\tErrorHandler<\n\t\t\t\tDefinitions['error'],\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tScope extends 'global'\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\tresolve: Singleton['resolve'] &\n\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t}\n\t\t\t\t\t: Scope extends 'scoped'\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive']\n\t\t\t\t\t\t\t\tresolve: Singleton['resolve'] &\n\t\t\t\t\t\t\t\t\tEphemeral['resolve']\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: Singleton,\n\t\t\t\tScoped extends 'global'\n\t\t\t\t\t? Ephemeral\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tderive: Partial<Ephemeral['derive']>\n\t\t\t\t\t\t\tresolve: Partial<Ephemeral['resolve']>\n\t\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\t},\n\t\t\t\tScoped extends 'global'\n\t\t\t\t\t? Ephemeral\n\t\t\t\t\t: Scoped extends 'scoped'\n\t\t\t\t\t\t? Ephemeral\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tderive: Partial<Ephemeral['derive']>\n\t\t\t\t\t\t\t\tresolve: Partial<Ephemeral['resolve']>\n\t\t\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('error', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'error',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### stop | Life cycle event\n\t * Called after server stop serving request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStop((app) => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonStop(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('stop', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<Event extends keyof LifeCycleStore>(\n\t\ttype: Event,\n\t\thandlers: MaybeArray<\n\t\t\tExtract<LifeCycleStore[Event], HookContainer[]>[0]['fn']\n\t\t>\n\t): this\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<const Event extends keyof LifeCycleStore>(\n\t\toptions: { as?: LifeCycleType },\n\t\ttype: Event,\n\t\thandlers: MaybeArray<Extract<LifeCycleStore[Event], Function[]>[0]>\n\t): this\n\n\ton(\n\t\toptionsOrType: { as?: LifeCycleType } | string,\n\t\ttypeOrHandlers: MaybeArray<Function | HookContainer> | string,\n\t\thandlers?: MaybeArray<Function | HookContainer>\n\t) {\n\t\tlet type: keyof LifeCycleStore\n\n\t\tswitch (typeof optionsOrType) {\n\t\t\tcase 'string':\n\t\t\t\ttype = optionsOrType as any\n\t\t\t\thandlers = typeOrHandlers as any\n\n\t\t\t\tbreak\n\n\t\t\tcase 'object':\n\t\t\t\ttype = typeOrHandlers as any\n\n\t\t\t\tif (\n\t\t\t\t\t!Array.isArray(typeOrHandlers) &&\n\t\t\t\t\ttypeof typeOrHandlers === 'object'\n\t\t\t\t)\n\t\t\t\t\thandlers = typeOrHandlers\n\n\t\t\t\tbreak\n\t\t}\n\n\t\tif (Array.isArray(handlers)) handlers = fnToContainer(handlers)\n\t\telse {\n\t\t\tif (typeof handlers === 'function')\n\t\t\t\thandlers = [\n\t\t\t\t\t{\n\t\t\t\t\t\tfn: handlers\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\telse handlers = [handlers!]\n\t\t}\n\n\t\tconst handles = handlers as HookContainer[]\n\n\t\tfor (const handle of handles)\n\t\t\thandle.scope =\n\t\t\t\ttypeof optionsOrType === 'string'\n\t\t\t\t\t? 'local'\n\t\t\t\t\t: (optionsOrType?.as ?? 'local')\n\n\t\tif (type !== 'trace')\n\t\t\tsucrose(\n\t\t\t\t{\n\t\t\t\t\t[type]: handles.map((x) => x.fn)\n\t\t\t\t},\n\t\t\t\tthis.inference\n\t\t\t)\n\n\t\tfor (const handle of handles) {\n\t\t\tconst fn = asHookType(handle, 'global', { skipIfHasType: true })\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'start':\n\t\t\t\t\tthis.event.start.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'request':\n\t\t\t\t\tthis.event.request.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'parse':\n\t\t\t\t\tthis.event.parse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'transform':\n\t\t\t\t\tthis.event.transform.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'beforeHandle':\n\t\t\t\t\tthis.event.beforeHandle.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'afterHandle':\n\t\t\t\t\tthis.event.afterHandle.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'mapResponse':\n\t\t\t\t\tthis.event.mapResponse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'afterResponse':\n\t\t\t\t\tthis.event.afterResponse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'trace':\n\t\t\t\t\tthis.event.trace.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tthis.event.error.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'stop':\n\t\t\t\t\tthis.event.stop.push(fn as any)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * @deprecated use `Elysia.as` instead\n\t *\n\t * Will be removed in Elysia 1.2\n\t */\n\tpropagate(): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tPrettify2<Ephemeral & Volatile>,\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t}\n\t> {\n\t\tpromoteEvent(this.event.parse)\n\t\tpromoteEvent(this.event.transform)\n\t\tpromoteEvent(this.event.beforeHandle)\n\t\tpromoteEvent(this.event.afterHandle)\n\t\tpromoteEvent(this.event.mapResponse)\n\t\tpromoteEvent(this.event.afterResponse)\n\t\tpromoteEvent(this.event.trace)\n\t\tpromoteEvent(this.event.error)\n\n\t\treturn this as any\n\t}\n\n\tas(type: 'global'): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Prettify<\n\t\t\t\tSingleton['derive'] & Ephemeral['derive'] & Volatile['derive']\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve']\n\t\t\t>\n\t\t},\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: MergeSchema<\n\t\t\t\tMergeSchema<Volatile['schema'], Ephemeral['schema']>,\n\t\t\t\tMetadata['schema']\n\t\t\t>\n\t\t\tmacro: Metadata['macro']\n\t\t\tmacroFn: Metadata['macroFn']\n\t\t},\n\t\tRoutes,\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t},\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t}\n\t>\n\n\tas(type: 'plugin'): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\t{\n\t\t\tderive: Prettify2<Ephemeral['derive'] & Volatile['derive']>\n\t\t\tresolve: Prettify2<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\tschema: MergeSchema<Volatile['schema'], Ephemeral['schema']>\n\t\t},\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t}\n\t>\n\n\tas(type: 'plugin' | 'global') {\n\t\tconst castType = ({ plugin: 'scoped', global: 'global' } as const)[type]\n\n\t\tpromoteEvent(this.event.parse, castType)\n\t\tpromoteEvent(this.event.transform, castType)\n\t\tpromoteEvent(this.event.beforeHandle, castType)\n\t\tpromoteEvent(this.event.afterHandle, castType)\n\t\tpromoteEvent(this.event.mapResponse, castType)\n\t\tpromoteEvent(this.event.afterResponse, castType)\n\t\tpromoteEvent(this.event.trace, castType)\n\t\tpromoteEvent(this.event.error, castType)\n\n\t\tif (type === 'plugin') {\n\t\t\tthis.validator.scoped = mergeSchemaValidator(\n\t\t\t\tthis.validator.scoped,\n\t\t\t\tthis.validator.local\n\t\t\t)\n\t\t\tthis.validator.local = null\n\t\t} else if (type === 'global') {\n\t\t\tthis.validator.global = mergeSchemaValidator(\n\t\t\t\tthis.validator.global,\n\t\t\t\tmergeSchemaValidator(\n\t\t\t\t\tthis.validator.scoped,\n\t\t\t\t\tthis.validator.local\n\t\t\t\t) as SchemaValidator\n\t\t\t) as SchemaValidator\n\n\t\t\tthis.validator.scoped = null\n\t\t\tthis.validator.local = null\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\tgroup<\n\t\tconst Prefix extends string,\n\t\tconst NewElysia extends Elysia<any, any, any, any, any, any, any, any>\n\t>(\n\t\tprefix: Prefix,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\t`${BasePath}${Prefix}`,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['_routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tgroup<\n\t\tconst Prefix extends string,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Input extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<Input, Definitions['type']>,\n\t\t\tMetadata['schema']\n\t\t>\n\t>(\n\t\tprefix: Prefix,\n\t\tschema: LocalHook<\n\t\t\tInput,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t`${BasePath}${Prefix}`\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\t`${BasePath}${Prefix}`,\n\t\t\t\tfalse,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Schema\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes & NewElysia['_routes'],\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### group\n\t * Encapsulate and group path with prefix\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .group('/v1', app => app\n\t *         .get('/', () => 'Hi')\n\t *         .get('/name', () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tgroup(\n\t\tprefix: string,\n\t\tschemaOrRun:\n\t\t\t| LocalHook<any, any, any, any, any, any>\n\t\t\t| ((group: AnyElysia) => AnyElysia),\n\t\trun?: (group: AnyElysia) => AnyElysia\n\t): AnyElysia {\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\n\t\tinstance.singleton = { ...this.singleton }\n\t\tinstance.definitions = { ...this.definitions }\n\t\tinstance.getServer = () => this.getServer()\n\t\tinstance.inference = cloneInference(this.inference)\n\t\tinstance.extender = { ...this.extender }\n\n\t\tconst isSchema = typeof schemaOrRun === 'object'\n\t\tconst sandbox = (isSchema ? run! : schemaOrRun)(instance)\n\t\tthis.singleton = mergeDeep(this.singleton, instance.singleton) as any\n\t\tthis.definitions = mergeDeep(this.definitions, instance.definitions)\n\n\t\tif (sandbox.event.request.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...(this.event.request || []),\n\t\t\t\t...((sandbox.event.request || []) as any)\n\t\t\t]\n\n\t\tif (sandbox.event.mapResponse.length)\n\t\t\tthis.event.mapResponse = [\n\t\t\t\t...(this.event.mapResponse || []),\n\t\t\t\t...((sandbox.event.mapResponse || []) as any)\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.router.history).forEach(\n\t\t\t({ method, path, handler, hooks }) => {\n\t\t\t\tpath = (isSchema ? '' : this.config.prefix) + prefix + path\n\n\t\t\t\tif (isSchema) {\n\t\t\t\t\tconst hook = schemaOrRun\n\t\t\t\t\tconst localHook = hooks as LocalHook<\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany,\n\t\t\t\t\t\tany\n\t\t\t\t\t>\n\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hook, {\n\t\t\t\t\t\t\t...(localHook || {}),\n\t\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t...(localHook.error || {}),\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || {})\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\t\tlocalHook.error,\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || {})\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(\n\t\t\t\t\t\t\thooks as LocalHook<any, any, any, any, any, any>,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror: sandbox.event.error\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tskipPrefix: true\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\thook: { as: Type } & LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tBasePath\n\t\t>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Singleton['resolve']\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\t\t\t\t\tMetadata['schema']\n\t\t\t\t\t\t>\n\t\t\t\t\t>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t},\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Volatile['resolve']\n\t\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\t\t\t\t\t\tMetadata['schema'] & Ephemeral['schema']\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t\t},\n\t\t\t\t\tEphemeral\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Volatile['resolve']\n\t\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\t\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema']\n\t\t>\n\t>(\n\t\thook: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tBasePath\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: Prettify<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t\t>\n\t\t}\n\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema']\n\t\t>\n\t>(\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['_routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tExtract<keyof Definitions['type'], string>\n\t\t>,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema']\n\t\t>\n\t>(\n\t\tschema: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\t''\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['_routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### guard\n\t * Encapsulate and pass hook into all child handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .guard({\n\t *          schema: {\n\t *              body: t.Object({\n\t *                  username: t.String(),\n\t *                  password: t.String()\n\t *              })\n\t *          }\n\t *     }, app => app\n\t *         .get(\"/\", () => 'Hi')\n\t *         .get(\"/name\", () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tguard(\n\t\thook:\n\t\t\t| (LocalHook<any, any, any, any, any, any, any> & {\n\t\t\t\t\tas: LifeCycleType\n\t\t\t  })\n\t\t\t| ((group: AnyElysia) => AnyElysia),\n\t\trun?: (group: AnyElysia) => AnyElysia\n\t): AnyElysia {\n\t\tif (!run) {\n\t\t\tif (typeof hook === 'object') {\n\t\t\t\tthis.applyMacro(hook)\n\t\t\t\t// this.event = mergeLifeCycle(this.event, hook)\n\n\t\t\t\tconst type: LifeCycleType = hook.as ?? 'local'\n\n\t\t\t\tthis.validator[type] = {\n\t\t\t\t\tbody: hook.body ?? this.validator[type]?.body,\n\t\t\t\t\theaders: hook.headers ?? this.validator[type]?.headers,\n\t\t\t\t\tparams: hook.params ?? this.validator[type]?.params,\n\t\t\t\t\tquery: hook.query ?? this.validator[type]?.query,\n\t\t\t\t\tresponse: hook.response ?? this.validator[type]?.response,\n\t\t\t\t\tcookie: hook.cookie ?? this.validator[type]?.cookie\n\t\t\t\t}\n\n\t\t\t\tif (hook.parse) this.on({ as: type }, 'parse', hook.parse)\n\t\t\t\tif (hook.transform)\n\t\t\t\t\tthis.on({ as: type }, 'transform', hook.transform)\n\t\t\t\tif (hook.beforeHandle)\n\t\t\t\t\tthis.on({ as: type }, 'beforeHandle', hook.beforeHandle)\n\t\t\t\tif (hook.afterHandle)\n\t\t\t\t\tthis.on({ as: type }, 'afterHandle', hook.afterHandle)\n\t\t\t\tif (hook.mapResponse)\n\t\t\t\t\tthis.on({ as: type }, 'mapResponse', hook.mapResponse)\n\t\t\t\tif (hook.afterResponse)\n\t\t\t\t\tthis.on({ as: type }, 'afterResponse', hook.afterResponse)\n\t\t\t\tif (hook.error) this.on({ as: type }, 'error', hook.error)\n\n\t\t\t\tif (hook.detail) {\n\t\t\t\t\tif (this.config.detail)\n\t\t\t\t\t\tthis.config.detail = mergeDeep(\n\t\t\t\t\t\t\tObject.assign({}, this.config.detail),\n\t\t\t\t\t\t\thook.detail\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.config.detail = hook.detail\n\t\t\t\t}\n\n\t\t\t\tif (hook?.tags) {\n\t\t\t\t\tif (!this.config.detail)\n\t\t\t\t\t\tthis.config.detail = {\n\t\t\t\t\t\t\ttags: hook.tags\n\t\t\t\t\t\t}\n\t\t\t\t\telse this.config.detail.tags = hook.tags\n\t\t\t\t}\n\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\treturn this.guard({}, hook)\n\t\t}\n\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\t\tinstance.singleton = { ...this.singleton }\n\t\tinstance.definitions = { ...this.definitions }\n\t\tinstance.inference = cloneInference(this.inference)\n\t\tinstance.extender = { ...this.extender }\n\n\t\tconst sandbox = run(instance)\n\t\tthis.singleton = mergeDeep(this.singleton, instance.singleton) as any\n\t\tthis.definitions = mergeDeep(this.definitions, instance.definitions)\n\n\t\t// ? Inject getServer for websocket and trace (important, do not remove)\n\t\tsandbox.getServer = () => this.server\n\n\t\tif (sandbox.event.request.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...(this.event.request || []),\n\t\t\t\t...(sandbox.event.request || [])\n\t\t\t]\n\n\t\tif (sandbox.event.mapResponse.length)\n\t\t\tthis.event.mapResponse = [\n\t\t\t\t...(this.event.mapResponse || []),\n\t\t\t\t...(sandbox.event.mapResponse || [])\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.router.history).forEach(\n\t\t\t({ method, path, handler, hooks: localHook }) => {\n\t\t\t\tthis.add(\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\thandler,\n\t\t\t\t\tmergeHook(hook as LocalHook<any, any, any, any, any>, {\n\t\t\t\t\t\t...((localHook || {}) as LocalHook<\n\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\tany\n\t\t\t\t\t\t>),\n\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t...(localHook.error || {}),\n\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || [])\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\tlocalHook.error,\n\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || [])\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * Inline fn\n\t */\n\tuse<\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Param extends AnyElysia = this\n\t>(\n\t\tplugin: MaybePromise<(app: Param) => MaybePromise<NewElysia>>\n\t): NewElysia['_scoped'] extends false\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t// @ts-expect-error - This is truly ideal\n\t\t\t\tPrettify2<Singleton & NewElysia['_types']['Singleton']>,\n\t\t\t\tPrettify2<Definitions & NewElysia['_types']['Definitions']>,\n\t\t\t\tPrettify2<Metadata & NewElysia['_types']['Metadata']>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tPrettify2<Ephemeral & NewElysia['_ephemeral']>,\n\t\t\t\tPrettify2<Volatile & NewElysia['_volatile']>\n\t\t\t>\n\t\t: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\n\t/**\n\t * Entire Instance\n\t **/\n\tuse<const NewElysia extends AnyElysia>(\n\t\tinstance: MaybePromise<NewElysia>\n\t): NewElysia['_scoped'] extends false\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t// @ts-expect-error - This is truly ideal\n\t\t\t\tPrettify2<Singleton & NewElysia['_types']['Singleton']>,\n\t\t\t\tPrettify2<Definitions & NewElysia['_types']['Definitions']>,\n\t\t\t\tPrettify2<Metadata & NewElysia['_types']['Metadata']>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tPrettify2<Volatile & NewElysia['_ephemeral']>\n\t\t\t>\n\t\t: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\n\t/**\n\t * Import fn\n\t */\n\tuse<const NewElysia extends AnyElysia>(\n\t\tplugin: Promise<{\n\t\t\tdefault: (elysia: AnyElysia) => MaybePromise<NewElysia>\n\t\t}>\n\t): NewElysia['_scoped'] extends false\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t// @ts-expect-error - This is truly ideal\n\t\t\t\tPrettify2<Singleton & NewElysia['_types']['Singleton']>,\n\t\t\t\tPrettify2<Definitions & NewElysia['_types']['Definitions']>,\n\t\t\t\tPrettify2<Metadata & NewElysia['_types']['Metadata']>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tPrettify2<Ephemeral & NewElysia['_ephemeral']>,\n\t\t\t\tPrettify2<Volatile & NewElysia['_volatile']>\n\t\t\t>\n\t\t: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & NewElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\n\t/**\n\t * Import entire instance\n\t */\n\tuse<const LazyLoadElysia extends AnyElysia>(\n\t\tplugin: Promise<{\n\t\t\tdefault: LazyLoadElysia\n\t\t}>\n\t): LazyLoadElysia['_scoped'] extends false\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t// @ts-expect-error - This is truly ideal\n\t\t\t\tPrettify2<Singleton & LazyLoadElysia['_types']['Singleton']>,\n\t\t\t\tPrettify2<\n\t\t\t\t\tDefinitions & LazyLoadElysia['_types']['Definitions']\n\t\t\t\t>,\n\t\t\t\tPrettify2<Metadata & LazyLoadElysia['_types']['Metadata']>,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & LazyLoadElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, LazyLoadElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tPrettify2<Volatile & LazyLoadElysia['_ephemeral']>\n\t\t\t>\n\t\t: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tBasePath extends ``\n\t\t\t\t\t? Routes & LazyLoadElysia['_routes']\n\t\t\t\t\t: Routes & CreateEden<BasePath, LazyLoadElysia['_routes']>,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t/**\n\t * ### use\n\t * Merge separate logic of Elysia with current\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const plugin = (app: Elysia) => app\n\t *     .get('/plugin', () => 'hi')\n\t *\n\t * new Elysia()\n\t *     .use(plugin)\n\t * ```\n\t */\n\tuse(\n\t\tplugin:\n\t\t\t| MaybePromise<AnyElysia>\n\t\t\t| MaybePromise<\n\t\t\t\t\tAnyElysia | ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t\t\t  >\n\t\t\t| Promise<{\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t| AnyElysia\n\t\t\t\t\t\t| ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t\t\t  }>,\n\t\toptions?: { scoped?: boolean }\n\t): AnyElysia {\n\t\tif (options?.scoped)\n\t\t\treturn this.guard({}, (app) => app.use(plugin as any))\n\n\t\tif (Array.isArray(plugin)) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\t\tlet current = this\n\n\t\t\tfor (const p of plugin) current = this.use(p) as any\n\n\t\t\treturn current\n\t\t}\n\n\t\tif (plugin instanceof Promise) {\n\t\t\tthis.promisedModules.add(\n\t\t\t\tplugin\n\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\tif (typeof plugin === 'function') return plugin(this)\n\n\t\t\t\t\t\tif (plugin instanceof Elysia) return this._use(plugin)\n\n\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\treturn plugin.default(this)\n\n\t\t\t\t\t\tif (plugin.default instanceof Elysia)\n\t\t\t\t\t\t\treturn this._use(plugin.default)\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Invalid plugin type. Expected Elysia instance, function, or module with \"default\" as Elysia instance or function that returns Elysia instance.'\n\t\t\t\t\t\t)\n\t\t\t\t\t})\n\t\t\t\t\t.then((x) => x.compile())\n\t\t\t)\n\t\t\treturn this\n\t\t}\n\n\t\treturn this._use(plugin)\n\t}\n\n\tprivate _use(\n\t\tplugin: AnyElysia | ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t) {\n\t\tif (typeof plugin === 'function') {\n\t\t\tconst instance = plugin(this as unknown as any) as unknown as any\n\t\t\tif (instance instanceof Promise) {\n\t\t\t\tthis.promisedModules.add(\n\t\t\t\t\tinstance\n\t\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\t\tif (plugin instanceof Elysia) {\n\t\t\t\t\t\t\t\tthis.compile()\n\n\t\t\t\t\t\t\t\t// Recompile async plugin routes\n\t\t\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\thooks\n\t\t\t\t\t\t\t\t} of Object.values(plugin.router.history)) {\n\t\t\t\t\t\t\t\t\tthis.add(\n\t\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\t\tmergeHook(\n\t\t\t\t\t\t\t\t\t\t\thooks as LocalHook<\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany,\n\t\t\t\t\t\t\t\t\t\t\t\tany\n\t\t\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn plugin\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (typeof plugin === 'function')\n\t\t\t\t\t\t\t\treturn plugin(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\t\treturn plugin.default(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn this._use(plugin)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then((x) => x.compile())\n\t\t\t\t)\n\t\t\t\treturn this as unknown as any\n\t\t\t}\n\n\t\t\treturn instance\n\t\t}\n\n\t\tif (plugin.promisedModules.size) {\n\t\t\tthis.promisedModules.add(\n\t\t\t\tplugin.modules\n\t\t\t\t\t.then(() => this._use(plugin))\n\t\t\t\t\t.then((x) => x.compile())\n\t\t\t)\n\t\t\treturn this\n\t\t}\n\n\t\tconst { name, seed } = plugin.config\n\n\t\tplugin.getServer = () => this.getServer()\n\t\tplugin.getGlobalRoutes = () => this.getGlobalRoutes()\n\n\t\t/**\n\t\t * Model and error is required for Swagger generation\n\t\t */\n\t\tplugin.model(this.definitions.type as any)\n\t\tplugin.error(this.definitions.error as any)\n\n\t\tconst isScoped = plugin.config.scoped as boolean\n\t\tif (isScoped) {\n\t\t\tif (name) {\n\t\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\t\tconst current =\n\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t: 0\n\n\t\t\t\tif (\n\t\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn this\n\n\t\t\t\tthis.dependencies[name].push(\n\t\t\t\t\t!this.config?.analytic\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies,\n\t\t\t\t\t\t\t\tstack: plugin.telemetry.stack,\n\t\t\t\t\t\t\t\troutes: plugin.router.history,\n\t\t\t\t\t\t\t\tdecorators: plugin.singleton.decorator,\n\t\t\t\t\t\t\t\tstore: plugin.singleton.store,\n\t\t\t\t\t\t\t\ttype: plugin.definitions.type,\n\t\t\t\t\t\t\t\terror: plugin.definitions.error,\n\t\t\t\t\t\t\t\tderive: plugin.event.transform\n\t\t\t\t\t\t\t\t\t.filter((x) => x.subType === 'derive')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.fn.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\tresolve: plugin.event.transform\n\t\t\t\t\t\t\t\t\t.filter((x) => x.subType === 'derive')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.fn.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tplugin.extender.macros = this.extender.macros.concat(\n\t\t\t\tplugin.extender.macros\n\t\t\t)\n\n\t\t\tconst macroHashes = <(number | undefined)[]>[]\n\t\t\tfor (let i = 0; i < plugin.extender.macros.length; i++) {\n\t\t\t\tconst macro = this.extender.macros[i]\n\n\t\t\t\tif (macroHashes.includes(macro.checksum)) {\n\t\t\t\t\tplugin.extender.macros.splice(i, 1)\n\t\t\t\t\ti--\n\t\t\t\t}\n\n\t\t\t\tmacroHashes.push(macro.checksum)\n\t\t\t}\n\n\t\t\tplugin.onRequest((context) => {\n\t\t\t\tObject.assign(context, this.singleton.decorator)\n\t\t\t\tObject.assign(context.store, this.singleton.store)\n\t\t\t})\n\n\t\t\tif (plugin.event.trace.length)\n\t\t\t\tplugin.event.trace.push(...plugin.event.trace)\n\n\t\t\tif (!plugin.config.prefix)\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.\"\n\t\t\t\t)\n\n\t\t\tif (plugin.event.error.length)\n\t\t\t\tplugin.event.error.push(...this.event.error)\n\n\t\t\tif (plugin.config.aot) plugin.compile()\n\n\t\t\tif (isScoped === true && plugin.config.prefix) {\n\t\t\t\tthis.mount(plugin.config.prefix + '/', plugin.fetch)\n\n\t\t\t\t// Ensure that when using plugins routes are correctly showing up in the .routes property. Else plugins e.g. swagger will not correctly work.\n\t\t\t\t// This also avoids adding routes multiple times.\n\t\t\t\tfor (const route of plugin.router.history) {\n\t\t\t\t\tthis.routeTree.set(\n\t\t\t\t\t\troute.method + `${plugin.config.prefix}${route.path}`,\n\t\t\t\t\t\tthis.router.history.length\n\t\t\t\t\t)\n\n\t\t\t\t\tthis.router.history.push({\n\t\t\t\t\t\t...route,\n\t\t\t\t\t\tpath: `${plugin.config.prefix}${route.path}`,\n\t\t\t\t\t\thooks: mergeHook(route.hooks, {\n\t\t\t\t\t\t\terror: this.event.error\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.mount(plugin.fetch)\n\n\t\t\t\tfor (const route of plugin.router.history) {\n\t\t\t\t\tthis.routeTree.set(\n\t\t\t\t\t\troute.method + `${plugin.config.prefix}${route.path}`,\n\t\t\t\t\t\tthis.router.history.length\n\t\t\t\t\t)\n\n\t\t\t\t\tthis.router.history.push({\n\t\t\t\t\t\t...route,\n\t\t\t\t\t\tpath: `${plugin.config.prefix}${route.path}`,\n\t\t\t\t\t\thooks: mergeHook(route.hooks, {\n\t\t\t\t\t\t\terror: this.event.error\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this\n\t\t} else {\n\t\t\tthis.headers(plugin.setHeaders)\n\n\t\t\tif (name) {\n\t\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\t\tconst current =\n\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t: 0\n\n\t\t\t\tif (\n\t\t\t\t\t!this.dependencies[name].some(\n\t\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthis.extender.macros = this.extender.macros.concat(\n\t\t\t\t\t\tplugin.extender.macros\n\t\t\t\t\t)\n\n\t\t\t\t\tthis.extender.higherOrderFunctions =\n\t\t\t\t\t\tthis.extender.higherOrderFunctions.concat(\n\t\t\t\t\t\t\tplugin.extender.higherOrderFunctions\n\t\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.extender.macros = this.extender.macros.concat(\n\t\t\t\t\tplugin.extender.macros\n\t\t\t\t)\n\t\t\t\tthis.extender.higherOrderFunctions =\n\t\t\t\t\tthis.extender.higherOrderFunctions.concat(\n\t\t\t\t\t\tplugin.extender.higherOrderFunctions\n\t\t\t\t\t)\n\t\t\t}\n\n\t\t\t// ! Deduplicate current instance\n\t\t\tdeduplicateChecksum(this.extender.macros)\n\t\t\tdeduplicateChecksum(this.extender.higherOrderFunctions)\n\n\t\t\t// ! Deduplicate current instance\n\t\t\tconst hofHashes: number[] = []\n\t\t\tfor (\n\t\t\t\tlet i = 0;\n\t\t\t\ti < this.extender.higherOrderFunctions.length;\n\t\t\t\ti++\n\t\t\t) {\n\t\t\t\tconst hof = this.extender.higherOrderFunctions[i]\n\n\t\t\t\tif (hof.checksum) {\n\t\t\t\t\tif (hofHashes.includes(hof.checksum)) {\n\t\t\t\t\t\tthis.extender.higherOrderFunctions.splice(i, 1)\n\t\t\t\t\t\ti--\n\t\t\t\t\t}\n\n\t\t\t\t\thofHashes.push(hof.checksum)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.inference = {\n\t\t\t\tbody: this.inference.body || plugin.inference.body,\n\t\t\t\tcookie: this.inference.cookie || plugin.inference.cookie,\n\t\t\t\theaders: this.inference.headers || plugin.inference.headers,\n\t\t\t\tquery: this.inference.query || plugin.inference.query,\n\t\t\t\tset: this.inference.set || plugin.inference.set,\n\t\t\t\tserver: this.inference.server || plugin.inference.server\n\t\t\t}\n\t\t}\n\n\t\tthis.decorate(plugin.singleton.decorator)\n\t\tthis.state(plugin.singleton.store)\n\t\tthis.model(plugin.definitions.type)\n\t\tthis.error(plugin.definitions.error as any)\n\t\tplugin.extender.macros = this.extender.macros.concat(\n\t\t\tplugin.extender.macros\n\t\t)\n\n\t\tfor (const { method, path, handler, hooks } of Object.values(\n\t\t\tplugin.router.history\n\t\t)) {\n\t\t\tthis.add(\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\thandler,\n\t\t\t\tmergeHook(\n\t\t\t\t\thooks as LocalHook<any, any, any, any, any, any, any>,\n\t\t\t\t\t{\n\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\tif (!isScoped)\n\t\t\tif (name) {\n\t\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\t\tconst current =\n\t\t\t\t\tseed !== undefined\n\t\t\t\t\t\t? checksum(name + JSON.stringify(seed))\n\t\t\t\t\t\t: 0\n\n\t\t\t\tif (\n\t\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn this\n\n\t\t\t\tthis.dependencies[name].push(\n\t\t\t\t\t!this.config?.analytic\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\t\tdependencies: plugin.dependencies,\n\t\t\t\t\t\t\t\tstack: plugin.telemetry.stack,\n\t\t\t\t\t\t\t\troutes: plugin.router.history,\n\t\t\t\t\t\t\t\tdecorators: plugin.singleton,\n\t\t\t\t\t\t\t\tstore: plugin.singleton.store,\n\t\t\t\t\t\t\t\ttype: plugin.definitions.type,\n\t\t\t\t\t\t\t\terror: plugin.definitions.error,\n\t\t\t\t\t\t\t\tderive: plugin.event.transform\n\t\t\t\t\t\t\t\t\t.filter((x) => x?.subType === 'derive')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\t\tresolve: plugin.event.transform\n\t\t\t\t\t\t\t\t\t.filter((x) => x?.subType === 'resolve')\n\t\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event),\n\t\t\t\t\tcurrent\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event)\n\t\t\t\t)\n\t\t\t}\n\n\t\t// @ts-ignore\n\t\tthis.validator.global = mergeHook(this.validator.global, {\n\t\t\t...plugin.validator.global\n\t\t})\n\t\t// @ts-ignore\n\t\tthis.validator.local = mergeHook(this.validator.local, {\n\t\t\t...plugin.validator.scoped\n\t\t})\n\n\t\treturn this\n\t}\n\n\tmacro<const NewMacro extends BaseMacroFn>(\n\t\tmacro: (\n\t\t\troute: MacroManager<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Partial<Ephemeral['derive'] & Volatile['derive']>\n\t\t\t\t\tresolve: Partial<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\t\t},\n\t\t\t\tDefinitions['error']\n\t\t\t>\n\t\t) => NewMacro\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: Metadata['schema']\n\t\t\tmacro: Metadata['macro'] & Partial<MacroToProperty<NewMacro>>\n\t\t\tmacroFn: Metadata['macroFn'] & NewMacro\n\t\t},\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tconst hook: MacroQueue = {\n\t\t\tchecksum: checksum(\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tname: this.config.name,\n\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\tcontent: macro.toString()\n\t\t\t\t})\n\t\t\t),\n\t\t\tfn: macro as any\n\t\t}\n\n\t\tthis.extender.macros.push(hook)\n\n\t\treturn this as any\n\t}\n\n\tmount(\n\t\thandle: ((request: Request) => MaybePromise<Response>) | AnyElysia\n\t): this\n\tmount(\n\t\tpath: string,\n\t\thandle: ((request: Request) => MaybePromise<Response>) | AnyElysia\n\t): this\n\n\tmount(\n\t\tpath:\n\t\t\t| string\n\t\t\t| ((request: Request) => MaybePromise<Response>)\n\t\t\t| AnyElysia,\n\t\thandle?: ((request: Request) => MaybePromise<Response>) | AnyElysia\n\t) {\n\t\tif (\n\t\t\tpath instanceof Elysia ||\n\t\t\ttypeof path === 'function' ||\n\t\t\tpath.length === 0 ||\n\t\t\tpath === '/'\n\t\t) {\n\t\t\tconst run =\n\t\t\t\ttypeof path === 'function'\n\t\t\t\t\t? path\n\t\t\t\t\t: path instanceof Elysia\n\t\t\t\t\t\t? path.compile().fetch\n\t\t\t\t\t\t: handle instanceof Elysia\n\t\t\t\t\t\t\t? handle.compile().fetch\n\t\t\t\t\t\t\t: handle!\n\n\t\t\tconst handler: Handler<any, any> = async ({ request, path }) =>\n\t\t\t\trun(\n\t\t\t\t\tnew Request(\n\t\t\t\t\t\treplaceUrlPath(request.url, path || '/'),\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t)\n\n\t\t\tthis.all(\n\t\t\t\t'/*',\n\t\t\t\thandler as any,\n\t\t\t\t{\n\t\t\t\t\ttype: 'none'\n\t\t\t\t} as any\n\t\t\t)\n\n\t\t\treturn this\n\t\t}\n\n\t\tconst length = path.length\n\n\t\tif (handle instanceof Elysia) handle = handle.compile().fetch\n\n\t\tconst handler: Handler<any, any> = async ({ request, path }) =>\n\t\t\t(handle as Function)!(\n\t\t\t\tnew Request(\n\t\t\t\t\treplaceUrlPath(request.url, path.slice(length) || '/'),\n\t\t\t\t\trequest\n\t\t\t\t)\n\t\t\t)\n\n\t\tthis.all(\n\t\t\tpath,\n\t\t\thandler as any,\n\t\t\t{\n\t\t\t\ttype: 'none'\n\t\t\t} as any\n\t\t)\n\n\t\tthis.all(\n\t\t\tpath + (path.endsWith('/') ? '*' : '/*'),\n\t\t\thandler as any,\n\t\t\t{\n\t\t\t\ttype: 'none'\n\t\t\t} as any\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### get\n\t * Register handler for path with method [GET]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .get('/', () => 'hi')\n\t *     .get('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tget<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tget: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('GET', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### post\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .post('/', () => 'hi')\n\t *     .post('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tpost<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tpost: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('POST', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### put\n\t * Register handler for path with method [PUT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .put('/', () => 'hi')\n\t *     .put('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tput<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tput: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('PUT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### patch\n\t * Register handler for path with method [PATCH]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .patch('/', () => 'hi')\n\t *     .patch('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tpatch<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tpatch: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('PATCH', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### delete\n\t * Register handler for path with method [DELETE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .delete('/', () => 'hi')\n\t *     .delete('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tdelete<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tdelete: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('DELETE', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### options\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .options('/', () => 'hi')\n\t *     .options('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\toptions<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('OPTIONS', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### all\n\t * Register handler for path with method [ALL]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .all('/', () => 'hi')\n\t *     .all('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tall<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\t[method in string]: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('ALL', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### head\n\t * Register handler for path with method [HEAD]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .head('/', () => 'hi')\n\t *     .head('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\thead<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\thead: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('HEAD', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### connect\n\t * Register handler for path with method [CONNECT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .connect('/', () => 'hi')\n\t *     .connect('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tconnect<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tconnect: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('CONNECT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### route\n\t * Register handler for path with method [ROUTE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .route('/', () => 'hi')\n\t *     .route('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\troute<\n\t\tconst Method extends HTTPMethod,\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tmethod: Method,\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tJoinPath<BasePath, Path>\n\t\t> & {\n\t\t\tconfig: {\n\t\t\t\tallowMeta?: boolean\n\t\t\t}\n\t\t}\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\t[method in Method]: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<\n\t\t\t\t\t\t\tSchema['response'],\n\t\t\t\t\t\t\tHandle\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add(method.toUpperCase(), path, handler as any, hook, hook?.config)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### ws\n\t * Register handler for path with method [ws]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .ws('/', {\n\t *         message(ws, message) {\n\t *             ws.send(message)\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tws<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['type'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['type']>,\n\t\t\tMetadata['schema']\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\toptions: WS.LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tsubscribe: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: {} extends Schema['response']\n\t\t\t\t\t\t\t? unknown\n\t\t\t\t\t\t\t: Schema['response']\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tconst transform = options.transformMessage\n\t\t\t? Array.isArray(options.transformMessage)\n\t\t\t\t? options.transformMessage\n\t\t\t\t: [options.transformMessage]\n\t\t\t: undefined\n\n\t\tlet server: Server | null = null\n\n\t\tconst validateMessage = getSchemaValidator(options?.body, {\n\t\t\tmodels: this.definitions.type as Record<string, TSchema>,\n\t\t\tnormalize: this.config.normalize\n\t\t})\n\n\t\tconst validateResponse = getSchemaValidator(options?.response as any, {\n\t\t\tmodels: this.definitions.type as Record<string, TSchema>,\n\t\t\tnormalize: this.config.normalize\n\t\t})\n\n\t\tconst parseMessage = (message: any) => {\n\t\t\tif (typeof message === 'string') {\n\t\t\t\tconst start = message?.charCodeAt(0)\n\n\t\t\t\tif (start === 47 || start === 123)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmessage = JSON.parse(message)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Not empty\n\t\t\t\t\t}\n\t\t\t\telse if (isNumericString(message)) message = +message\n\t\t\t}\n\n\t\t\tif (transform?.length)\n\t\t\t\tfor (let i = 0; i < transform.length; i++) {\n\t\t\t\t\tconst temp = transform[i](message)\n\n\t\t\t\t\tif (temp !== undefined) message = temp\n\t\t\t\t}\n\n\t\t\treturn message\n\t\t}\n\n\t\tthis.route(\n\t\t\t'$INTERNALWS',\n\t\t\tpath as any,\n\t\t\t// @ts-expect-error\n\t\t\t(context) => {\n\t\t\t\t// ! Enable static code analysis just in case resolveUnknownFunction doesn't work, do not remove\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\tconst { set, path, qi, headers, query, params } = context\n\n\t\t\t\tif (server === null) server = this.getServer()\n\n\t\t\t\tif (\n\t\t\t\t\tserver?.upgrade<any>(context.request, {\n\t\t\t\t\t\theaders: (typeof options.upgrade === 'function'\n\t\t\t\t\t\t\t? options.upgrade(context as any as Context)\n\t\t\t\t\t\t\t: options.upgrade) as Bun.HeadersInit,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tvalidator: validateResponse,\n\t\t\t\t\t\t\topen(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\toptions.open?.(new ElysiaWS(ws, context as any))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: (ws: ServerWebSocket<any>, msg: any) => {\n\t\t\t\t\t\t\t\tconst message = parseMessage(msg)\n\n\t\t\t\t\t\t\t\tif (validateMessage?.Check(message) === false)\n\t\t\t\t\t\t\t\t\treturn void ws.send(\n\t\t\t\t\t\t\t\t\t\tnew ValidationError(\n\t\t\t\t\t\t\t\t\t\t\t'message',\n\t\t\t\t\t\t\t\t\t\t\tvalidateMessage,\n\t\t\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t\t\t).message as string\n\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\toptions.message?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any),\n\t\t\t\t\t\t\t\t\tmessage as any\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdrain(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\toptions.drain?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclose(\n\t\t\t\t\t\t\t\tws: ServerWebSocket<any>,\n\t\t\t\t\t\t\t\tcode: number,\n\t\t\t\t\t\t\t\treason: string\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toptions.close?.(\n\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any),\n\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\treason\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\t\treturn\n\n\t\t\t\tset.status = 400\n\n\t\t\t\treturn 'Expected a websocket connection'\n\t\t\t},\n\t\t\t{\n\t\t\t\tbeforeHandle: options.beforeHandle,\n\t\t\t\ttransform: options.transform,\n\t\t\t\theaders: options.headers,\n\t\t\t\tparams: options.params,\n\t\t\t\tquery: options.query\n\t\t\t} as any\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<const Name extends string | number | symbol, Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Reconcile<\n\t\t\t\tSingleton['store'],\n\t\t\t\t{\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<Store extends Record<string, unknown>>(\n\t\tstore: Store\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Reconcile<Singleton['store'], Store>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<\n\t\tconst Type extends ContextAppendType,\n\t\tconst Name extends string | number | symbol,\n\t\tValue\n\t>(\n\t\toptions: { as: Type },\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Reconcile<\n\t\t\t\tSingleton['store'],\n\t\t\t\t{\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t},\n\t\t\t\tType extends 'override' ? true : false\n\t\t\t>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<\n\t\tconst Type extends ContextAppendType,\n\t\tStore extends Record<string, unknown>\n\t>(\n\t\toptions: { as: Type },\n\t\tstore: Store\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Reconcile<\n\t\t\t\tSingleton['store'],\n\t\t\t\tStore,\n\t\t\t\tType extends 'override' ? true : false\n\t\t\t>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tstate<NewStore extends Record<string, unknown>>(\n\t\tmapper: (decorators: Singleton['store']) => NewStore\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: NewStore\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate(\n\t\toptions:\n\t\t\t| { as: ContextAppendType }\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function,\n\t\tname?:\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function\n\t\t\t| { as: ContextAppendType },\n\t\tvalue?: unknown\n\t) {\n\t\tif (name === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ name: value })\n\t\t\t */\n\t\t\tvalue = options\n\t\t\toptions = { as: 'append' }\n\t\t\tname = ''\n\t\t} else if (value === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ as: 'override' }, { name: value })\n\t\t\t * - decorate('name', value)\n\t\t\t */\n\n\t\t\t// decorate('name', value)\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tvalue = name\n\t\t\t\tname = options\n\t\t\t\toptions = { as: 'append' }\n\t\t\t} else if (typeof options === 'object') {\n\t\t\t\t// decorate({ as: 'override' }, { name: value })\n\t\t\t\tvalue = name\n\t\t\t\tname = ''\n\t\t\t}\n\t\t}\n\n\t\tconst { as } = options as { as: ContextAppendType }\n\n\t\tif (typeof name !== 'string') return this\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (name in this.singleton.store)\n\t\t\t\t\t\tthis.singleton.store[name] = mergeDeep(\n\t\t\t\t\t\t\tthis.singleton.store[name] as any,\n\t\t\t\t\t\t\tvalue!,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.singleton.store[name] = value\n\n\t\t\t\t\treturn this\n\t\t\t\t}\n\n\t\t\t\tif (value === null) return this\n\n\t\t\t\tthis.singleton.store = mergeDeep(this.singleton.store, value, {\n\t\t\t\t\toverride: as === 'override'\n\t\t\t\t})\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (as === 'override' || !(name in this.singleton.store))\n\t\t\t\t\t\tthis.singleton.store[name] = value\n\t\t\t\t} else this.singleton.store = value(this.singleton.store)\n\n\t\t\t\treturn this as any\n\n\t\t\tdefault:\n\t\t\t\tif (as === 'override' || !(name in this.singleton.store))\n\t\t\t\t\tthis.singleton.store[name] = value\n\n\t\t\t\treturn this\n\t\t}\n\t}\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const Name extends string, const Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Reconcile<\n\t\t\t\tSingleton['decorator'],\n\t\t\t\t{\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const NewDecorators extends Record<string, unknown>>(\n\t\tdecorators: NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Reconcile<Singleton['decorator'], NewDecorators>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tdecorate<const NewDecorators extends Record<string, unknown>>(\n\t\tmapper: (decorators: Singleton['decorator']) => NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: NewDecorators\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate({ as: 'override' }, 'getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<\n\t\tconst Type extends ContextAppendType,\n\t\tconst Name extends string,\n\t\tconst Value\n\t>(\n\t\toptions: { as: Type },\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Reconcile<\n\t\t\t\tSingleton['decorator'],\n\t\t\t\t{\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t},\n\t\t\t\tType extends 'override' ? true : false\n\t\t\t>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<\n\t\tconst Type extends ContextAppendType,\n\t\tconst NewDecorators extends Record<string, unknown>\n\t>(\n\t\toptions: { as: Type },\n\t\tdecorators: NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Reconcile<\n\t\t\t\tSingleton['decorator'],\n\t\t\t\tNewDecorators,\n\t\t\t\tType extends 'override' ? true : false\n\t\t\t>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate(\n\t\toptions:\n\t\t\t| { as: ContextAppendType }\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function,\n\t\tname?:\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function\n\t\t\t| { as: ContextAppendType },\n\t\tvalue?: unknown\n\t) {\n\t\tif (name === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ name: value })\n\t\t\t */\n\t\t\tvalue = options\n\t\t\toptions = { as: 'append' }\n\t\t\tname = ''\n\t\t} else if (value === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ as: 'override' }, { name: value })\n\t\t\t * - decorate('name', value)\n\t\t\t */\n\n\t\t\t// decorate('name', value)\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tvalue = name\n\t\t\t\tname = options\n\t\t\t\toptions = { as: 'append' }\n\t\t\t} else if (typeof options === 'object') {\n\t\t\t\t// decorate({ as: 'override' }, { name: value })\n\t\t\t\tvalue = name\n\t\t\t\tname = ''\n\t\t\t}\n\t\t}\n\n\t\tconst { as } = options as { as: ContextAppendType }\n\n\t\tif (typeof name !== 'string') return this\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (name in this.singleton.decorator)\n\t\t\t\t\t\tthis.singleton.decorator[name] = mergeDeep(\n\t\t\t\t\t\t\tthis.singleton.decorator[name] as any,\n\t\t\t\t\t\t\tvalue!,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.singleton.decorator[name] = value\n\n\t\t\t\t\treturn this\n\t\t\t\t}\n\n\t\t\t\tif (value === null) return this\n\n\t\t\t\tthis.singleton.decorator = mergeDeep(\n\t\t\t\t\tthis.singleton.decorator,\n\t\t\t\t\tvalue,\n\t\t\t\t\t{\n\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tas === 'override' ||\n\t\t\t\t\t\t!(name in this.singleton.decorator)\n\t\t\t\t\t)\n\t\t\t\t\t\tthis.singleton.decorator[name] = value\n\t\t\t\t} else\n\t\t\t\t\tthis.singleton.decorator = value(this.singleton.decorator)\n\n\t\t\t\treturn this as any\n\n\t\t\tdefault:\n\t\t\t\tif (as === 'override' || !(name in this.singleton.decorator))\n\t\t\t\t\tthis.singleton.decorator[name] = value\n\n\t\t\t\treturn this\n\t\t}\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<const Derivative extends Record<string, unknown> | void>(\n\t\ttransform: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tSingleton & {\n\t\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Derivative>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Prettify<\n\t\t\t\tVolatile['derive'] & ExcludeElysiaResponse<Derivative>\n\t\t\t>\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<\n\t\tconst Derivative extends Record<string, unknown> | void,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\ttransform: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tSingleton &\n\t\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\tBasePath\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Derivative>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\tSingleton['derive'] & ExcludeElysiaResponse<Derivative>\n\t\t\t\t\t>\n\t\t\t\t\tresolve: Singleton['resolve']\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Derivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tresolve: Ephemeral['resolve']\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\t\tVolatile['derive'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Derivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tresolve: Ephemeral['resolve']\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tderive(\n\t\toptionsOrTransform: { as?: LifeCycleType } | Function,\n\t\ttransform?: Function\n\t) {\n\t\tif (!transform) {\n\t\t\ttransform = optionsOrTransform as any\n\t\t\toptionsOrTransform = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'derive',\n\t\t\tfn: transform!\n\t\t}\n\n\t\treturn this.onTransform(optionsOrTransform as any, hook as any) as any\n\t}\n\n\tmodel<const Name extends string, const Model extends TSchema>(\n\t\tname: Name,\n\t\tmodel: Model\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: Prettify<\n\t\t\t\tDefinitions['type'] & { [name in Name]: Static<Model> }\n\t\t\t>\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel<const Recorder extends Record<string, TSchema>>(\n\t\trecord: Recorder\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: Prettify<\n\t\t\t\tDefinitions['type'] & {\n\t\t\t\t\t[key in keyof Recorder]: Static<Recorder[key]>\n\t\t\t\t}\n\t\t\t>\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel<const NewType extends Record<string, TSchema>>(\n\t\tmapper: (decorators: {\n\t\t\t[type in keyof Definitions['type']]: ReturnType<\n\t\t\t\ttypeof t.Unsafe<Definitions['type'][type]>\n\t\t\t>\n\t\t}) => NewType\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\t{\n\t\t\ttype: { [x in keyof NewType]: Static<NewType[x]> }\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel(name: string | Record<string, TSchema> | Function, model?: TSchema) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tObject.entries(name).forEach(([key, value]) => {\n\t\t\t\t\tif (!(key in this.definitions.type))\n\t\t\t\t\t\tthis.definitions.type[key] = value as TSchema\n\t\t\t\t})\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tthis.definitions.type = name(this.definitions.type)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\t;(this.definitions.type as Record<string, TSchema>)[name] = model!\n\n\t\treturn this as any\n\t}\n\n\tmapDerive<const NewDerivative extends Record<string, unknown>>(\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewDerivative>\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: NewDerivative\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\tmapDerive<\n\t\tconst NewDerivative extends Record<string, unknown>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t}),\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewDerivative>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\tScoped,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tScoped,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tmapDerive(\n\t\toptionsOrDerive: { as?: LifeCycleType } | Function,\n\t\tmapper?: Function\n\t) {\n\t\tif (!mapper) {\n\t\t\tmapper = optionsOrDerive as any\n\t\t\toptionsOrDerive = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'mapDerive',\n\t\t\tfn: mapper!\n\t\t}\n\n\t\treturn this.onTransform(optionsOrDerive as any, hook as any) as any\n\t}\n\n\taffix<\n\t\tconst Base extends 'prefix' | 'suffix',\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(\n\t\tbase: Base,\n\t\ttype: Type,\n\t\tword: Word\n\t): Elysia<\n\t\tBasePath,\n\t\tScoped,\n\t\t{\n\t\t\tdecorator: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['decorator']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['decorator']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['decorator']>\n\t\t\t\t: Singleton['decorator']\n\t\t\tstore: Type extends 'state' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['store']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['store']>\n\t\t\t\t\t: AddSuffix<Word, Singleton['store']>\n\t\t\t\t: Singleton['store']\n\t\t\tderive: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['derive']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['derive']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['derive']>\n\t\t\t\t: Singleton['derive']\n\t\t\tresolve: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['resolve']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['resolve']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['resolve']>\n\t\t\t\t: Singleton['resolve']\n\t\t},\n\t\t{\n\t\t\ttype: Type extends 'model' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['type']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['type']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['type']>\n\t\t\t\t: Definitions['type']\n\t\t\terror: Type extends 'error' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['error']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['error']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['error']>\n\t\t\t\t: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tif (word === '') return this as any\n\n\t\tconst delimieter = ['_', '-', ' ']\n\t\tconst capitalize = (word: string) =>\n\t\t\tword[0].toUpperCase() + word.slice(1)\n\n\t\tconst joinKey =\n\t\t\tbase === 'prefix'\n\t\t\t\t? (prefix: string, word: string) =>\n\t\t\t\t\t\tdelimieter.includes(prefix.at(-1) ?? '')\n\t\t\t\t\t\t\t? prefix + word\n\t\t\t\t\t\t\t: prefix + capitalize(word)\n\t\t\t\t: delimieter.includes(word.at(-1) ?? '')\n\t\t\t\t\t? (suffix: string, word: string) => word + suffix\n\t\t\t\t\t: (suffix: string, word: string) =>\n\t\t\t\t\t\t\tword + capitalize(suffix)\n\n\t\tconst remap = (type: 'decorator' | 'state' | 'model' | 'error') => {\n\t\t\tconst store: Record<string, any> = {}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'decorator':\n\t\t\t\t\tfor (const key in this.singleton.decorator) {\n\t\t\t\t\t\tstore[joinKey(word, key)] =\n\t\t\t\t\t\t\tthis.singleton.decorator[key]\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.singleton.decorator = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'state':\n\t\t\t\t\tfor (const key in this.singleton.store)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.singleton.store[key]\n\n\t\t\t\t\tthis.singleton.store = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'model':\n\t\t\t\t\tfor (const key in this.definitions.type)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.type[key]\n\n\t\t\t\t\tthis.definitions.type = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tfor (const key in this.definitions.error)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.error[key]\n\n\t\t\t\t\tthis.definitions.error = store\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst types = Array.isArray(type) ? type : [type]\n\n\t\tfor (const type of types.some((x) => x === 'all')\n\t\t\t? ['decorator', 'state', 'model', 'error']\n\t\t\t: types)\n\t\t\tremap(type as 'decorator')\n\n\t\treturn this as any\n\t}\n\n\tprefix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('prefix', type, word)\n\t}\n\n\tsuffix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('suffix', type, word)\n\t}\n\n\tcompile() {\n\t\tthis.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this)\n\n\t\tif (typeof this.server?.reload === 'function')\n\t\t\tthis.server.reload({\n\t\t\t\t...(this.server || {}),\n\t\t\t\tfetch: this.fetch\n\t\t\t})\n\n\t\treturn this\n\t}\n\n\thandle = async (request: Request) => this.fetch(request)\n\n\t/**\n\t * Use handle can be either sync or async to save performance.\n\t *\n\t * Beside benchmark purpose, please use 'handle' instead.\n\t */\n\tfetch = (request: Request): MaybePromise<Response> => {\n\t\tif (process.env.NODE_ENV === 'production' && this.config.aot !== false)\n\t\t\tconsole.warn(\n\t\t\t\t\"Performance degradation found. Please call Elysia.compile() before using 'fetch'\"\n\t\t\t)\n\n\t\treturn (this.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this))(request)\n\t}\n\n\tprivate handleError = async (\n\t\tcontext: Partial<\n\t\t\tContext<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t> & {\n\t\t\trequest: Request\n\t\t},\n\t\terror:\n\t\t\t| Error\n\t\t\t| ValidationError\n\t\t\t| ParseError\n\t\t\t| NotFoundError\n\t\t\t| InternalServerError\n\t) =>\n\t\t(this.handleError = this.config.aot\n\t\t\t? composeErrorHandler(this)\n\t\t\t: createDynamicErrorHandler(this))(context, error)\n\n\tprivate outerErrorHandler = (error: Error) =>\n\t\tnew Response(error.message || error.name || 'Error', {\n\t\t\t// @ts-ignore\n\t\t\tstatus: error?.status ?? 500\n\t\t})\n\n\t/**\n\t * ### listen\n\t * Assign current instance to port and start serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t * ```\n\t */\n\tlisten = (\n\t\toptions: string | number | Partial<Serve>,\n\t\tcallback?: ListenCallback\n\t) => {\n\t\tif (typeof Bun === 'undefined')\n\t\t\tthrow new Error(\n\t\t\t\t'.listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch'\n\t\t\t)\n\n\t\tthis.compile()\n\n\t\tif (typeof options === 'string') {\n\t\t\tif (!isNumericString(options))\n\t\t\t\tthrow new Error('Port must be a numeric value')\n\n\t\t\toptions = parseInt(options)\n\t\t}\n\n\t\tconst fetch = this.fetch\n\n\t\tconst serve =\n\t\t\ttypeof options === 'object'\n\t\t\t\t? ({\n\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\treusePort: true,\n\t\t\t\t\t\t...(this.config.serve || {}),\n\t\t\t\t\t\t...(options || {}),\n\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t...(this.config.websocket || {}),\n\t\t\t\t\t\t\t...(websocket || {})\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfetch,\n\t\t\t\t\t\terror: this.outerErrorHandler\n\t\t\t\t\t} as Serve)\n\t\t\t\t: ({\n\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\treusePort: true,\n\t\t\t\t\t\t...(this.config.serve || {}),\n\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t...(this.config.websocket || {}),\n\t\t\t\t\t\t\t...(websocket || {})\n\t\t\t\t\t\t},\n\t\t\t\t\t\tport: options,\n\t\t\t\t\t\tfetch,\n\t\t\t\t\t\terror: this.outerErrorHandler\n\t\t\t\t\t} as Serve)\n\n\t\tthis.server = Bun?.serve(serve)\n\n\t\tfor (let i = 0; i < this.event.start.length; i++)\n\t\t\tthis.event.start[i].fn(this)\n\n\t\tif (callback) callback(this.server!)\n\n\t\tprocess.on('beforeExit', () => {\n\t\t\tif (this.server) {\n\t\t\t\tthis.server.stop()\n\t\t\t\tthis.server = null\n\n\t\t\t\tfor (let i = 0; i < this.event.stop.length; i++)\n\t\t\t\t\tthis.event.stop[i].fn(this)\n\t\t\t}\n\t\t})\n\n\t\tthis.promisedModules.then(() => {\n\t\t\tBun?.gc(false)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### stop\n\t * Stop server from serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const app = new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t *\n\t * // Sometime later\n\t * app.stop()\n\t * ```\n\t */\n\tstop = async () => {\n\t\tif (!this.server)\n\t\t\tthrow new Error(\n\t\t\t\t\"Elysia isn't running. Call `app.listen` to start the server.\"\n\t\t\t)\n\n\t\tif (this.server) {\n\t\t\tthis.server.stop()\n\t\t\tthis.server = null\n\n\t\t\tif (this.event.stop.length)\n\t\t\t\tfor (let i = 0; i < this.event.stop.length; i++)\n\t\t\t\t\tthis.event.stop[i].fn(this)\n\t\t}\n\t}\n\n\t/**\n\t * Wait until all lazy loaded modules all load is fully\n\t */\n\tget modules() {\n\t\treturn Promise.all(this.promisedModules.promises)\n\t}\n}\n\nexport { Elysia }\n\nexport { mapResponse, mapCompactResponse, mapEarlyResponse } from './handler'\nexport { t } from './type-system'\nexport { Cookie, type CookieOptions } from './cookies'\nexport type { Context, PreContext, ErrorContext } from './context'\nexport {\n\tELYSIA_TRACE,\n\ttype TraceEvent,\n\ttype TraceListener,\n\ttype TraceHandler,\n\ttype TraceProcess,\n\ttype TraceStream\n} from './trace'\n\nexport {\n\tgetSchemaValidator,\n\tmergeHook,\n\tmergeObjectArray,\n\tgetResponseSchemaValidator,\n\tredirect,\n\tStatusMap,\n\tInvertedStatusMap,\n\tform,\n\treplaceSchemaType,\n\treplaceUrlPath,\n\tchecksum,\n\tcloneInference,\n\tdeduplicateChecksum,\n\tELYSIA_FORM_DATA,\n\tELYSIA_REQUEST_ID\n} from './utils'\n\nexport {\n\terror,\n\tmapValueError,\n\tParseError,\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tInvalidCookieSignature,\n\tERROR_CODE,\n\tELYSIA_RESPONSE\n} from './error'\n\nexport type {\n\tEphemeralType,\n\tCreateEden,\n\tComposeElysiaResponse,\n\tElysiaConfig,\n\tSingletonBase,\n\tDefinitionBase,\n\tRouteBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tVoidHandler,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tAfterResponseHandler,\n\tErrorHandler,\n\tAfterHandler,\n\tLifeCycleEvent,\n\tLifeCycleStore,\n\tLifeCycleType,\n\tMaybePromise,\n\tListenCallback,\n\tUnwrapSchema,\n\tChecksum,\n\tDocumentDecoration,\n\tInferContext,\n\tInferHandler,\n\tResolvePath,\n\tMapResponse,\n\tMacroQueue,\n\tBaseMacro,\n\tMacroManager,\n\tBaseMacroFn,\n\tMacroToProperty,\n\tResolveMacroContext,\n\tMergeElysiaInstances,\n\tMaybeArray,\n\tModelValidator,\n\tMetadataBase,\n\tUnwrapBodySchema,\n\tUnwrapGroupGuardRoute,\n\tModelValidatorError,\n\tExcludeElysiaResponse,\n\tCoExist\n} from './types'\n\nexport type { Static, TSchema } from '@sinclair/typebox'\n"
  ],
  "mappings": ";wZAwCA,IAAS,WAAmB,CAAC,EAAK,CAChC,IAAI,EAAkB,EAAI,QAAQ,GAAG,EACrC,GAAI,IAAoB,GAAI,OAAO,EAEnC,IAAI,EAAS,EAAI,OACb,EAAU,GACV,EAAO,EACP,EAAY,EACZ,EAAgB,EAChB,EAAQ,GAEZ,MAAO,EAAkB,IAAM,EAAkB,EAAQ,CACvD,IAAI,EAAO,GAAa,EAAI,EAAkB,GAAI,CAAC,EAC/C,EAAM,GAAa,EAAI,EAAkB,GAAI,CAAC,EAC9C,EAAO,EAAO,EACd,EAAO,GAAU,GAIrB,GAHA,EAAQ,GAAU,IAAM,EAAQ,GAChC,EAAa,GAAa,EAAM,EAAO,GAAU,IAAM,GAEnD,IAAU,GACZ,GAAW,EAAI,MAAM,EAAM,CAAa,EAExC,GAAY,GAAa,MACrB,OAAO,aAAa,CAAS,EAC7B,OAAO,aACN,OAAU,GAAa,IACvB,OAAU,EAAY,KACzB,EAEF,EAAY,EACZ,EAAO,EAAkB,EACzB,EAAkB,EAAgB,EAAI,QAAQ,IAAK,CAAI,UAC9C,IAAU,GACnB,OAAO,SACF,CAEL,GADA,GAAmB,EACf,EAAkB,GAAU,EAAI,WAAW,CAAe,IAAM,GAAI,SACxE,OAAO,MAIX,OAAO,EAAU,EAAI,MAAM,CAAI,GA4BxB,WAAa,CAAC,EAAG,EAAO,CAC/B,IAAI,EAAI,GAAI,GACZ,OAAO,IAAM,OAAY,IAAM,GAAK,GA7GlC,GAAc,GACd,GAAc,EACd,GAAY,CAEd,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAI/C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACjC,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GACxC,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACpC,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAClC,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACpC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",
  "debugId": "343A34477716BDA564756E2164756E21",
  "names": []
}