// @bun
var I2=Object.create;var{defineProperty:E1,getPrototypeOf:V2,getOwnPropertyNames:O2}=Object;var A2=Object.prototype.hasOwnProperty;var Y1=($,X,Z)=>{Z=$!=null?I2(V2($)):{};const W=X||!$||!$.__esModule?E1(Z,"default",{value:$,enumerable:!0}):Z;for(let J of O2($))if(!A2.call(W,J))E1(W,J,{get:()=>$[J],enumerable:!0});return W};var C2=($,X)=>()=>(X||$((X={exports:{}}).exports,X),X.exports);var s0=C2((e3,t1)=>{var Q3=function($){var X=$.indexOf("%");if(X===-1)return $;var Z=$.length,W="",J=0,j=0,G=X,Y=i1;while(X>-1&&X<Z){var K=n1($[X+1],4),B=n1($[X+2],0),U=K|B,w=F1[U];if(Y=F1[256+Y+w],j=j<<6|U&F1[364+w],Y===i1)W+=$.slice(J,G),W+=j<=65535?String.fromCharCode(j):String.fromCharCode(55232+(j>>10),56320+(j&1023)),j=0,J=X+3,X=G=$.indexOf("%",J);else if(Y===j3)return null;else{if(X+=3,X<Z&&$.charCodeAt(X)===37)continue;return null}}return W+$.slice(J)},n1=function($,X){var Z=G3[$];return Z===void 0?255:Z<<X},i1=12,j3=0,F1=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,7,7,7,7,7,7,7,7,7,7,7,7,8,7,7,10,9,9,9,11,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,24,36,48,60,72,84,96,0,12,12,12,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,24,24,24,0,0,0,0,0,0,0,0,0,24,24,0,0,0,0,0,0,0,0,0,0,48,48,48,0,0,0,0,0,0,0,0,0,0,48,48,0,0,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,127,63,63,63,0,31,15,15,15,7,7,7],G3={"0":0,"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,a:10,A:10,b:11,B:11,c:12,C:12,d:13,D:13,e:14,E:14,f:15,F:15};t1.exports=Q3});var S0=($,X)=>{const Z=X?.length?{}:null;if(Z)for(let W of X)Z[W.part.charCodeAt(0)]=W;return{part:$,store:null,inert:Z,params:null,wildcardStore:null}},R1=($,X)=>({...$,part:X}),b1=($)=>({name:$,store:null,inert:null});class w0{root={};history=[];static regex={static:/:.+?(?=\/|$)/,params:/:.+?(?=\/|$)/g,optionalParams:/:.+?\?(?=\/|$)/g};add($,X,Z,{ignoreError:W=!1,ignoreHistory:J=!1}={}){if(typeof X!=="string")throw new TypeError("Route path must be a string");if(X==="")X="/";else if(X[0]!=="/")X=`/${X}`;const j=X[X.length-1]==="*",G=X.match(w0.regex.optionalParams);if(G){const w=X.replaceAll("?","");this.add($,w,Z,{ignoreError:W});for(let D=0;D<G.length;D++){let Q=X.replace("/"+G[D],"");this.add($,Q,Z,{ignoreError:!0})}return Z}if(G)X=X.replaceAll("?","");if(this.history.find(([w,D,Q])=>w===$&&D===X))return Z;if(j||G&&X.charCodeAt(X.length-1)===63)X=X.slice(0,-1);if(!J)this.history.push([$,X,Z]);const Y=X.split(w0.regex.static),K=X.match(w0.regex.params)||[];if(Y[Y.length-1]==="")Y.pop();let B;if(!this.root[$])B=this.root[$]=S0("/");else B=this.root[$];let U=0;for(let w=0;w<Y.length;++w){let D=Y[w];if(w>0){const Q=K[U++].slice(1);if(B.params===null)B.params=b1(Q);else if(B.params.name!==Q)if(W)return Z;else throw new Error(`Cannot create route "${X}" with parameter "${Q}" because a route already exists with a different parameter name ("${B.params.name}") in the same location`);const _=B.params;if(_.inert===null){B=_.inert=S0(D);continue}B=_.inert}for(let Q=0;;){if(Q===D.length){if(Q<B.part.length){const _=R1(B,B.part.slice(Q));Object.assign(B,S0(D,[_]))}break}if(Q===B.part.length){if(B.inert===null)B.inert={};const _=B.inert[D.charCodeAt(Q)];if(_){B=_,D=D.slice(Q),Q=0;continue}const P=S0(D.slice(Q));B.inert[D.charCodeAt(Q)]=P,B=P;break}if(D[Q]!==B.part[Q]){const _=R1(B,B.part.slice(Q)),P=S0(D.slice(Q));Object.assign(B,S0(B.part.slice(0,Q),[_,P])),B=P;break}++Q}}if(U<K.length){const w=K[U].slice(1);if(B.params===null)B.params=b1(w);else if(B.params.name!==w)if(W)return Z;else throw new Error(`Cannot create route "${X}" with parameter "${w}" because a route already exists with a different parameter name ("${B.params.name}") in the same location`);if(B.params.store===null)B.params.store=Z;return B.params.store}if(j){if(B.wildcardStore===null)B.wildcardStore=Z;return B.wildcardStore}if(B.store===null)B.store=Z;return B.store}find($,X){const Z=this.root[$];if(!Z)return null;return B1(X,X.length,Z,0)}}var B1=($,X,Z,W)=>{const J=Z.part,j=J.length,G=W+j;if(j>1){if(G>X)return null;if(j<15){for(let Y=1,K=W+1;Y<j;++Y,++K)if(J.charCodeAt(Y)!==$.charCodeAt(K))return null}else if($.slice(W,G)!==J)return null}if(G===X){if(Z.store!==null)return{store:Z.store,params:{}};if(Z.wildcardStore!==null)return{store:Z.wildcardStore,params:{"*":""}};return null}if(Z.inert!==null){const Y=Z.inert[$.charCodeAt(G)];if(Y!==void 0){const K=B1($,X,Y,G);if(K!==null)return K}}if(Z.params!==null){const{store:Y,name:K,inert:B}=Z.params,U=$.indexOf("/",G);if(U!==G){if(U===-1||U>=X){if(Y!==null){const w={};return w[K]=$.substring(G,X),{store:Y,params:w}}}else if(B!==null){const w=B1($,X,B,U);if(w!==null)return w.params[K]=$.substring(G,U),w}}}if(Z.wildcardStore!==null)return{store:Z.wildcardStore,params:{"*":$.substring(G,X)}};return null};var q0=($)=>{const X=typeof $==="object"?$.fn.toString():typeof $==="string"?$.toString():$,Z=X.indexOf(")");if(X.charCodeAt(Z+2)===61&&X.charCodeAt(Z+5)!==123)return!0;return X.includes("return")},S2=($)=>{if($.startsWith("async"))$=$.slice(6);let X=-1;if($.charCodeAt(0)===40){if(X=$.indexOf("=>",$.indexOf(")")),X!==-1){let J=X;while(J>0)if($.charCodeAt(--J)===41)break;let j=$.slice(X+2);if(j.charCodeAt(0)===32)j=j.trimLeft();return[$.slice(1,J),j,{isArrowReturn:j.charCodeAt(0)!==123}]}}if($.startsWith("function")){X=$.indexOf("(");const J=$.indexOf(")");return[$.slice(X+1,J),$.slice(J+2),{isArrowReturn:!1}]}const Z=$.indexOf("(");if(Z!==-1){const J=$.indexOf("\n",2),j=$.slice(0,J),G=j.lastIndexOf(")")+1,Y=$.slice(J+1);return[j.slice(Z,G),"{"+Y,{isArrowReturn:!1}]}const W=$.split("\n",2);return[W[0],W[1],{isArrowReturn:!1}]},q2=($)=>{const X=$.indexOf("{");if(X===-1)return[-1,0];let Z=X+1,W=1;for(;Z<$.length;Z++){const J=$.charCodeAt(Z);if(J===123)W++;else if(J===125)W--;if(W===0)break}if(W!==0)return[0,$.length];return[X,Z+1]},L2=($)=>{const X=$.lastIndexOf("}");if(X===-1)return[-1,0];let Z=X-1,W=1;for(;Z>=0;Z--){const J=$.charCodeAt(Z);if(J===125)W++;else if(J===123)W--;if(W===0)break}if(W!==0)return[-1,0];return[Z,X+1]},x1=($)=>{while(!0){const X=$.indexOf(":");if(X===-1)break;let Z=$.indexOf(",",X);if(Z===-1)Z=$.indexOf("}",X)-1;if(Z===0)Z=$.length;$=$.slice(0,X)+$.slice(Z)}return $},g1=($)=>{let X=!1;if($.charCodeAt(0)===40)$=$.slice(1,-1);if($.charCodeAt(0)===123)X=!0,$=$.slice(1,-1);$=$.replace(/( |\t|\n)/g,"").trim();let Z=[];while(!0){let[W,J]=q2($);if(W===-1)break;if(Z.push($.slice(0,W-1)),$.charCodeAt(J)===44)J++;$=$.slice(J)}if($=x1($),$)Z=Z.concat($.split(","));return{hasParenthesis:X,parameters:Z}},T2=($,X)=>{const{parameters:Z,hasParenthesis:W}=g1($);if(!X.query&&Z.includes("query"))X.query=!0;if(!X.headers&&Z.includes("headers"))X.headers=!0;if(!X.body&&Z.includes("body"))X.body=!0;if(!X.cookie&&Z.includes("cookie"))X.cookie=!0;if(!X.set&&Z.includes("set"))X.set=!0;if(!X.server&&Z.includes("server"))X.server=!0;if(W)return`{ ${Z.join(", ")} }`;return Z.join(", ")},H2=($,X,Z)=>{const W=X.indexOf($+"\n",Z),J=X.indexOf($+"\t",Z),j=X.indexOf($+",",Z),G=X.indexOf($+";",Z),Y=X.indexOf($+" ",Z);return[W,J,j,G,Y].filter((K)=>K>0).sort((K,B)=>K-B)[0]||-1};var f1=($,X,Z=0)=>{if(Z>5)return[];const W=[];let J=X;while(!0){let j=H2(" = "+$,J);if(j===-1){const K=J.indexOf(" = "+$);if(K+3+$.length!==J.length)break;j=K}const G=J.slice(0,j);let Y=G.slice(G.lastIndexOf(" ")+1);if(Y==="}"){const[K,B]=L2(G);W.push(x1(J.slice(K,B))),J=J.slice(j+3+$.length);continue}while(Y.charCodeAt(0)===44)Y=Y.slice(1);while(Y.charCodeAt(0)===9)Y=Y.slice(1);if(!Y.includes("("))W.push(Y);J=J.slice(j+3+$.length)}for(let j of W){if(j.charCodeAt(0)===123)continue;const G=f1(j,X);if(G.length>0)W.push(...G)}return W},E2=($)=>{if(!$)return;if($.charCodeAt(0)!==123)return $;if($=$.slice(2,-2),!$.includes(",")){if($.includes("..."))return $.slice($.indexOf("...")+3);return}const Z=$.indexOf("...");if(Z===-1)return;return $.slice(Z+3).trimEnd()},R2=($,X,Z)=>{const W=(J,j)=>$.includes(j+"."+J)||$.includes(j+'["'+J+'"]')||$.includes(j+"['"+J+"']");for(let J of X){if(!J)continue;if(J.charCodeAt(0)===123){const j=g1(J).parameters;if(!Z.query&&j.includes("query"))Z.query=!0;if(!Z.headers&&j.includes("headers"))Z.headers=!0;if(!Z.body&&j.includes("body"))Z.body=!0;if(!Z.cookie&&j.includes("cookie"))Z.cookie=!0;if(!Z.set&&j.includes("set"))Z.set=!0;if(!Z.query&&j.includes("server"))Z.server=!0;continue}if(!Z.query&&W("query",J))Z.query=!0;if($.includes("return "+J)||$.includes("return "+J+".query"))Z.query=!0;if(!Z.headers&&W("headers",J))Z.headers=!0;if(!Z.body&&W("body",J))Z.body=!0;if(!Z.cookie&&W("cookie",J))Z.cookie=!0;if(!Z.set&&W("set",J))Z.set=!0;if(!Z.server&&W("server",J))Z.server=!0;if(Z.query&&Z.headers&&Z.body&&Z.cookie&&Z.set&&Z.server)break}return X};var b2=($,X,Z)=>{try{const W=new RegExp(`(?:\\w)\\((?:.*)?${$}`,"gs");W.test(X);const J=X.charCodeAt(W.lastIndex);if(J===41||J===44)return Z.query=!0,Z.headers=!0,Z.body=!0,Z.cookie=!0,Z.set=!0,Z.server=!0,!0;return!1}catch(W){return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to the developer:"),console.log("--- body ---"),console.log(X),console.log("--- context ---"),console.log($),!0}},i0=($,X={query:!1,headers:!1,body:!1,cookie:!1,set:!1,server:!1})=>{const Z=[];if($.handler&&typeof $.handler==="function")Z.push($.handler);if($.request?.length)Z.push(...$.request);if($.beforeHandle?.length)Z.push(...$.beforeHandle);if($.parse?.length)Z.push(...$.parse);if($.error?.length)Z.push(...$.error);if($.transform?.length)Z.push(...$.transform);if($.afterHandle?.length)Z.push(...$.afterHandle);if($.mapResponse?.length)Z.push(...$.mapResponse);if($.afterResponse?.length)Z.push(...$.afterResponse);for(let W of Z){if(!W)continue;const J="fn"in W?W.fn:W,[j,G,{isArrowReturn:Y}]=S2(J.toString()),K=T2(j,X),B=E2(K);if(B){const U=f1(B,G);if(U.splice(0,-1,B),!b2(B,G,X))R2(G,U,X);if(!X.query&&G.includes("return "+B+".query"))X.query=!0}if(X.query&&X.headers&&X.body&&X.cookie&&X.set&&X.server)break}return X};import{Value as m0} from"@sinclair/typebox/value";import{Kind as T0,TransformKind as $2} from"@sinclair/typebox";import{Value as F0} from"@sinclair/typebox/value";import{TypeCompiler as Z2} from"@sinclair/typebox/compiler";import{TypeRegistry as d1} from"@sinclair/typebox";import{TypeSystem as L0} from"@sinclair/typebox/system";import{Type as f0,FormatRegistry as o} from"@sinclair/typebox";import{TypeCompiler as h1} from"@sinclair/typebox/compiler";import{Value as a} from"@sinclair/typebox/value";var x2=function($){return $%4===0&&($%100!==0||$%400===0)},u1=function($){const X=g2.exec($);if(!X)return!1;const Z=+X[1],W=+X[2],J=+X[3];return W>=1&&W<=12&&J>=1&&J<=(W===2&&x2(Z)?29:f2[W])},K1=function($){return function X(Z){const W=y2.exec(Z);if(!W)return!1;const J=+W[1],j=+W[2],G=+W[3],Y=W[4],K=W[5]==="-"?-1:1,B=+(W[6]||0),U=+(W[7]||0);if(B>23||U>59||$&&!Y)return!1;if(J<=23&&j<=59&&G<60)return!0;const w=j-U*K,D=J-B*K-(w<0?1:0);return(D===23||D===-1)&&(w===59||w===-1)&&G<61}},y1=function($){const X=K1($);return function Z(W){const J=W.split(v2);return J.length===2&&u1(J[0])&&X(J[1])}},h2=function($){return k2.test($)&&u2.test($)},m2=function($){return v1.lastIndex=0,v1.test($)},l2=function($){return Number.isInteger($)&&$<=c2&&$>=d2},p2=function($){return Number.isInteger($)},k1=function(){return!0},n2=function($){if(i2.test($))return!1;try{return new RegExp($),!0}catch(X){return!1}},n0={date:u1,time:K1(!0),"date-time":y1(!0),"iso-time":K1(!1),"iso-date-time":y1(!1),duration:/^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,uri:h2,"uri-reference":/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-template":/^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,url:/^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,email:/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,hostname:/^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,ipv6:/^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,regex:n2,uuid:/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,"json-pointer":/^(?:\/(?:[^~/]|~0|~1)*)*$/,"json-pointer-uri-fragment":/^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,"relative-json-pointer":/^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,byte:m2,int32:{type:"number",validate:l2},int64:{type:"number",validate:p2},float:{type:"number",validate:k1},double:{type:"number",validate:k1},password:!0,binary:!0},g2=/^(\d\d\d\d)-(\d\d)-(\d\d)$/,f2=[0,31,28,31,30,31,30,31,31,30,31,30,31],y2=/^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i,v2=/t|\s/i,k2=/\/|:/,u2=/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,v1=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm,d2=-2147483648,c2=2147483647,i2=/[^\\]\\Z/;import{TypeSystemPolicy as p3,TypeSystem as i3,TypeSystemDuplicateFormat as n3,TypeSystemDuplicateTypeKind as t3} from"@sinclair/typebox/system";import{TypeCompiler as r3,TypeCheck as a3} from"@sinclair/typebox/compiler";var c1=/(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/,l1=/(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/,p1=/^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/,t2=n0.date,s2=n0["date-time"];if(!o.Has("date"))L0.Format("date",($)=>{const X=$.replace(/"/g,"");if(c1.test(X)||l1.test(X)||p1.test(X)||t2(X)){const Z=new Date(X);if(!Number.isNaN(Z.getTime()))return!0}return!1});if(!o.Has("date-time"))L0.Format("date-time",($)=>{const X=$.replace(/"/g,"");if(c1.test(X)||l1.test(X)||p1.test(X)||s2(X)){const Z=new Date(X);if(!Number.isNaN(Z.getTime()))return!0}return!1});Object.entries(n0).forEach(($)=>{const[X,Z]=$;if(!o.Has(X)){if(Z instanceof RegExp)L0.Format(X,(W)=>Z.test(W));else if(typeof Z==="function")L0.Format(X,Z)}});var A=Object.assign({},f0),m1=($)=>{if(typeof $==="string")switch($.slice(-1)){case"k":return+$.slice(0,$.length-1)*1024;case"m":return+$.slice(0,$.length-1)*1048576;default:return+$}return $},U1=($,X)=>{if(!(X instanceof Blob))return!1;if($.minSize&&X.size<m1($.minSize))return!1;if($.maxSize&&X.size>m1($.maxSize))return!1;if($.extension)if(typeof $.extension==="string"){if(!X.type.startsWith($.extension))return!1}else{for(let Z=0;Z<$.extension.length;Z++)if(X.type.startsWith($.extension[Z]))return!0;return!1}return!0},r2=d1.Get("Files")??L0.Type("File",U1),a2=d1.Get("Files")??L0.Type("Files",($,X)=>{if(!Array.isArray(X))return U1($,X);if($.minItems&&X.length<$.minItems)return!1;if($.maxItems&&X.length>$.maxItems)return!1;for(let Z=0;Z<X.length;Z++)if(!U1($,X[Z]))return!1;return!0});if(!o.Has("numeric"))o.Set("numeric",($)=>!!$&&!isNaN(+$));if(!o.Has("boolean"))o.Set("boolean",($)=>$==="true"||$==="false");if(!o.Has("ObjectString"))o.Set("ObjectString",($)=>{let X=$.charCodeAt(0);if(X===9||X===10||X===32)X=$.trimStart().charCodeAt(0);if(X!==123&&X!==91)return!1;try{return JSON.parse($),!0}catch{return!1}});if(!o.Has("ArrayString"))o.Set("ArrayString",($)=>{let X=$.charCodeAt(0);if(X===9||X===10||X===32)X=$.trimStart().charCodeAt(0);if(X!==123&&X!==91)return!1;try{return JSON.parse($),!0}catch{return!1}});var j0={Numeric:($)=>{const X=f0.Number($);return A.Transform(A.Union([A.String({format:"numeric",default:0}),A.Number($)],$)).Decode((Z)=>{const W=+Z;if(isNaN(W))return Z;if($&&!a.Check(X,W))throw new H("property",X,W);return W}).Encode((Z)=>Z)},Date:($)=>{const X=f0.Date($);return A.Transform(A.Union([f0.Date($),A.String({format:"date",default:(new Date()).toISOString()}),A.String({format:"date-time",default:(new Date()).toISOString()})],$)).Decode((Z)=>{if(Z instanceof Date)return Z;const W=new Date(Z);if(!a.Check(X,W))throw new H("property",X,W);return W}).Encode((Z)=>{if(typeof Z==="string")return new Date(Z);return Z})},BooleanString:($)=>{const X=f0.Boolean($);return A.Transform(A.Union([A.String({format:"boolean",default:!1}),A.Boolean($)],$)).Decode((Z)=>{if(typeof Z==="string")return Z==="true";if($&&!a.Check(X,Z))throw new H("property",X,Z);return Z}).Encode((Z)=>Z)},ObjectString:($,X)=>{const Z=A.Object($,X),W=JSON.stringify(a.Create(Z));let J;try{J=h1.Compile(Z)}catch{}return A.Transform(A.Union([A.String({format:"ObjectString",default:W}),Z])).Decode((j)=>{if(typeof j==="string"){if(j.charCodeAt(0)!==123)throw new H("property",Z,j);try{j=JSON.parse(j)}catch{throw new H("property",Z,j)}if(J){if(!J.Check(j))throw new H("property",Z,j);return J.Decode(j)}if(!a.Check(Z,j))throw new H("property",Z,j);return a.Decode(Z,j)}return j}).Encode((j)=>{if(typeof j==="string")try{j=JSON.parse(j)}catch{throw new H("property",Z,j)}if(!a.Check(Z,j))throw new H("property",Z,j);return JSON.stringify(j)})},ArrayString:($={},X)=>{const Z=A.Array($,X),W=JSON.stringify(a.Create(Z));let J;try{J=h1.Compile(Z)}catch{}return A.Transform(A.Union([A.String({format:"ArrayString",default:W}),Z])).Decode((j)=>{if(typeof j==="string"){if(j.charCodeAt(0)!==91)throw new H("property",Z,j);try{j=JSON.parse(j)}catch{throw new H("property",Z,j)}if(J){if(!J.Check(j))throw new H("property",Z,j);return J.Decode(j)}if(!a.Check(Z,j))throw new H("property",Z,j);return a.Decode(Z,j)}return j}).Encode((j)=>{if(typeof j==="string")try{j=JSON.parse(j)}catch{throw new H("property",Z,j)}if(!a.Check(Z,j))throw new H("property",Z,j);return JSON.stringify(j)})},File:r2,Files:($={})=>A.Transform(a2($)).Decode((X)=>{if(Array.isArray(X))return X;return[X]}).Encode((X)=>X),Nullable:($)=>A.Union([$,A.Null()]),MaybeEmpty:($)=>A.Union([$,A.Null(),A.Undefined()]),Cookie:($,{domain:X,expires:Z,httpOnly:W,maxAge:J,path:j,priority:G,sameSite:Y,secure:K,secrets:B,sign:U,...w}={})=>{const D=A.Object($,w);return D.config={domain:X,expires:Z,httpOnly:W,maxAge:J,path:j,priority:G,sameSite:Y,secure:K,secrets:B,sign:U},D}};A.BooleanString=j0.BooleanString;A.ObjectString=j0.ObjectString;A.ArrayString=j0.ArrayString;A.Numeric=j0.Numeric;A.File=($={})=>j0.File({default:"File",...$,extension:$?.type,type:"string",format:"binary"});A.Files=($={})=>j0.Files({...$,elysiaMeta:"Files",default:"Files",extension:$?.type,type:"array",items:{...$,default:"Files",type:"string",format:"binary"}});A.Nullable=($)=>j0.Nullable($);A.MaybeEmpty=j0.MaybeEmpty;A.Cookie=j0.Cookie;A.Date=j0.Date;var e2=function($,X){if(typeof $!=="string")throw new TypeError("argument str must be a string");var Z={},W=X||{},J=W.decode||X3,j=0;while(j<$.length){var G=$.indexOf("=",j);if(G===-1)break;var Y=$.indexOf(";",j);if(Y===-1)Y=$.length;else if(Y<G){j=$.lastIndexOf(";",G-1)+1;continue}var K=$.slice(j,G).trim();if(Z[K]===void 0){var B=$.slice(G+1,Y).trim();if(B.charCodeAt(0)===34)B=B.slice(1,-1);Z[K]=J3(B,J)}j=Y+1}return Z},$3=function($,X,Z){var W=Z||{},J=W.encode||Z3;if(typeof J!=="function")throw new TypeError("option encode is invalid");if(!t0.test($))throw new TypeError("argument name is invalid");var j=J(X);if(j&&!t0.test(j))throw new TypeError("argument val is invalid");var G=$+"="+j;if(W.maxAge!=null){var Y=W.maxAge-0;if(isNaN(Y)||!isFinite(Y))throw new TypeError("option maxAge is invalid");G+="; Max-Age="+Math.floor(Y)}if(W.domain){if(!t0.test(W.domain))throw new TypeError("option domain is invalid");G+="; Domain="+W.domain}if(W.path){if(!t0.test(W.path))throw new TypeError("option path is invalid");G+="; Path="+W.path}if(W.expires){var K=W.expires;if(!W3(K)||isNaN(K.valueOf()))throw new TypeError("option expires is invalid");G+="; Expires="+K.toUTCString()}if(W.httpOnly)G+="; HttpOnly";if(W.secure)G+="; Secure";if(W.partitioned)G+="; Partitioned";if(W.priority){var B=typeof W.priority==="string"?W.priority.toLowerCase():W.priority;switch(B){case"low":G+="; Priority=Low";break;case"medium":G+="; Priority=Medium";break;case"high":G+="; Priority=High";break;default:throw new TypeError("option priority is invalid")}}if(W.sameSite){var U=typeof W.sameSite==="string"?W.sameSite.toLowerCase():W.sameSite;switch(U){case!0:G+="; SameSite=Strict";break;case"lax":G+="; SameSite=Lax";break;case"strict":G+="; SameSite=Strict";break;case"none":G+="; SameSite=None";break;default:throw new TypeError("option sameSite is invalid")}}return G},X3=function($){return $.indexOf("%")!==-1?decodeURIComponent($):$},Z3=function($){return encodeURIComponent($)},W3=function($){return o2.call($)==="[object Date]"||$ instanceof Date},J3=function($,X){try{return X($)}catch(Z){return $}};/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */var w1=e2,_1=$3;var o2=Object.prototype.toString,t0=/^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;var r1=Y1(s0(),1);class G0{$;X;Z;constructor($,X,Z={}){this.name=$;this.jar=X;this.initial=Z}get cookie(){if(!(this.name in this.jar))return this.initial;return this.jar[this.name]}set cookie($){if(!(this.name in this.jar))this.jar[this.name]=this.initial;this.jar[this.name]=$}get value(){return this.cookie.value}set value($){if(!(this.name in this.jar))this.jar[this.name]=this.initial;this.jar[this.name].value=$}get expires(){return this.cookie.expires}set expires($){this.cookie.expires=$}get maxAge(){return this.cookie.maxAge}set maxAge($){this.cookie.maxAge=$}get domain(){return this.cookie.domain}set domain($){this.cookie.domain=$}get path(){return this.cookie.path}set path($){this.cookie.path=$}get secure(){return this.cookie.secure}set secure($){this.cookie.secure=$}get httpOnly(){return this.cookie.httpOnly}set httpOnly($){this.cookie.httpOnly=$}get sameSite(){return this.cookie.sameSite}set sameSite($){this.cookie.sameSite=$}get priority(){return this.cookie.priority}set priority($){this.cookie.priority=$}get partitioned(){return this.cookie.partitioned}set partitioned($){this.cookie.partitioned=$}get secrets(){return this.cookie.secrets}set secrets($){this.cookie.secrets=$}update($){return this.cookie=Object.assign(this.cookie,typeof $==="function"?$(this.cookie):$),this}set($){return this.cookie=Object.assign({...this.initial,value:this.value},typeof $==="function"?$(this.cookie):$),this}remove(){if(this.value===void 0)return;return this.set({expires:new Date(0),maxAge:0,value:""}),this}toString(){return typeof this.value==="object"?JSON.stringify(this.value):this.value?.toString()??""}}var s1=($,X,Z)=>{if(!$.cookie)$.cookie={};return new Proxy(X,{get(W,J){if(J in X)return new G0(J,$.cookie,Object.assign({},Z??{},X[J]));return new G0(J,$.cookie,Object.assign({},Z))}})},r0=async($,X,{secrets:Z,sign:W,...J}={})=>{if(!X)return s1($,{},J);const j=typeof Z==="string";if(W&&W!==!0&&!Array.isArray(W))W=[W];const G={},Y=w1(X);for(let[K,B]of Object.entries(Y)){let U=r1.default(B);if(W===!0||W?.includes(K)){if(!Z)throw new Error("No secret is provided to cookie plugin");if(j){const w=await D1(U,Z);if(w===!1)throw new y0(K);U=w}else{let w=!0;for(let D=0;D<Z.length;D++){const Q=await D1(U,Z[D]);if(Q!==!1){w=!0,U=Q;break}}if(!w)throw new y0(K)}}G[K]={value:U}}return s1($,G,J)};var a1="toJSON"in new Headers,p=($)=>{if(!$)return!1;for(let X in $)return!0;return!1},v0=($,X)=>{const Z=$.size;if(!X&&Z||Z&&X&&X.status!==206&&X.status!==304&&X.status!==412&&X.status!==416){if(X){if(X.headers instanceof Headers){if(a1)X.headers=X.headers.toJSON();else for(let[W,J]of X.headers.entries())if(W in X.headers)X.headers[W]=J}return new Response($,{status:X.status,headers:Object.assign({"accept-ranges":"bytes","content-range":`bytes 0-${Z-1}/${Z}`},X.headers)})}return new Response($,{headers:{"accept-ranges":"bytes","content-range":`bytes 0-${Z-1}/${Z}`}})}return new Response($)},o1=($,X)=>{if(!$)return $;$.delete("set-cookie");for(let Z=0;Z<X.length;Z++){const W=X[Z].indexOf("=");$.append("set-cookie",`${X[Z].slice(0,W)}=${X[Z].slice(W+1)||""}`)}return $},e1=($)=>{if(!$||!p($))return;const X=[];for(let[Z,W]of Object.entries($)){if(!Z||!W)continue;const J=W.value;if(J===void 0||J===null)continue;X.push(_1(Z,typeof J==="object"?JSON.stringify(J):J+"",W))}if(X.length===0)return;if(X.length===1)return X[0];return X},k0=async($,X,Z)=>{let W=$.next();if(W instanceof Promise)W=await W;if(W.done){if(X)return f(W.value,X,Z);return e(W.value,Z)}return new Response(new ReadableStream({async start(J){let j=!1;if(Z?.signal.addEventListener("abort",()=>{j=!0;try{J.close()}catch{}}),W.value!==void 0&&W.value!==null)J.enqueue(Buffer.from(W.value.toString()));for await(let G of $){if(j)break;if(G===void 0||G===null)continue;J.enqueue(Buffer.from(G.toString())),await new Promise((Y)=>setTimeout(()=>Y(),0))}try{J.close()}catch{}}}),{...X,headers:{"transfer-encoding":"chunked","content-type":"text/event-stream; charset=utf-8",...X?.headers}})},f=($,X,Z)=>{if(p(X.headers)||X.status!==200||X.redirect||X.cookie){if(typeof X.status==="string")X.status=Y0[X.status];if(X.redirect){if(X.headers.Location=X.redirect,!X.status||X.status<300||X.status>=400)X.status=302}if(X.cookie&&p(X.cookie)){const W=e1(X.cookie);if(W)X.headers["set-cookie"]=W}if(X.headers["set-cookie"]&&Array.isArray(X.headers["set-cookie"]))X.headers=o1(new Headers(X.headers),X.headers["set-cookie"]);switch($?.constructor?.name){case"String":return new Response($,X);case"Blob":return v0($,X);case"Array":return Response.json($,X);case"Object":const W=$[m];if(W)return X.status=W,f($.response,X,Z);for(let j in Object.values($))switch(j?.constructor?.name){case"Blob":case"File":case"ArrayBuffer":case"FileRef":return new Response(M0($));default:break}return Response.json($,X);case"ReadableStream":if(!X.headers["content-type"]?.startsWith("text/event-stream"))X.headers["content-type"]="text/event-stream; charset=utf-8";return Z?.signal.addEventListener("abort",{handleEvent(){if(!Z?.signal.aborted)$.cancel(Z)}},{once:!0}),new Response($,X);case void 0:if(!$)return new Response("",X);return Response.json($,X);case"Response":let J=!1;if(X.headers instanceof Headers)for(let j of X.headers.keys())if(j==="set-cookie"){if(J)continue;J=!0;for(let G of X.headers.getSetCookie())$.headers.append("set-cookie",G)}else $.headers.append(j,X.headers?.get(j)??"");else for(let j in X.headers)$.headers.append(j,X.headers[j]);if($.status!==X.status)X.status=$.status;return $;case"Error":return Q0($,X);case"Promise":return $.then((j)=>f(j,X));case"Function":return f($(),X);case"Number":case"Boolean":return new Response($.toString(),X);case"Cookie":if($ instanceof G0)return new Response($.value,X);return new Response($?.toString(),X);case"FormData":return new Response($,X);default:if($ instanceof Response){let j=!1;if(X.headers instanceof Headers)for(let G of X.headers.keys())if(G==="set-cookie"){if(j)continue;j=!0;for(let Y of X.headers.getSetCookie())$.headers.append("set-cookie",Y)}else $.headers.append(G,X.headers?.get(G)??"");else for(let G in X.headers)$.headers.append(G,X.headers[G]);if(a1)X.headers=$.headers.toJSON();else for(let[G,Y]of $.headers.entries())if(G in X.headers)X.headers[G]=Y;return $}if($ instanceof Promise)return $.then((j)=>f(j,X));if($ instanceof Error)return Q0($,X);if(typeof $?.next==="function")return k0($,X,Z);if("toResponse"in $)return f($.toResponse(),X);if("charCodeAt"in $){const j=$.charCodeAt(0);if(j===123||j===91){if(!X.headers["Content-Type"])X.headers["Content-Type"]="application/json";return new Response(JSON.stringify($),X)}}return new Response($,X)}}else switch($?.constructor?.name){case"String":return new Response($);case"Blob":return v0($,X);case"Array":return Response.json($);case"Object":const W=$[m];if(W)return X.status=W,f($.response,X,Z);for(let J in Object.values($))switch(J?.constructor?.name){case"Blob":case"File":case"ArrayBuffer":case"FileRef":return new Response(M0($),X);default:break}return Response.json($,X);case"ReadableStream":return Z?.signal.addEventListener("abort",{handleEvent(){if(!Z?.signal.aborted)$.cancel(Z)}},{once:!0}),new Response($,{headers:{"Content-Type":"text/event-stream; charset=utf-8"}});case void 0:if(!$)return new Response("");return new Response(JSON.stringify($),{headers:{"content-type":"application/json"}});case"Response":return $;case"Error":return Q0($,X);case"Promise":return $.then((J)=>{const j=e(J,Z);if(j!==void 0)return j;return new Response("")});case"Function":return e($(),Z);case"Number":case"Boolean":return new Response($.toString());case"Cookie":if($ instanceof G0)return new Response($.value,X);return new Response($?.toString(),X);case"FormData":return new Response($,X);default:if($ instanceof Response)return new Response($.body,{headers:{"Content-Type":"application/json"}});if($ instanceof Promise)return $.then((J)=>f(J,X));if($ instanceof Error)return Q0($,X);if(typeof $?.next==="function")return k0($,X,Z);if("toResponse"in $)return f($.toResponse(),X);if("charCodeAt"in $){const J=$.charCodeAt(0);if(J===123||J===91){if(!X.headers["Content-Type"])X.headers["Content-Type"]="application/json";return new Response(JSON.stringify($),X)}}return new Response($)}},y=($,X,Z)=>{if($===void 0||$===null)return;if(p(X.headers)||X.status!==200||X.redirect||X.cookie){if(typeof X.status==="string")X.status=Y0[X.status];if(X.redirect){if(X.headers.Location=X.redirect,!X.status||X.status<300||X.status>=400)X.status=302}if(X.cookie&&p(X.cookie)){const W=e1(X.cookie);if(W)X.headers["set-cookie"]=W}if(X.headers["set-cookie"]&&Array.isArray(X.headers["set-cookie"]))X.headers=o1(new Headers(X.headers),X.headers["set-cookie"]);switch($?.constructor?.name){case"String":return new Response($,X);case"Blob":return v0($,X);case"Array":return Response.json($,X);case"Object":const W=$[m];if(W)return X.status=W,y($.response,X,Z);for(let j in Object.values($))switch(j?.constructor?.name){case"Blob":case"File":case"ArrayBuffer":case"FileRef":return new Response(M0($),X);default:break}return Response.json($,X);case"ReadableStream":if(!X.headers["content-type"]?.startsWith("text/event-stream"))X.headers["content-type"]="text/event-stream; charset=utf-8";return Z?.signal.addEventListener("abort",{handleEvent(){if(!Z?.signal.aborted)$.cancel(Z)}},{once:!0}),new Response($,X);case void 0:if(!$)return;return Response.json($,X);case"Response":let J=!1;if(X.headers instanceof Headers)for(let j of X.headers.keys())if(j==="set-cookie"){if(J)continue;J=!0;for(let G of X.headers.getSetCookie())$.headers.append("set-cookie",G)}else $.headers.append(j,X.headers?.get(j)??"");else for(let j in X.headers)$.headers.append(j,X.headers[j]);if($.status!==X.status)X.status=$.status;return $;case"Promise":return $.then((j)=>{const G=y(j,X);if(G!==void 0)return G});case"Error":return Q0($,X);case"Function":return y($(),X);case"Number":case"Boolean":return new Response($.toString(),X);case"FormData":return new Response($);case"Cookie":if($ instanceof G0)return new Response($.value,X);return new Response($?.toString(),X);default:if($ instanceof Response){let j=!1;if(X.headers instanceof Headers)for(let G of X.headers.keys())if(G==="set-cookie"){if(j)continue;j=!0;for(let Y of X.headers.getSetCookie())$.headers.append("set-cookie",Y)}else $.headers.append(G,X.headers?.get(G)??"");else for(let G in X.headers)$.headers.append(G,X.headers[G]);if($.status!==X.status)X.status=$.status;return $}if($ instanceof Promise)return $.then((j)=>y(j,X));if($ instanceof Error)return Q0($,X);if(typeof $?.next==="function")return k0($,X,Z);if("toResponse"in $)return y($.toResponse(),X);if("charCodeAt"in $){const j=$.charCodeAt(0);if(j===123||j===91){if(!X.headers["Content-Type"])X.headers["Content-Type"]="application/json";return new Response(JSON.stringify($),X)}}return new Response($,X)}}else switch($?.constructor?.name){case"String":return new Response($);case"Blob":return v0($,X);case"Array":return Response.json($);case"Object":const W=$[m];if(W)return X.status=W,y($.response,X,Z);for(let J in Object.values($))switch(J?.constructor?.name){case"Blob":case"File":case"ArrayBuffer":case"FileRef":return new Response(M0($),X);default:break}return Response.json($,X);case"ReadableStream":return Z?.signal.addEventListener("abort",{handleEvent(){if(!Z?.signal.aborted)$.cancel(Z)}},{once:!0}),new Response($,{headers:{"Content-Type":"text/event-stream; charset=utf-8"}});case void 0:if(!$)return new Response("");return new Response(JSON.stringify($),{headers:{"content-type":"application/json"}});case"Response":return $;case"Promise":return $.then((J)=>{const j=y(J,X);if(j!==void 0)return j});case"Error":return Q0($,X);case"Function":return e($(),Z);case"Number":case"Boolean":return new Response($.toString());case"Cookie":if($ instanceof G0)return new Response($.value,X);return new Response($?.toString(),X);case"FormData":return new Response($);default:if($ instanceof Response)return new Response($.body,{headers:{"Content-Type":"application/json"}});if($ instanceof Promise)return $.then((J)=>y(J,X));if($ instanceof Error)return Q0($,X);if(typeof $?.next==="function")return k0($,X,Z);if("toResponse"in $)return y($.toResponse(),X);if("charCodeAt"in $){const J=$.charCodeAt(0);if(J===123||J===91){if(!X.headers["Content-Type"])X.headers["Content-Type"]="application/json";return new Response(JSON.stringify($),X)}}return new Response($)}},e=($,X)=>{switch($?.constructor?.name){case"String":return new Response($);case"Blob":return v0($);case"Array":return Response.json($);case"Object":if($[m])return f($.response,{status:$[m],headers:{}});$:for(let Z of Object.values($))switch(Z?.constructor?.name){case"Blob":case"File":case"ArrayBuffer":case"FileRef":return new Response(M0($));case"Object":break $;default:break}return Response.json($);case"ReadableStream":return X?.signal.addEventListener("abort",{handleEvent(){if(!X?.signal.aborted)$.cancel(X)}},{once:!0}),new Response($,{headers:{"Content-Type":"text/event-stream; charset=utf-8"}});case void 0:if(!$)return new Response("");return new Response(JSON.stringify($),{headers:{"content-type":"application/json"}});case"Response":return $;case"Error":return Q0($);case"Promise":return $.then((Z)=>e(Z,X));case"Function":return e($(),X);case"Number":case"Boolean":return new Response($.toString());case"FormData":return new Response($);default:if($ instanceof Response)return new Response($.body,{headers:{"Content-Type":"application/json"}});if($ instanceof Promise)return $.then((Z)=>e(Z,X));if($ instanceof Error)return Q0($);if(typeof $?.next==="function")return k0($,void 0,X);if("toResponse"in $)return e($.toResponse());if("charCodeAt"in $){const Z=$.charCodeAt(0);if(Z===123||Z===91)return new Response(JSON.stringify($),{headers:{"Content-Type":"application/json"}})}return new Response($)}},Q0=($,X)=>new Response(JSON.stringify({name:$?.name,message:$?.message,cause:$?.cause}),{status:X?.status!==200?X?.status??500:500,headers:X?.headers});var F3=function($){let X=$;while(X.endsWith("="))X=X.slice(0,-1);return X},a0=($,X)=>{const Z=new URL($);return Z.pathname=X,Z.toString()},Y3=($)=>typeof $==="function"&&/^\s*class\s+/.test($.toString())||$.toString().startsWith("[object ")&&$.toString()!=="[object Object]"||p(Object.getPrototypeOf($)),M1=($)=>$&&typeof $==="object"&&!Array.isArray($),d=($,X,{skipKeys:Z,override:W=!0}={})=>{if(!M1($)||!M1(X))return $;for(let[J,j]of Object.entries(X)){if(Z?.includes(J))continue;if(!M1(j)||!(J in $)||Y3(j)){if(W||!(J in $))$[J]=j;continue}$[J]=d($[J],j,{skipKeys:Z,override:W})}return $},B3=($,X)=>{const{properties:Z,...W}=$??{},{properties:J,...j}=X??{};return d(W,j)},x=($=[],X=[])=>{if(!$)return[];if(!X)return $;const Z=[],W=[];if(!Array.isArray($))$=[$];if(!Array.isArray(X))X=[X];for(let J of $)if(Z.push(J),J.checksum)W.push(J.checksum);for(let J of X)if(!W.includes(J.checksum))Z.push(J);return Z},K3=["start","request","parse","transform","resolve","beforeHandle","afterHandle","mapResponse","afterResponse","trace","error","stop","body","headers","params","query","response","type","detail"],U3=K3.reduce(($,X)=>($[X]=!0,$),{}),W2=($,X)=>{const Z=(W)=>typeof W==="object"&&Object.keys(W).every(X1);if(Z($)&&Z(X))return{...$,...X};return X??$},H0=($,X)=>{return{body:X?.body??$?.body,headers:X?.headers??$?.headers,params:X?.params??$?.params,query:X?.query??$?.query,response:W2($?.response,X?.response)}},c=($,X)=>{return{...$,...X,body:X?.body??$?.body,headers:X?.headers??$?.headers,params:X?.params??$?.params,query:X?.query??$?.query,response:W2($?.response,X?.response),type:$?.type||X?.type,detail:d(X?.detail??{},$?.detail??{}),parse:x($?.parse,X?.parse),transform:x($?.transform,X?.transform),beforeHandle:x($?.beforeHandle,X?.beforeHandle),afterHandle:x($?.afterHandle,X?.afterHandle),mapResponse:x($?.mapResponse,X?.mapResponse),afterResponse:x($?.afterResponse,X?.afterResponse),trace:x($?.trace,X?.trace),error:x($?.error,X?.error)}},J2=($,X,Z=!0)=>{if(!Array.isArray(X))return u($,X,Z);for(let W of X)$=u($,W,Z);return $},u=($,X,Z=!0)=>{if(!$)return $;if(X.untilObjectFound&&!Z&&$.type==="object")return $;const W=X.from[T0];if($.oneOf){for(let G=0;G<$.oneOf.length;G++)$.oneOf[G]=u($.oneOf[G],X,Z);return $}if($.anyOf){for(let G=0;G<$.anyOf.length;G++)$.anyOf[G]=u($.anyOf[G],X,Z);return $}if($.allOf){for(let G=0;G<$.allOf.length;G++)$.allOf[G]=u($.allOf[G],X,Z);return $}if($.not){for(let G=0;G<$.not.length;G++)$.not[G]=u($.not[G],X,Z);return $}const J=Z&&!!X.excludeRoot;if($[T0]===W){const{anyOf:G,oneOf:Y,allOf:K,not:B,properties:U,items:w,...D}=$,Q=X.to();let _;const P=(M)=>{if(U&&M.type==="object"){const V={};for(let[O,q]of Object.entries(U))V[O]=u(q,X,!1);return{...D,...M,properties:V}}if(w&&M.type==="array")return{...D,...M,items:u(w,X,!1)};const I={...D,...M};if(delete I.required,U&&M.type==="string"&&M.format==="ObjectString"&&M.default==="{}")_=A.ObjectString(U,D),I.default=JSON.stringify(F0.Create(A.Object(U))),I.properties=U;if(w&&M.type==="string"&&M.format==="ArrayString"&&M.default==="[]")_=A.ArrayString(w,D),I.default=JSON.stringify(F0.Create(A.Array(w))),I.items=w;return I};if(J){if(U){const M={};for(let[I,V]of Object.entries(U))M[I]=u(V,X,!1);return{...D,properties:M}}else if(w?.map)return{...D,items:w.map((M)=>u(M,X,!1))};return D}if(Q.anyOf)for(let M=0;M<Q.anyOf.length;M++)Q.anyOf[M]=P(Q.anyOf[M]);else if(Q.oneOf)for(let M=0;M<Q.oneOf.length;M++)Q.oneOf[M]=P(Q.oneOf[M]);else if(Q.allOf)for(let M=0;M<Q.allOf.length;M++)Q.allOf[M]=P(Q.allOf[M]);else if(Q.not)for(let M=0;M<Q.not.length;M++)Q.not[M]=P(Q.not[M]);if(_)Q[$2]=_[$2];if(Q.anyOf||Q.oneOf||Q.allOf||Q.not)return Q;if(U){const M={};for(let[I,V]of Object.entries(U))M[I]=u(V,X,!1);return{...D,...Q,properties:M}}else if(w?.map)return{...D,...Q,items:w.map((M)=>u(M,X,!1))};return{...D,...Q}}const j=$?.properties;if(j)for(let[G,Y]of Object.entries(j))switch(Y[T0]){case W:const{anyOf:K,oneOf:B,allOf:U,not:w,type:D,...Q}=Y,_=X.to();if(_.anyOf)for(let P=0;P<_.anyOf.length;P++)_.anyOf[P]={...Q,..._.anyOf[P]};else if(_.oneOf)for(let P=0;P<_.oneOf.length;P++)_.oneOf[P]={...Q,..._.oneOf[P]};else if(_.allOf)for(let P=0;P<_.allOf.length;P++)_.allOf[P]={...Q,..._.allOf[P]};else if(_.not)for(let P=0;P<_.not.length;P++)_.not[P]={...Q,..._.not[P]};j[G]={...Q,...u(Q,X,!1)};break;case"Object":case"Union":j[G]=u(Y,X,!1);break;default:if(Y.items)for(let P=0;P<Y.items.length;P++)Y.items[P]=u(Y.items[P],X,!1);else if(Y.anyOf||Y.oneOf||Y.allOf||Y.not)j[G]=u(Y,X,!1);break}return $},h=($,{models:X={},dynamic:Z=!1,normalize:W=!1,additionalProperties:J=!1,coerce:j=!1,additionalCoerce:G=[]}={})=>{if(!$)return;if(typeof $==="string"&&!($ in X))return;let Y=typeof $==="string"?X[$]:$;if(j)Y=J2(Y,[{from:A.Number(),to:()=>A.Numeric(),untilObjectFound:!0},{from:A.Boolean(),to:()=>A.BooleanString(),untilObjectFound:!0},...Array.isArray(G)?G:[G]]);if(Y.type==="object"&&"additionalProperties"in Y===!1)Y.additionalProperties=J;const K=(U)=>F0.Clean(Y,U);if(Z){const U={schema:Y,references:"",checkFunc:()=>{},code:"",Check:(w)=>F0.Check(Y,w),Errors:(w)=>F0.Errors(Y,w),Code:()=>"",Clean:K};if(W&&Y.additionalProperties===!1)U.Clean=K;if(Y.config){if(U.config=Y.config,U?.schema?.config)delete U.schema.config}return U.parse=(w)=>{try{return U.Decode(w)}catch(D){throw[...U.Errors(w)].map(s)}},U.safeParse=(w)=>{try{return{success:!0,data:U.Decode(w),error:null}}catch(D){const Q=[...B.Errors(w)].map(s);return{success:!1,data:null,error:Q[0]?.summary,errors:Q}}},U}const B=Z2.Compile(Y,Object.values(X));if(B.Clean=K,Y.config){if(B.config=Y.config,B?.schema?.config)delete B.schema.config}return B.parse=(U)=>{try{return B.Decode(U)}catch(w){throw[...B.Errors(U)].map(s)}},B.safeParse=(U)=>{try{return{success:!0,data:B.Decode(U),error:null}}catch(w){const D=[...B.Errors(U)].map(s);return{success:!1,data:null,error:D[0]?.summary,errors:D}}},B},o0=($,{models:X={},dynamic:Z=!1,normalize:W=!1,additionalProperties:J=!1})=>{if(!$)return;if(typeof $==="string"&&!($ in X))return;const j=typeof $==="string"?X[$]:$,G=(K,B)=>{const U=(D)=>F0.Clean(K,D);if(Z)return{schema:K,references:"",checkFunc:()=>{},code:"",Check:(D)=>F0.Check(K,D),Errors:(D)=>F0.Errors(K,D),Code:()=>""};const w=Z2.Compile(K,B);if(W&&K.additionalProperties===!1)w.Clean=U;return w};if(T0 in j){if("additionalProperties"in j===!1)j.additionalProperties=J;return{200:G(j,Object.values(X))}}const Y={};return Object.keys(j).forEach((K)=>{const B=j[+K];if(typeof B==="string"){if(B in X){const U=X[B];U.type==="object"&&"additionalProperties"in U,Y[+K]=T0 in U?G(U,Object.values(X)):U}return}if(B.type==="object"&&"additionalProperties"in B===!1)B.additionalProperties=J;Y[+K]=T0 in B?G(B,Object.values(X)):B}),Y},w3=typeof Bun!=="undefined",_3=w3&&typeof Bun.hash==="function",z0=($)=>{if(_3)return Bun.hash($);let X=9;for(let Z=0;Z<$.length;)X=Math.imul(X^$.charCodeAt(Z++),387420489);return X=X^X>>>9},D0=[{from:A.Object({}),to:()=>A.ObjectString({}),excludeRoot:!0},{from:A.Array(A.Any()),to:()=>A.ArrayString(A.Any())}],e0=({validator:$,defaultConfig:X={},config:Z,dynamic:W,models:J})=>{let j=h($,{dynamic:W,models:J,additionalProperties:!0,coerce:!0,additionalCoerce:D0});if(p(X))if(j)j.config=B3(j.config,Z);else j=h(A.Cookie({}),{dynamic:W,models:J,additionalProperties:!0}),j.config=X;return j},$0=($,X)=>{if(!X)return;if(!Array.isArray(X)){const W=X;if($&&!W.checksum)W.checksum=$;if(W.scope==="scoped")W.scope="local";return W}const Z=[...X];for(let W of Z){if($&&!W.checksum)W.checksum=$;if(W.scope==="scoped")W.scope="local"}return Z},z1=($,X,Z)=>{return{start:x($.start,$0(Z,X?.start)),request:x($.request,$0(Z,X?.request)),parse:x($.parse,$0(Z,X?.parse)),transform:x($.transform,$0(Z,X?.transform)),beforeHandle:x($.beforeHandle,$0(Z,X?.beforeHandle)),afterHandle:x($.afterHandle,$0(Z,X?.afterHandle)),mapResponse:x($.mapResponse,$0(Z,X?.mapResponse)),afterResponse:x($.afterResponse,$0(Z,X?.afterResponse)),trace:x($.trace,$0(Z,X?.trace)),error:x($.error,$0(Z,X?.error)),stop:x($.stop,$0(Z,X?.stop))}},j2=($,X,{skipIfHasType:Z=!1}={})=>{if(!$)return $;if(!Array.isArray($)){if(Z)$.scope??=X;else $.scope=X;return $}for(let W of $)if(Z)W.scope??=X;else W.scope=X;return $},_0=($)=>{if(!$)return $;if(!Array.isArray($))switch($.scope){case"global":case"scoped":return{...$};default:return{fn:$}}const X=[];for(let Z of $)switch(Z.scope){case"global":case"scoped":X.push({...Z});break}return X},P1=($)=>{return{...$,type:$?.type,detail:$?.detail,parse:_0($?.parse),transform:_0($?.transform),beforeHandle:_0($?.beforeHandle),afterHandle:_0($?.afterHandle),mapResponse:_0($?.mapResponse),afterResponse:_0($?.afterResponse),error:_0($?.error),trace:_0($?.trace)}},Y0={Continue:100,"Switching Protocols":101,Processing:102,"Early Hints":103,OK:200,Created:201,Accepted:202,"Non-Authoritative Information":203,"No Content":204,"Reset Content":205,"Partial Content":206,"Multi-Status":207,"Already Reported":208,"Multiple Choices":300,"Moved Permanently":301,Found:302,"See Other":303,"Not Modified":304,"Temporary Redirect":307,"Permanent Redirect":308,"Bad Request":400,Unauthorized:401,"Payment Required":402,Forbidden:403,"Not Found":404,"Method Not Allowed":405,"Not Acceptable":406,"Proxy Authentication Required":407,"Request Timeout":408,Conflict:409,Gone:410,"Length Required":411,"Precondition Failed":412,"Payload Too Large":413,"URI Too Long":414,"Unsupported Media Type":415,"Range Not Satisfiable":416,"Expectation Failed":417,"I'm a teapot":418,"Misdirected Request":421,"Unprocessable Content":422,Locked:423,"Failed Dependency":424,"Too Early":425,"Upgrade Required":426,"Precondition Required":428,"Too Many Requests":429,"Request Header Fields Too Large":431,"Unavailable For Legal Reasons":451,"Internal Server Error":500,"Not Implemented":501,"Bad Gateway":502,"Service Unavailable":503,"Gateway Timeout":504,"HTTP Version Not Supported":505,"Variant Also Negotiates":506,"Insufficient Storage":507,"Loop Detected":508,"Not Extended":510,"Network Authentication Required":511},$1=Object.fromEntries(Object.entries(Y0).map(([$,X])=>[X,$])),X2=new TextEncoder,E0=async($,X)=>{if(typeof $!=="string")throw new TypeError("Cookie value must be provided as a string.");if(X===null)throw new TypeError("Secret key must be provided.");const Z=await crypto.subtle.importKey("raw",X2.encode(X),{name:"HMAC",hash:"SHA-256"},!1,["sign"]),W=await crypto.subtle.sign("HMAC",Z,X2.encode($));return $+"."+F3(Buffer.from(W).toString("base64"))},D1=async($,X)=>{if(typeof $!=="string")throw new TypeError("Signed cookie string must be provided.");if(X===null)throw new TypeError("Secret key must be provided.");const Z=$.slice(0,$.lastIndexOf("."));return await E0(Z,X)===$?Z:!1},Q2=($,X)=>{if(!$||typeof $!=="object"||!X)return;for(let[Z,W]of Object.entries(X)){if(Z in U3||!(Z in $))continue;const J=$[Z];if(typeof J==="function")J(W),delete X[Z]}},G2=({globalHook:$,localHook:X})=>(Z)=>(W,J)=>{if(typeof W==="function")W={fn:W};if("fn"in W||Array.isArray(W)){if(!X[Z])X[Z]=[];if(typeof X[Z]==="function")X[Z]=[X[Z]];if(Array.isArray(W))X[Z]=X[Z].concat(W);else X[Z].push(W);return}const{insert:j="after",stack:G="local"}=W;if(typeof J==="function")J={fn:J};if(G==="global")if(!Array.isArray(J))if(j==="before")$[Z].unshift(J);else $[Z].push(J);else if(j==="before")$[Z]=J.concat($[Z]);else $[Z]=$[Z].concat(J);else{if(!X[Z])X[Z]=[];if(typeof X[Z]==="function")X[Z]=[X[Z]];if(!Array.isArray(J))if(j==="before")X[Z].unshift(J);else X[Z].push(J);else if(j==="before")X[Z]=J.concat(X[Z]);else X[Z]=X[Z].concat(J)}},D3=($)=>{if(typeof $==="number")return $;if($.length<16){if($.trim().length===0)return null;const X=Number($);if(Number.isNaN(X))return null;return X}if($.length===16){if($.trim().length===0)return null;const X=Number($);if(Number.isNaN(X)||X.toString()!==$)return null;return X}return null},X1=($)=>D3($)!==null;class N1{$;root=null;promises=[];constructor($=console.error){this.onError=$}get size(){return this.promises.length}add($){return this.promises.push($),this.root||=this.drain(),$}async drain(){while(this.promises.length>0){try{await this.promises[0]}catch($){this.onError($)}this.promises.shift()}this.root=null}then($,X){return(this.root??Promise.resolve()).then($,X)}}var i=($)=>{if(!$)return $;if(!Array.isArray($)){if(typeof $==="function")return{fn:$};else if("fn"in $)return $}const X=[];for(let Z of $)if(typeof Z==="function")X.push({fn:Z});else if("fn"in Z)X.push(Z);return X},Y2=($)=>{return{...$,start:i($?.start),request:i($?.request),parse:i($?.parse),transform:i($?.transform),beforeHandle:i($?.beforeHandle),afterHandle:i($?.afterHandle),mapResponse:i($?.mapResponse),afterResponse:i($?.afterResponse),trace:i($?.trace),error:i($?.error),stop:i($?.stop)}},I1=($)=>{return{...$,start:$.start?.map((X)=>X.fn),request:$.request?.map((X)=>X.fn),parse:$.parse?.map((X)=>X.fn),transform:$.transform?.map((X)=>X.fn),beforeHandle:$.beforeHandle?.map((X)=>X.fn),afterHandle:$.afterHandle?.map((X)=>X.fn),afterResponse:$.afterResponse?.map((X)=>X.fn),mapResponse:$.mapResponse?.map((X)=>X.fn),trace:$.trace?.map((X)=>X.fn),error:$.error?.map((X)=>X.fn),stop:$.stop?.map((X)=>X.fn)}},u0=($)=>({body:$.body,cookie:$.cookie,headers:$.headers,query:$.query,set:$.set,server:$.server}),h0=($,X=302)=>Response.redirect($,X),M3=Symbol("ElysiaFormData"),P0=Symbol("ElysiaRequestId"),M0=($)=>{const X=new FormData;for(let[Z,W]of Object.entries($)){if(Array.isArray(W)){for(let J of W){if(W instanceof File)X.append(Z,W,W.name);X.append(Z,J)}continue}if(W instanceof File)X.append(Z,W,W.name);X.append(Z,W)}return X},Z1=()=>crypto.getRandomValues(new Uint32Array(1))[0],W1=($)=>{const X=[];for(let Z=0;Z<$.length;Z++){const W=$[Z];if(W.checksum){if(X.includes(W.checksum))$.splice(Z,1),Z--;X.push(W.checksum)}}return $},v=($,X="scoped")=>{if(X==="scoped"){for(let Z of $)if("scope"in Z&&Z.scope==="local")Z.scope="scoped";return}for(let Z of $)if("scope"in Z)Z.scope="global"};var B2=typeof Bun!=="undefined"?Bun.env:typeof process!=="undefined"?process?.env:void 0,N0=Symbol("ElysiaErrorCode"),m=Symbol("ElysiaResponse"),d0=(B2?.NODE_ENV??B2?.ENV)==="production",V1=($,X)=>{const Z=X??($ in $1?$1[$]:$);return{[m]:Y0[$]??$,response:Z,_type:void 0,error:new Error(Z)}};class J1 extends Error{code="INTERNAL_SERVER_ERROR";status=500;constructor($){super($??"INTERNAL_SERVER_ERROR")}}class I0 extends Error{code="NOT_FOUND";status=404;constructor($){super($??"NOT_FOUND")}}class j1 extends Error{code="PARSE";status=400;constructor(){super("Failed to parse body")}}class y0 extends Error{$;code="INVALID_COOKIE_SIGNATURE";status=400;constructor($,X){super(X??`"${$}" has invalid cookie signature`);this.key=$}}var s=($)=>{const{message:X,path:Z,value:W,type:J}=$,j=Z.slice(1).replaceAll("/","."),G=Z==="";switch(J){case 42:return{...$,summary:G?"Value should not be provided":`Property '${j}' should not be provided`};case 45:return{...$,summary:G?"Value is missing":`Property '${j}' is missing`};case 50:const Y=X.indexOf("'"),K=X.slice(Y+1,X.indexOf("'",Y+1));return{...$,summary:G?"Value should be an email":`Property '${j}' should be ${K}`};case 54:return{...$,summary:`${X.slice(0,9)} property '${j}' to be ${X.slice(8)} but found: ${W}`};case 62:const B=$.schema.anyOf.map((U)=>`'${U?.format??U.type}'`).join(", ");return{...$,summary:G?`Value should be one of ${B}`:`Property '${j}' should be one of: ${B}`};default:return{summary:X,...$}}};class H extends Error{$;X;Z;code="VALIDATION";status=422;constructor($,X,Z){if(Z&&typeof Z==="object"&&m in Z)Z=Z.response;const W=d0?void 0:("Errors"in X)?X.Errors(Z).First():m0.Errors(X,Z).First(),J=W?.schema.error!==void 0?typeof W.schema.error==="function"?W.schema.error({type:$,validator:X,value:Z,get errors(){return[...X.Errors(Z)].map(s)}}):W.schema.error:void 0,j=W?.path||"root";let G="";if(J!==void 0)G=typeof J==="object"?JSON.stringify(J):J+"";else if(d0)G=JSON.stringify({type:"validation",on:$,summary:s(W).summary,message:W?.message,found:Z});else{const Y=X?.schema??X,K="Errors"in X?[...X.Errors(Z)].map(s):[...m0.Errors(X,Z)].map(s);let B;try{B=m0.Create(Y)}catch(U){B={type:"Could not create expected value",message:U?.message,error:U}}G=JSON.stringify({type:"validation",on:$,summary:K[0]?.summary,property:j,message:W?.message,expected:B,found:Z,errors:K},null,2)}super(G);this.type=$;this.validator=X;this.value=Z;Object.setPrototypeOf(this,H.prototype)}get all(){return"Errors"in this.validator?[...this.validator.Errors(this.value)].map(s):[...m0.Errors(this.validator,this.value)].map(s)}static simplifyModel($){const X="schema"in $?$.schema:$;try{return m0.Create(X)}catch{return X}}get model(){return H.simplifyModel(this.validator)}toResponse($){return new Response(this.message,{status:400,headers:{...$,"content-type":"application/json"}})}}var O1={open($){$.data.open?.($)},message($,X){$.data.message?.($,X)},drain($){$.data.drain?.($)},close($,X,Z){$.data.close?.($,X,Z)}};class R0{$;X;validator;_validator;constructor($,X){this.raw=$;this.data=X;if(this.validator=$.data.validator,$.data.id)this.id=$.data.id;else this.id=Z1().toString()}get id(){return this.raw.data.id}set id($){this.raw.data.id=$}get publish(){return($,X=void 0,Z)=>{if(this.validator?.Check(X)===!1)throw new H("message",this.validator,X);if(typeof X==="object")X=JSON.stringify(X);return this.raw.publish($,X,Z),this}}get send(){return($)=>{if(this.validator?.Check($)===!1)throw new H("message",this.validator,$);if(Buffer.isBuffer($))return this.raw.send($),this;if(typeof $==="object")$=JSON.stringify($);return this.raw.send($),this}}get subscribe(){return($)=>{return this.raw.subscribe($),this}}get unsubscribe(){return($)=>{return this.raw.unsubscribe($),this}}get cork(){return($)=>{return this.raw.cork($),this}}get close(){return()=>{return this.raw.close(),this}}get terminate(){return this.raw.terminate.bind(this.raw)}get isSubscribed(){return this.raw.isSubscribed.bind(this.raw)}get remoteAddress(){return this.raw.remoteAddress}}var A1="1.1.3";import{Value as l0} from"@sinclair/typebox/value";var C1=Y1(s0(),1);function b0($){const X={};if(typeof $!=="string")return X;const Z=$.length;let W="",J="",j=-1,G=-1,Y=!1,K=!1,B=!1,U=!1,w=!1,D=0;for(let Q=0;Q<Z+1;Q++)if(D=Q!==Z?$.charCodeAt(Q):38,D===38){if(w=G>j,!w)G=Q;if(W=$.slice(j+1,G),w||W.length>0){if(B)W=W.replace(K2," ");if(Y)W=C1.default(W)||W;if(!X[W]){if(w){if(J=$.slice(G+1,Q),U)J=J.replace(K2," ");if(K)J=C1.default(J)||J}X[W]=J}}J="",j=Q,G=Q,Y=!1,K=!1,B=!1,U=!1}else if(D===61)if(G<=j)G=Q;else K=!0;else if(D===43)if(G>j)U=!0;else B=!0;else if(D===37)if(G>j)K=!0;else Y=!0;return X}var K2=/\+/g;var w2=Y1(s0(),1);var c0=Symbol("ElysiaTrace"),B0=()=>{const{promise:$,resolve:X}=Promise.withResolvers(),{promise:Z,resolve:W}=Promise.withResolvers(),{promise:J,resolve:j}=Promise.withResolvers(),G=[],Y=[];return[(K)=>{if(K)G.push(K);return $},(K)=>{const B=[],U=[];let w=null;for(let Q=0;Q<(K.total??0);Q++){const{promise:_,resolve:P}=Promise.withResolvers(),{promise:M,resolve:I}=Promise.withResolvers(),{promise:V,resolve:O}=Promise.withResolvers(),q=[],L=[];B.push((E)=>{if(E)q.push(E);return _}),U.push((E)=>{const k={...E,end:M,error:V,index:Q,onStop(R){if(R)L.push(R);return M}};P(k);for(let R=0;R<q.length;R++)q[R](k);return(R=null)=>{const U0=performance.now();if(R)w=R;const b={end:U0,error:R,get elapsed(){return U0-E.begin}};for(let W0=0;W0<L.length;W0++)L[W0](b);I(U0),O(R)}})}const D={...K,end:Z,error:J,onEvent(Q){for(let _=0;_<B.length;_++)B[_](Q)},onStop(Q){if(Q)Y.push(Q);return Z}};X(D);for(let Q=0;Q<G.length;Q++)G[Q](D);return{resolveChild:U,resolve(Q=null){const _=performance.now();if(!Q&&w)Q=w;const P={end:_,error:Q,get elapsed(){return _-K.begin}};for(let M=0;M<Y.length;M++)Y[M](P);W(_),j(Q)}}}]},U2=($)=>{return(X)=>{const[Z,W]=B0(),[J,j]=B0(),[G,Y]=B0(),[K,B]=B0(),[U,w]=B0(),[D,Q]=B0(),[_,P]=B0(),[M,I]=B0(),[V,O]=B0();return $({id:X[P0],context:X,set:X.set,onRequest:Z,onParse:J,onTransform:G,onBeforeHandle:K,onHandle:U,onAfterHandle:D,onMapResponse:M,onAfterResponse:V,onError:_}),{request:W,parse:j,transform:Y,beforeHandle:B,handle:w,afterHandle:Q,error:P,mapResponse:I,afterResponse:O}}};var P3=(new Headers()).toJSON,_2={optional:Symbol.for("TypeBox.Optional"),kind:Symbol.for("TypeBox.Kind")},K0=($)=>{if(!$)return!1;const X=$?.schema;return!!X&&_2.optional in X},X0=($)=>{if(!$)return!1;const X=$?.schema??$;if(X.anyOf)return X.anyOf.some(X0);if(X.someOf)return X.someOf.some(X0);if(X.allOf)return X.allOf.some(X0);if(X.not)return X.not.some(X0);if(X.type==="object"){const Z=X.properties;if("additionalProperties"in X)return X.additionalProperties;for(let W of Object.keys(Z)){const J=Z[W];if(J.type==="object"){if(X0(J))return!0}else if(J.anyOf){for(let j=0;j<J.anyOf.length;j++)if(X0(J.anyOf[j]))return!0}return J.additionalProperties}return!1}return!1},q1=({context:$="c",trace:X,addFn:Z})=>{if(!X.length)return()=>{return{resolveChild(){return()=>{}},resolve(){}}};for(let W=0;W<X.length;W++)Z(`let report${W}, reportChild${W}, reportErr${W}, reportErrChild${W}; let trace${W} = ${$}[ELYSIA_TRACE]?.[${W}] ?? trace[${W}](${$});\n`);return(W,{name:J,total:j=0}={})=>{if(!J)J="anonymous";const G=W==="error"?"reportErr":"report";for(let Y=0;Y<X.length;Y++)Z(`\n${G}${Y} = trace${Y}.${W}({id,event: '${W}',name: '${J}',begin: performance.now(),total: ${j}})\n`);return{resolve(){for(let Y=0;Y<X.length;Y++)Z(`\n${G}${Y}.resolve()\n`)},resolveChild(Y){for(let K=0;K<X.length;K++)Z(`${G}Child${K} = ${G}${K}.resolveChild?.shift()?.({id,event: '${W}',name: '${Y}',begin: performance.now()})\n`);return(K)=>{for(let B=0;B<X.length;B++)if(K)Z(`
                             	if (${K} instanceof Error)
                    				${G}Child${B}?.(${K})
                           		else
                             		${G}Child${B}?.()\n`);else Z(`${G}Child${B}?.()\n`)}}}}},N3=({injectResponse:$="",normalize:X=!1,validator:Z})=>({composeValidation:(W,J=`c.${W}`)=>`c.set.status = 422; throw new ValidationError('${W}', validator.${W}, ${J})`,composeResponseValidation:(W="r")=>{let J="\n"+$+"\n";J+=`if(typeof ${W} === "object" && ${W} && ELYSIA_RESPONSE in ${W}) {
			c.set.status = ${W}[ELYSIA_RESPONSE]
			${W} = ${W}.response
		}

		const isResponse = ${W} instanceof Response\n\n`,J+="switch(c.set.status) {\n";for(let[j,G]of Object.entries(Z.response)){if(J+=`\tcase ${j}:
				if (!isResponse) {\n`,X&&"Clean"in G&&!X0(G))J+=`${W} = validator.response['${j}'].Clean(${W})\n`;J+=`if(validator.response['${j}'].Check(${W}) === false) {
					c.set.status = 422

					throw new ValidationError('response', validator.response['${j}'], ${W})
				}

				c.set.status = ${j}
			}

			break\n\n`}return J+="\n}\n",J}}),v8=Symbol.for("TypeBox.Kind");var V0=($,X)=>{if(!X)return;if(X.type==="object"){const Z=X.properties;if(!Z)return!1;for(let W of Object.keys(Z)){const J=Z[W];if($ in J)return!0;if(J.type==="object"){if(V0($,J))return!0}else if(J.anyOf){for(let j=0;j<J.anyOf.length;j++)if(V0($,J.anyOf[j]))return!0}}return!1}return $ in X},S1=Symbol.for("TypeBox.Transform"),O0=($)=>{if(!$)return;if($.type==="object"&&$.properties){const X=$.properties;for(let Z of Object.keys(X)){const W=X[Z];if(W.type==="object"){if(O0(W))return!0}else if(W.anyOf){for(let j=0;j<W.anyOf.length;j++)if(O0(W.anyOf[j]))return!0}if(S1 in W)return!0}return!1}return S1 in $||$.properties&&S1 in $.properties},I3=/(?:return|=>) \S+\(/g,A0=($)=>{return($?.fn??$).constructor.name==="AsyncFunction"},g=($)=>{const X=$?.fn??$;if(X.constructor.name==="AsyncFunction")return!0;const Z=X.toString();if(Z.includes("=> response.clone("))return!1;if(Z.includes("await"))return!0;if(Z.includes("async"))return!0;return!!Z.match(I3)},Q1=($)=>{const X=$?.fn??$;return X.constructor.name==="AsyncGeneratorFunction"||X.constructor.name==="GeneratorFunction"},F2=({app:$,path:X,method:Z,localHook:W,hooks:J,validator:j,handler:G,allowMeta:Y=!1,inference:K})=>{const B=typeof G==="function";if(!B)G=f(G,{headers:$.setHeaders??{}});const U=B?"handler(c)":"handler",w=J.afterResponse.length>0,D=J.trace.length>0;let Q="";if(K=i0(Object.assign(W,{handler:G}),K),K.server)Q+=`\nObject.defineProperty(c, 'server', {
			get: function() { return getServer() }
		})\n`;if(K.body)Q+="let isParsing = false\n";j.createBody?.(),j.createQuery?.(),j.createHeaders?.(),j.createParams?.(),j.createCookie?.(),j.createResponse?.();const _=K.query||!!j.query,P=Z!=="$INTERNALWS"&&Z!=="GET"&&Z!=="HEAD"&&(K.body||!!j.body||J.parse.length),M=$.setHeaders,I=M&&!!Object.keys(M).length,V=K.headers||j.headers,O=K.cookie||!!j.cookie,q=O?e0({validator:j.cookie,defaultConfig:$.config.cookie,dynamic:!!$.config.aot,config:j.cookie?.config??{},models:$.definitions.type}):void 0,L=q?.config;let E="";if(L?.sign){if(!L.secrets)throw new Error(`t.Cookie required secret which is not set in (${Z}) ${X}.`);const z=!L.secrets?void 0:typeof L.secrets==="string"?L.secrets:L.secrets[0];if(E+=`const _setCookie = c.set.cookie
		if(_setCookie) {`,L.sign===!0)E+=`for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${z}')
			}`;else for(let F of L.sign)E+=`if(_setCookie['${F}']?.value) { c.set.cookie['${F}'].value = await signCookie(_setCookie['${F}'].value, '${z}') }\n`;E+="}\n"}const k=$.config.normalize,{composeValidation:R,composeResponseValidation:U0}=N3({normalize:k,validator:j});if(V)Q+=P3?"c.headers = c.request.headers.toJSON()\n":`c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;if(O){const z=(N,C)=>{const S=L?.[N]??C;if(!S)return typeof C==="string"?`${N}: "${C}",`:`${N}: ${C},`;if(typeof S==="string")return`${N}: '${S}',`;if(S instanceof Date)return`${N}: new Date(${S.getTime()}),`;return`${N}: ${S},`},F=L?`{
			secrets: ${L.secrets!==void 0?typeof L.secrets==="string"?`'${L.secrets}'`:"["+L.secrets.reduce((N,C)=>N+`'${C}',`,"")+"]":"undefined"},
			sign: ${L.sign===!0?!0:L.sign!==void 0?"["+L.sign.reduce((N,C)=>N+`'${C}',`,"")+"]":"undefined"},
			${z("domain")}
			${z("expires")}
			${z("httpOnly")}
			${z("maxAge")}
			${z("path","/")}
			${z("priority")}
			${z("sameSite")}
			${z("secure")}
		}`:"undefined";if(V)Q+=`\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${F})\n`;else Q+=`\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${F})\n`}if(_){const z=[];if(j.query&&j.query.schema.type==="object"){const F=j.query.schema.properties;if(!X0(j.query))for(let[N,C]of Object.entries(F)){let S=C;if(S&&_2.optional in S&&S.type==="array"&&S.items)S=S.items;const{type:T,anyOf:t}=S,g0=T==="array"||t?.some((l)=>l.type==="string"&&l.format==="ArrayString");z.push({key:N,isArray:g0,isNestedObjectArray:g0&&(S.items?.type==="object"||!!t?.length)||!!S.items?.anyOf,isObject:T==="object"||t?.some((l)=>l.type==="string"&&l.format==="ArrayString"),anyOf:!!t})}}if(!z.length)Q+=`if(c.qi === -1) {
				c.query = {}
			} else {
				c.query = parseQuery(c.url.slice(c.qi + 1))
			}`;else Q+=`if(c.qi !== -1) {
				let url = '&' + c.url.slice(c.qi + 1)

				${z.map(({key:F,isArray:N,isObject:C,isNestedObjectArray:S},T)=>{const t=`${T===0?"let":""} memory = url.indexOf('&${F}=')
							let a${T}\n`;if(N)return t+(S?`while (memory !== -1) {
											const start = memory + ${F.length+2}
											memory = url.indexOf('&', start)

											if(a${T} === undefined)
												a${T} = ''
											else
												a${T} += ','

											let temp

											if(memory === -1) temp = decodeURIComponent(url.slice(start))
											else temp = decodeURIComponent(url.slice(start, memory))

											const charCode = temp.charCodeAt(0)
											if(charCode !== 91 && charCode !== 123)
												temp = '"' + temp + '"'

											a${T} += temp
										}

										try {
										    if(a${T}.charCodeAt(0) === 91)
												a${T} = JSON.parse(a${T})
											else
												a${T} = JSON.parse('[' + a${T} + ']')
										} catch {}\n`:`while (memory !== -1) {
											const start = memory + ${F.length+2}
											memory = url.indexOf('&', start)

											if(a${T} === undefined)
												a${T} = []

											if(memory === -1) a${T}.push(decodeURIComponent(url.slice(start)))
											else a${T}.push(decodeURIComponent(url.slice(start, memory)))
										}\n`);if(C)return t+`if (memory !== -1) {
										const start = memory + ${F.length+2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${T} = decodeURIComponent(url.slice(start))
										else a${T} = decodeURIComponent(url.slice(start, memory))

										if (a${T} !== undefined) {
											try {
												a${T} = JSON.parse(a${T})
											} catch {}
										}
									}`;return t+`if (memory !== -1) {
										const start = memory + ${F.length+2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${T} = decodeURIComponent(url.slice(start))
										else {
											a${T} = decodeURIComponent(url.slice(start, memory))

											let deepMemory = url.indexOf('&${F}=', memory)

											if(deepMemory !== -1) {
												a${T} = [a${T}]
												let first = true

												while(true) {
													const start = deepMemory + ${F.length+2}
													if(first)
														first = false
													else
														deepMemory = url.indexOf('&', start)

													let value
													if(deepMemory === -1) value = decodeURIComponent(url.slice(start))
													else value = decodeURIComponent(url.slice(start, deepMemory))

													const vStart = value.charCodeAt(0)
													const vEnd = value.charCodeAt(value.length - 1)

													if((vStart === 91 && vEnd === 93) || (vStart === 123 && vEnd === 125))
														try {
															a${T}.push(JSON.parse(value))
														} catch {
														 	a${T}.push(value)
														}

													if(deepMemory === -1) break
												}
											}
										}
									}`}).join("\n")}

				c.query = {
					${z.map(({key:F},N)=>`'${F}': a${N}`).join(", ")}
				}
			} else {
				c.query = {}
			}`}if(D)Q+="\nconst id = c[ELYSIA_REQUEST_ID]\n";const b=q1({trace:J.trace,addFn:(z)=>{Q+=z}});Q+="\ntry {\n";const W0=typeof G==="function"&&g(G),r=D||J.afterResponse.length>0?"c.response = ":"",x0=O||P||W0||J.parse.length>0||J.afterHandle.some(g)||J.beforeHandle.some(g)||J.transform.some(g)||J.mapResponse.some(g),M2=(typeof G==="function"?Q1(G):!1)||J.beforeHandle.some(Q1)||J.afterHandle.some(Q1)||J.transform.some(Q1),p0=K.cookie||K.set||V||D||j.response||B&&I||M2,n=", c.request";Q+=`c.route = \`${X}\`\n`;const z2=b("parse",{total:J.parse.length});if(P){const z=J.parse.length||K.body||j.body;if(Q+="isParsing = true\n",J.type&&!J.parse.length)switch(J.type){case"json":case"application/json":Q+="c.body = await c.request.json()";break;case"text":case"text/plain":Q+="c.body = await c.request.text()\n";break;case"urlencoded":case"application/x-www-form-urlencoded":Q+="c.body = parseQuery(await c.request.text())\n";break;case"arrayBuffer":case"application/octet-stream":Q+="c.body = await c.request.arrayBuffer()\n";break;case"formdata":case"multipart/form-data":Q+=`c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;break}else if(z){if(Q+="\n",Q+=V?"let contentType = c.headers['content-type']":"let contentType = c.request.headers.get('content-type')",Q+=`
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n
					c.contentType = contentType\n`,J.parse.length){Q+="let used = false\n";const F=b("parse",{total:J.parse.length});for(let N=0;N<J.parse.length;N++){const C=F.resolveChild(J.parse[N].fn.name),S=`bo${N}`;if(N!==0)Q+="if(!used) {\n";if(Q+=`let ${S} = parse[${N}](c, contentType)\n`,Q+=`if(${S} instanceof Promise) ${S} = await ${S}\n`,Q+=`if(${S} !== undefined) { c.body = ${S}; used = true }\n`,C(),N!==0)Q+="}"}F.resolve()}if(Q+="\ndelete c.contentType\n",J.parse.length)Q+="if (!used) {";if(J.type&&!Array.isArray(J.type))switch(J.type){case"json":case"application/json":Q+="c.body = await c.request.json()";break;case"text":case"text/plain":Q+="c.body = await c.request.text()\n";break;case"urlencoded":case"application/x-www-form-urlencoded":Q+="c.body = parseQuery(await c.request.text())\n";break;case"arrayBuffer":case"application/octet-stream":Q+="c.body = await c.request.arrayBuffer()\n";break;case"formdata":case"multipart/form-data":Q+=`c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}\n`;break}else Q+=`
					switch (contentType) {
						case 'application/json':
							c.body = await c.request.json()
							break

						case 'text/plain':
							c.body = await c.request.text()
							break

						case 'application/x-www-form-urlencoded':
							c.body = parseQuery(await c.request.text())
							break

						case 'application/octet-stream':
							c.body = await c.request.arrayBuffer();
							break

						case 'multipart/form-data':
							c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}

							break
					}`;if(J.parse.length)Q+="}";Q+="}\n"}Q+="\nisParsing = false\n"}if(z2.resolve(),J?.transform){const z=b("transform",{total:J.transform.length});if(J.transform.length)Q+="\nlet transformed\n";for(let F=0;F<J.transform.length;F++){const N=J.transform[F],C=z.resolveChild(N.fn.name);if(Q+=g(N)?`transformed = await transform[${F}](c)\n`:`transformed = transform[${F}](c)\n`,N.subType==="mapDerive")Q+=`if(transformed?.[ELYSIA_RESPONSE])
					throw transformed
				else {
					transformed.request = c.request
					transformed.store = c.store
					transformed.qi = c.qi
					transformed.path = c.path
					transformed.url = c.url
					transformed.redirect = c.redirect
					transformed.set = c.set
					transformed.error = c.error

					c = transformed
			}`;else Q+=`if(transformed?.[ELYSIA_RESPONSE])
					throw transformed
				else
					Object.assign(c, transformed)\n`;C()}z.resolve()}if(j){if(Q+="\n",j.headers){if(k&&"Clean"in j.headers&&!X0(j.headers))Q+="c.headers = validator.headers.Clean(c.headers);\n";if(V0("default",j.headers.schema))for(let[z,F]of Object.entries(l0.Default(j.headers.schema,{}))){const N=typeof F==="object"?JSON.stringify(F):typeof F==="string"?`'${F}'`:F;if(N!==void 0)Q+=`c.headers['${z}'] ??= ${N}\n`}if(K0(j.headers))Q+="if(isNotEmpty(c.headers)) {";if(Q+=`if(validator.headers.Check(c.headers) === false) {
				${R("headers")}
			}`,O0(j.headers.schema))Q+="c.headers = validator.headers.Decode(c.headers)\n";if(K0(j.headers))Q+="}"}if(j.params){if(V0("default",j.params.schema))for(let[z,F]of Object.entries(l0.Default(j.params.schema,{}))){const N=typeof F==="object"?JSON.stringify(F):typeof F==="string"?`'${F}'`:F;if(N!==void 0)Q+=`c.params['${z}'] ??= ${N}\n`}if(Q+=`if(validator.params.Check(c.params) === false) {
				${R("params")}
			}`,O0(j.params.schema))Q+="\nc.params = validator.params.Decode(c.params)\n"}if(j.query){if(k&&"Clean"in j.query&&!X0(j.query))Q+="c.query = validator.query.Clean(c.query);\n";if(V0("default",j.query.schema))for(let[z,F]of Object.entries(l0.Default(j.query.schema,{}))){const N=typeof F==="object"?JSON.stringify(F):typeof F==="string"?`'${F}'`:F;if(N!==void 0)Q+=`if(c.query['${z}'] === undefined) c.query['${z}'] = ${N}\n`}if(K0(j.query))Q+="if(isNotEmpty(c.query)) {";if(Q+=`if(validator.query.Check(c.query) === false) {
          		${R("query")}
			}`,O0(j.query.schema))Q+="\nc.query = validator.query.Decode(Object.assign({}, c.query))\n";if(K0(j.query))Q+="}"}if(j.body){if(k&&"Clean"in j.body&&!X0(j.body))Q+="c.body = validator.body.Clean(c.body);\n";const z=O0(j.body.schema);if(z||K0(j.body))Q+='\nconst isNotEmptyObject = c.body && (typeof c.body === "object" && isNotEmpty(c.body))\n';if(V0("default",j.body.schema)){const F=l0.Default(j.body.schema,j.body.schema.type==="object"?{}:void 0),N=typeof F==="object"?JSON.stringify(F):typeof F==="string"?`'${F}'`:F;if(Q+=`if(validator.body.Check(c.body) === false) {
					if (typeof c.body === 'object') {
						c.body = Object.assign(${N}, c.body)
					} else { c.body = ${N} }`,K0(j.body))Q+=`
					    if(isNotEmptyObject && validator.body.Check(c.body) === false) {
            				${R("body")}
             			}
                    }`;else Q+=`
    				if(validator.body.Check(c.body) === false) {
        				${R("body")}
         			}
                }`}else if(K0(j.body))Q+=`if(isNotEmptyObject && validator.body.Check(c.body) === false) {
         			${R("body")}
          		}`;else Q+=`if(validator.body.Check(c.body) === false) {
         			${R("body")}
          		}`;if(z)Q+="\nif(isNotEmptyObject) c.body = validator.body.Decode(c.body)\n"}if(p(q?.schema?.properties??q?.schema?.schema??{})){if(Q+=`const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value\n`,V0("default",q.schema))for(let[z,F]of Object.entries(l0.Default(q.schema,{})))Q+=`cookieValue['${z}'] = ${typeof F==="object"?JSON.stringify(F):F}\n`;if(K0(j.cookie))Q+="if(isNotEmpty(c.cookie)) {";if(Q+=`if(validator.cookie.Check(cookieValue) === false) {
				${R("cookie","cookieValue")}
			}`,O0(j.cookie.schema))Q+=`\nfor(const [key, value] of Object.entries(validator.cookie.Decode(cookieValue)))
					c.cookie[key].value = value\n`;if(K0(j.cookie))Q+="}"}}if(J?.beforeHandle){const z=b("beforeHandle",{total:J.beforeHandle.length});let F=!1;for(let N=0;N<J.beforeHandle.length;N++){const C=J.beforeHandle[N],S=z.resolveChild(C.fn.name),T=q0(C);if(C.subType==="resolve"||C.subType==="mapResolve"){if(!F)F=!0,Q+="\nlet resolved\n";if(Q+=g(C)?`resolved = await beforeHandle[${N}](c);\n`:`resolved = beforeHandle[${N}](c);\n`,C.subType==="mapResolve")Q+=`if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else {
						resolved.request = c.request
						resolved.store = c.store
						resolved.qi = c.qi
						resolved.path = c.path
						resolved.url = c.url
						resolved.redirect = c.redirect
						resolved.set = c.set
						resolved.error = c.error

						c = resolved
					}`;else Q+=`if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else
						Object.assign(c, resolved)\n`}else if(!T)Q+=g(C)?`await beforeHandle[${N}](c);\n`:`beforeHandle[${N}](c);\n`,S();else{if(Q+=g(C)?`be = await beforeHandle[${N}](c);\n`:`be = beforeHandle[${N}](c);\n`,S("be"),Q+="if(be !== undefined) {\n",z.resolve(),J.afterHandle?.length){b("handle",{name:B?G.name:void 0}).resolve();const l=b("afterHandle",{total:J.afterHandle.length});for(let J0=0;J0<J.afterHandle.length;J0++){const C0=J.afterHandle[J0],P2=q0(C0),N2=l.resolveChild(C0.fn.name);if(Q+="c.response = be\n",!P2)Q+=g(C0.fn)?`await afterHandle[${J0}](c, be)\n`:`afterHandle[${J0}](c, be)\n`;else Q+=g(C0.fn)?`af = await afterHandle[${J0}](c)\n`:`af = afterHandle[${J0}](c)\n`,Q+="if(af !== undefined) { c.response = be = af }\n";N2("af")}l.resolve()}if(j.response)Q+=U0("be");const g0=b("mapResponse",{total:J.mapResponse.length});if(J.mapResponse.length){Q+="\nc.response = be\n";for(let l=0;l<J.mapResponse.length;l++){const J0=J.mapResponse[l],C0=g0.resolveChild(J0.fn.name);Q+=`\nif(mr === undefined) {
							mr = ${A0(J0)?"await":""} onMapResponse[${l}](c)
							if(mr !== undefined) be = c.response = mr
						}\n`,C0()}}g0.resolve(),Q+=E,Q+=`return mapEarlyResponse(${r} be, c.set ${n})}\n`}}z.resolve()}if(J?.afterHandle.length){const z=b("handle",{name:B?G.name:void 0});if(J.afterHandle.length)Q+=W0?`let r = c.response = await ${U};\n`:`let r = c.response = ${U};\n`;else Q+=W0?`let r = await ${U};\n`:`let r = ${U};\n`;z.resolve();const F=b("afterHandle",{total:J.afterHandle.length});for(let C=0;C<J.afterHandle.length;C++){const S=J.afterHandle[C],T=q0(S),t=F.resolveChild(S.fn.name);if(!T)Q+=g(S.fn)?`await afterHandle[${C}](c)\n`:`afterHandle[${C}](c)\n`,t();else if(Q+=g(S.fn)?`af = await afterHandle[${C}](c)\n`:`af = afterHandle[${C}](c)\n`,t("af"),j.response)Q+="if(af !== undefined) {",F.resolve(),Q+=U0("af"),Q+="c.response = af }";else Q+="if(af !== undefined) {",F.resolve(),Q+="c.response = af}\n"}if(F.resolve(),Q+="r = c.response\n",j.response)Q+=U0();Q+=E;const N=b("mapResponse",{total:J.mapResponse.length});if(J.mapResponse.length)for(let C=0;C<J.mapResponse.length;C++){const S=J.mapResponse[C],T=N.resolveChild(S.fn.name);Q+=`\nmr = ${A0(S)?"await":""} onMapResponse[${C}](c)
				if(mr !== undefined) r = c.response = mr\n`,T()}if(N.resolve(),p0)Q+=`return mapResponse(${r} r, c.set ${n})\n`;else Q+=`return mapCompactResponse(${r} r ${n})\n`}else{const z=b("handle",{name:B?G.name:void 0});if(j.response||J.mapResponse.length){if(Q+=W0?`let r = await ${U};\n`:`let r = ${U};\n`,z.resolve(),j.response)Q+=U0();b("afterHandle").resolve();const F=b("mapResponse",{total:J.mapResponse.length});if(J.mapResponse.length){Q+="\nc.response = r\n";for(let N=0;N<J.mapResponse.length;N++){const C=J.mapResponse[N],S=F.resolveChild(C.fn.name);Q+=`\nif(mr === undefined) {
						mr = ${A0(C)?"await":""} onMapResponse[${N}](c)
    					if(mr !== undefined) r = c.response = mr
					}\n`,S()}}if(F.resolve(),Q+=E,G instanceof Response)Q+=K.set?`if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${r} ${U}.clone(), c.set ${n})
				else
					return ${U}.clone()`:`return ${U}.clone()`,Q+="\n";else if(p0)Q+=`return mapResponse(${r} r, c.set ${n})\n`;else Q+=`return mapCompactResponse(${r} r ${n})\n`}else if(O||D){Q+=W0?`let r = await ${U};\n`:`let r = ${U};\n`,z.resolve(),b("afterHandle").resolve();const F=b("mapResponse",{total:J.mapResponse.length});if(J.mapResponse.length){Q+="\nc.response = r\n";for(let N=0;N<J.mapResponse.length;N++){const C=J.mapResponse[N],S=F.resolveChild(C.fn.name);Q+=`\nif(mr === undefined) {
							mr = ${A0(C)?"await":""} onMapResponse[${N}](c)
    						if(mr !== undefined) r = c.response = mr
						}\n`,S()}}if(F.resolve(),Q+=E,p0)Q+=`return mapResponse(${r} r, c.set ${n})\n`;else Q+=`return mapCompactResponse(${r} r ${n})\n`}else{z.resolve();const F=W0?`await ${U}`:U;if(b("afterHandle").resolve(),G instanceof Response)Q+=K.set?`if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${r} ${U}.clone(), c.set ${n})
				else
					return ${U}.clone()`:`return ${U}.clone()`,Q+="\n";else if(p0)Q+=`return mapResponse(${r} ${F}, c.set ${n})\n`;else Q+=`return mapCompactResponse(${r} ${F} ${n})\n`}}if(Q+="\n} catch(error) {",P)Q+="\nif(isParsing) error = new ParseError()\n";if(!x0)Q+="\nreturn (async () => {\n";if(Q+="\nconst set = c.set\nif (!set.status || set.status < 300) set.status = error?.status || 500\n",D)for(let z=0;z<J.trace.length;z++)Q+=`report${z}?.resolve(error);reportChild${z}?.(error);\n`;const G1=b("error",{total:J.error.length});if(J.error.length){Q+=`
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
				let er
			`;for(let z=0;z<J.error.length;z++){const F=G1.resolveChild(J.error[z].fn.name);if(g(J.error[z]))Q+=`\ner = await handleErrors[${z}](c)\n`;else Q+=`\ner = handleErrors[${z}](c)\nif (er instanceof Promise) er = await er\n`;F();const N=b("mapResponse",{total:J.mapResponse.length});if(J.mapResponse.length)for(let C=0;C<J.mapResponse.length;C++){const S=J.mapResponse[C],T=N.resolveChild(S.fn.name);Q+=`\nc.response = er\n
							er = ${A0(S)?"await":""} onMapResponse[${C}](c)
							if(er instanceof Promise) er = await er\n`,T()}if(N.resolve(),Q+=`er = mapEarlyResponse(er, set ${n})\n`,Q+="if (er) {",D){for(let C=0;C<J.trace.length;C++)Q+=`\nreport${C}.resolve()\n`;G1.resolve()}Q+="return er\n}\n"}}if(G1.resolve(),Q+="return handleError(c, error, true)\n",!x0)Q+="})()";if(Q+="}",w||D){if(Q+=" finally { ",!x0)Q+=";(async () => {";const z=b("afterResponse",{total:J.afterResponse.length});if(w)for(let F=0;F<J.afterResponse.length;F++){const N=z.resolveChild(J.afterResponse[F].fn.name);Q+=`\nawait afterResponse[${F}](c);\n`,N()}if(z.resolve(),!x0)Q+="})();";Q+="}"}Q=`const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			afterResponse,
			trace: _trace
		},
		validator,
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery,
			isNotEmpty
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError,
			ParseError
		},
		schema,
		definitions,
		ERROR_CODE,
		parseCookie,
		signCookie,
		decodeURIComponent,
		ELYSIA_RESPONSE,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer
	} = hooks

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)

	return ${x0?"async":""} function handle(c) {
		${J.beforeHandle.length?"let be":""}
		${J.afterHandle.length?"let af":""}
		${J.mapResponse.length?"let mr":""}

		${Y?"c.schema = schema; c.defs = definitions":""}
		${Q}
	}`;try{return Function("hooks",Q)({handler:G,hooks:I1(J),validator:j,handleError:$.handleError,utils:{mapResponse:f,mapCompactResponse:e,mapEarlyResponse:y,parseQuery:b0,isNotEmpty:p},error:{NotFoundError:I0,ValidationError:H,InternalServerError:J1,ParseError:j1},schema:$.router.history,definitions:$.definitions.type,ERROR_CODE:N0,parseCookie:r0,signCookie:E0,decodeURIComponent:w2.default,ELYSIA_RESPONSE:m,ELYSIA_TRACE:c0,ELYSIA_REQUEST_ID:P0,getServer:()=>$.getServer()})}catch{const z=I1(J);console.log("[Composer] failed to generate optimized handler"),console.log("Please report the following to SaltyAom privately as it may include sensitive information about your codebase:"),console.log("---"),console.log({handler:typeof G==="function"?G.toString():G,hooks:{...z,transform:z?.transform?.map?.((F)=>F.toString()),resolve:z?.resolve?.map?.((F)=>F.toString()),beforeHandle:z?.beforeHandle?.map?.((F)=>F.toString()),afterHandle:z?.afterHandle?.map?.((F)=>F.toString()),mapResponse:z?.mapResponse?.map?.((F)=>F.toString()),parse:z?.parse?.map?.((F)=>F.toString()),error:z?.error?.map?.((F)=>F.toString()),afterResponse:z?.afterResponse?.map?.((F)=>F.toString()),stop:z?.stop?.map?.((F)=>F.toString())},validator:j,definitions:$.definitions.type}),console.log("---"),process.exit(1)}},L1=($)=>{let X="",Z="";const W=$.setHeaders;for(let _ of Object.keys($.singleton.decorator))X+=`,${_}: app.singleton.decorator.${_}`;const J=$.router,j=$.event.trace.length>0;let G=`
	const route = router.find(request.method, path) ${J.http.root.ALL?'?? router.find("ALL", path)':""}

	if (route === null)
		return ${$.event.error.length?"app.handleError(ctx, notFound)":$.event.request.length?`new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`:"error404.clone()"}

	ctx.params = route.params\n`;G+=`if(route.store.handler) return route.store.handler(ctx)
	return (route.store.handler = route.store.compile())(ctx)\n`;let Y="";for(let[_,{code:P,all:M}]of Object.entries(J.static.http.map))Y+=`case '${_}':\nswitch(request.method) {\n${P}\n${M??"default: break map"}}\n\n`;const K=$.event.request.some(g);if(Z+=`const {
		app,
		mapEarlyResponse,
		NotFoundError,
		randomId,
		handleError,
		error,
		redirect,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer
	} = data

	const store = app.singleton.store
	const staticRouter = app.router.static.http
	const st = staticRouter.handlers
	const wsRouter = app.router.ws
	const router = app.router.http
	const trace = app.event.trace.map(x => typeof x === 'function' ? x : x.fn)

	const notFound = new NotFoundError()
	const hoc = app.extender.higherOrderFunctions.map(x => x.fn)

	${$.event.request.length?"const onRequest = app.event.request.map(x => x.fn)":""}
	${$.event.error.length?"":`\nconst error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });\n`}

	${$.event.trace.length?`const ${$.event.trace.map((_,P)=>`tr${P} = app.event.trace[${P}].fn`).join(",")}`:""}

	${K?"async":""} function map(request) {\n`,$.event.request.length)Z+="let re";if(Z+=`\nconst url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		let path
		if(qi === -1)
			path = url.substring(s)
		else
			path = url.substring(s, qi)\n`,Z+=`${j?"const id = randomId()":""}
		const ctx = {
			request,
			store,
			qi,
			path,
			url,
			redirect,
			set: {
				headers: ${Object.keys(W??{}).length?"Object.assign({}, app.setHeaders)":"{}"},
				status: 200
			},
			error
			${$.inference.server?`, get server() {
							return getServer()
						}`:""}
			${j?",[ELYSIA_REQUEST_ID]: id":""}
			${X}
		}\n`,$.event.trace.length)Z+=`\nctx[ELYSIA_TRACE] = [${$.event.trace.map((_,P)=>`tr${P}(ctx)`).join(",")}]\n`;const U=q1({context:"ctx",trace:$.event.trace,addFn:(_)=>{Z+=_}})("request",{attribute:"ctx",total:$.event.request.length});if($.event.request.length){Z+="\n try {\n";for(let _=0;_<$.event.request.length;_++){const P=$.event.request[_],M=q0(P),I=g(P),V=U.resolveChild($.event.request[_].fn.name);if(M)Z+=`re = mapEarlyResponse(
					${I?"await":""} onRequest[${_}](ctx),
					ctx.set,
					request
				)\n`,V("re"),Z+="if(re !== undefined) return re\n";else Z+=`${I?"await":""} onRequest[${_}](ctx)\n`,V()}Z+=`} catch (error) {
			return app.handleError(ctx, error)
		}`}U.resolve();const w=$.router.static.ws,D=$.router.ws;if(Object.keys(w).length||D.history.length){Z+=`
			if(request.method === 'GET') {
				switch(path) {`;for(let[_,P]of Object.entries(w))Z+=`
					case '${_}':
						if(request.headers.get('upgrade') === 'websocket')
							return st[${P}](ctx)

						break`;Z+=`
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							if(route.store.handler)
							    return route.store.handler(ctx)

							return (route.store.handler = route.store.compile())(ctx)
						}
					}

					break
			}
		}\n`}if(Z+=`
		map: switch(path) {
			${Y}

			default:
				break
		}

		${G}
	}\n`,$.extender.higherOrderFunctions.length){let _="map";for(let P=0;P<$.extender.higherOrderFunctions.length;P++)_=`hoc[${P}](${_}, request)`;Z+=`return function hocMap(request) { return ${_}(request) }`}else Z+="return map";const Q=T1($);return $.handleError=Q,Function("data",Z)({app:$,mapEarlyResponse:y,NotFoundError:I0,randomId:Z1,handleError:Q,error:V1,redirect:h0,ELYSIA_TRACE:c0,ELYSIA_REQUEST_ID:P0,getServer:()=>$.getServer()})},T1=($)=>{const X=$.event;let Z="";Z+=`const {
		app: { event: { error: onErrorContainer, afterResponse: resContainer, mapResponse: _onMapResponse, trace: _trace } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID
	} = inject

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)
	const onMapResponse = []

	for(let i = 0; i < _onMapResponse.length; i++)
		onMapResponse.push(_onMapResponse[i].fn ?? _onMapResponse[i])

	delete _onMapResponse

	const onError = onErrorContainer.map(x => x.fn)
	const res = resContainer.map(x => x.fn)

	return ${$.event.error.find(g)||$.event.mapResponse.find(g)?"async":""} function(context, error, skipGlobal) {`;const W=$.event.trace.length>0;if(W)Z+="\nconst id = context[ELYSIA_REQUEST_ID]\n";const J=q1({context:"context",trace:X.trace,addFn:(Y)=>{Z+=Y}});Z+=`
		const set = context.set
		let r

		context.code = error.code
		context.error = error

		if(typeof error === "object" && error && ELYSIA_RESPONSE in error) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}\n`;const j=W||X.afterResponse.length>0||X.afterResponse.length>0?"context.response = ":"";for(let Y=0;Y<$.event.error.length;Y++){const K=$.event.error[Y],B=`${g(K)?"await ":""}onError[${Y}](context)`;if(Z+="\nif(skipGlobal !== true) {\n",q0(K)){Z+=`r = ${B}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}

				if(set.status === 200) set.status = error.status\n`;const U=J("mapResponse",{total:X.mapResponse.length,name:"context"});if(X.mapResponse.length)for(let w=0;w<X.mapResponse.length;w++){const D=X.mapResponse[w],Q=U.resolveChild(D.fn.name);Z+=`\ncontext.response = r
						r = ${A0(D)?"await":""} onMapResponse[${w}](context)\n`,Q()}U.resolve(),Z+=`return mapResponse(${j} r, set, context.request)}\n`}else Z+=B+"\n";Z+="\n}\n"}Z+=`if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 422
		return new Response(
			error.message,
			{
				headers: Object.assign(
					{ 'content-type': 'application/json'},
					set.headers
				),
				status: set.status
			}
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)\n`;const G=J("mapResponse",{total:X.mapResponse.length,name:"context"});if(X.mapResponse.length)for(let Y=0;Y<X.mapResponse.length;Y++){const K=X.mapResponse[Y],B=G.resolveChild(K.fn.name);Z+=`\ncontext.response = error
			error = ${A0(K)?"await":""} onMapResponse[${Y}](context)\n`,B()}return G.resolve(),Z+=`\nreturn mapResponse(${j} error, set, context.request)\n}\n}`,Function("inject",Z)({app:$,mapResponse:f,ERROR_CODE:N0,ELYSIA_RESPONSE:m,ELYSIA_TRACE:c0,ELYSIA_REQUEST_ID:P0})};var H1=($)=>async(X)=>{const Z=X.url,W=Z.indexOf("/",11),J=Z.indexOf("?",W+1),j=J===-1?Z.substring(W):Z.substring(W,J),G={cookie:{},status:200,headers:{}},Y=Object.assign({},$.singleton.decorator,{set:G,store:$.singleton.store,request:X,path:j,qi:J,redirect:h0});try{for(let I=0;I<$.event.request.length;I++){const V=$.event.request[I].fn;let O=V(Y);if(O instanceof Promise)O=await O;if(O=y(O,G),O)return Y.response=O}const K=$.router.dynamic.find(X.method,j)??$.router.dynamic.find("ALL",j);if(!K)throw new I0;const{handle:B,hooks:U,validator:w,content:D}=K.store;let Q;if(X.method!=="GET"&&X.method!=="HEAD")if(D)switch(D){case"application/json":Q=await X.json();break;case"text/plain":Q=await X.text();break;case"application/x-www-form-urlencoded":Q=b0(await X.text());break;case"application/octet-stream":Q=await X.arrayBuffer();break;case"multipart/form-data":Q={};const I=await X.formData();for(let V of I.keys()){if(Q[V])continue;const O=I.getAll(V);if(O.length===1)Q[V]=O[0];else Q[V]=O}break}else{let I=X.headers.get("content-type");if(I){const V=I.indexOf(";");if(V!==-1)I=I.slice(0,V);Y.contentType=I;for(let O=0;O<U.parse.length;O++){const q=U.parse[O].fn;let L=q(Y,I);if(L instanceof Promise)L=await L;if(L){Q=L;break}}if(delete Y.contentType,Q===void 0)switch(I){case"application/json":Q=await X.json();break;case"text/plain":Q=await X.text();break;case"application/x-www-form-urlencoded":Q=b0(await X.text());break;case"application/octet-stream":Q=await X.arrayBuffer();break;case"multipart/form-data":Q={};const O=await X.formData();for(let q of O.keys()){if(Q[q])continue;const L=O.getAll(q);if(L.length===1)Q[q]=L[0];else Q[q]=L}break}}}Y.body=Q,Y.params=K?.params||void 0,Y.query=J===-1?{}:b0(Z.substring(J+1)),Y.headers={};for(let[I,V]of X.headers.entries())Y.headers[I]=V;const _=Object.assign({},$.config?.cookie,w?.cookie?.config),P=X.headers.get("cookie");Y.cookie=await r0(Y.set,P,_?{secrets:_.secrets!==void 0?typeof _.secrets==="string"?_.secrets:_.secrets.join(","):void 0,sign:_.sign===!0?!0:_.sign!==void 0?typeof _.sign==="string"?_.sign:_.sign.join(","):void 0}:void 0);for(let I=0;I<U.transform.length;I++){const V=U.transform[I],O=V.fn(Y);if(V.subType==="derive")if(O instanceof Promise)Object.assign(Y,await O);else Object.assign(Y,O);else if(O instanceof Promise)await O}if(w){if(w.createHeaders?.()){const I={};for(let V in X.headers)I[V]=X.headers.get(V);if(w.headers.Check(I)===!1)throw new H("header",w.headers,I)}if(w.createParams?.()?.Check(Y.params)===!1)throw new H("params",w.params,Y.params);if(w.createQuery?.()?.Check(Y.query)===!1)throw new H("query",w.query,Y.query);if(w.createCookie?.()){const I={};for(let[V,O]of Object.entries(Y.cookie))I[V]=O.value;if(w.cookie.Check(I)===!1)throw new H("cookie",w.cookie,I)}if(w.createBody?.()?.Check(Q)===!1)throw new H("body",w.body,Q)}for(let I=0;I<U.beforeHandle.length;I++){let V=U.beforeHandle[I].fn(Y);if(V instanceof Promise)V=await V;if(V!==void 0){Y.response=V;for(let q=0;q<U.afterHandle.length;q++){let L=U.afterHandle[q].fn(Y);if(L instanceof Promise)L=await L;if(L)V=L}const O=y(V,Y.set);if(O)return Y.response=O}}let M=B(Y);if(M instanceof Promise)M=await M;if(!U.afterHandle.length){const I=M[m]??(G.status?typeof G.status==="string"?Y0[G.status]:G.status:200),V=w?.createResponse?.()?.[I];if(V?.Check(M)===!1)throw new H("response",V,M)}else{Y.response=M;for(let I=0;I<U.afterHandle.length;I++){let V=U.afterHandle[I].fn(Y);if(V instanceof Promise)V=await V;const O=y(V,Y.set);if(O!==void 0){const q=w?.response?.[O.status];if(q?.Check(O)===!1)throw new H("response",q,O);return Y.response=O}}}if(Y.set.cookie&&_?.sign){const I=!_.secrets?void 0:typeof _.secrets==="string"?_.secrets:_.secrets[0];if(_.sign===!0)for(let[V,O]of Object.entries(Y.set.cookie))Y.set.cookie[V].value=await E0(O.value,"${secret}");else{const V=w?.cookie?.schema?.properties;for(let O of _.sign){if(!(O in V))continue;if(Y.set.cookie[O]?.value)Y.set.cookie[O].value=await E0(Y.set.cookie[O].value,I)}}}return Y.response=f(M,Y.set)}catch(K){if(K.status)G.status=K.status;return $.handleError(Y,K)}finally{for(let K of $.event.afterResponse)await K.fn(Y)}},D2=($)=>async(X,Z)=>{const W=Object.assign(X,{error:Z,code:Z.code});W.set=X.set;for(let J=0;J<$.event.error.length;J++){let G=$.event.error[J].fn(W);if(G instanceof Promise)G=await G;if(G!==void 0&&G!==null)return X.response=f(G,X.set)}return new Response(typeof Z.cause==="string"?Z.cause:Z.message,{headers:X.set.headers,status:Z.status??500})};class Z0{config;server=null;dependencies={};_routes={};_types={Prefix:"",Scoped:!1,Singleton:{},Definitions:{},Metadata:{}};_ephemeral={};_volatile={};static version=A1;version=A1;singleton={decorator:{},store:{},derive:{},resolve:{}};get store(){return this.singleton.store}get decorator(){return this.singleton.decorator}get _scoped(){return this.config.scoped}definitions={type:{},error:{}};extender={macros:[],higherOrderFunctions:[]};validator={global:null,scoped:null,local:null,getCandidate(){return H0(H0(this.global,this.scoped),this.local)}};event={start:[],request:[],parse:[],transform:[],beforeHandle:[],afterHandle:[],mapResponse:[],afterResponse:[],trace:[],error:[],stop:[]};telemetry={stack:void 0};router={http:new w0,ws:new w0,dynamic:new w0,static:{http:{handlers:[],map:{},all:""},ws:{}},history:[]};routeTree=new Map;get routes(){return this.router.history}getGlobalRoutes(){return this.router.history}inference={body:!1,cookie:!1,headers:!1,query:!1,set:!1,server:!1};getServer(){return this.server}_promisedModules;get promisedModules(){if(!this._promisedModules)this._promisedModules=new N1;return this._promisedModules}constructor($){if($?.tags)if(!$.detail)$.detail={tags:$.tags};else $.detail.tags=$.tags;if(this.config={},this.applyConfig($??{}),$?.analytic&&($?.name||$?.seed!==void 0))this.telemetry.stack=new Error().stack}env($,X=Bun?.env??process.env){if(h($,{dynamic:!0,additionalProperties:!0,coerce:!0}).Check(X)===!1){const W=new H("env",$,X);throw new Error(W.all.map((J)=>J.summary).join("\n"))}return this}wrap($){return this.extender.higherOrderFunctions.push({checksum:z0(JSON.stringify({name:this.config.name,seed:this.config.seed,content:$.toString()})),fn:$}),this}applyMacro($){if(this.extender.macros.length){const X=G2({globalHook:this.event,localHook:$}),Z={events:{global:this.event,local:$},onParse:X("parse"),onTransform:X("transform"),onBeforeHandle:X("beforeHandle"),onAfterHandle:X("afterHandle"),mapResponse:X("mapResponse"),onAfterResponse:X("afterResponse"),onError:X("error")};for(let W of this.extender.macros)Q2(W.fn(Z),$)}}applyConfig($){return this.config={prefix:"",aot:!0,strictPath:!1,global:!1,analytic:!1,normalize:!0,...$,cookie:{path:"/",...$?.cookie},experimental:$?.experimental??{},seed:$?.seed===void 0?"":$?.seed},this}get models(){const $={};for(let[X,Z]of Object.entries(this.definitions.type))$[X]=h(Z);return $}add($,X,Z,W,{allowMeta:J=!1,skipPrefix:j=!1}={allowMeta:!1,skipPrefix:!1}){if(W=Y2(W),X!==""&&X.charCodeAt(0)!==47)X="/"+X;if(this.config.prefix&&!j&&!this.config.scoped)X=this.config.prefix+X;if(W?.type)switch(W.type){case"text":W.type="text/plain";break;case"json":W.type="application/json";break;case"formdata":W.type="multipart/form-data";break;case"urlencoded":W.type="application/x-www-form-urlencoded";break;case"arrayBuffer":W.type="application/octet-stream";break;default:break}const G=this.definitions.type,Y=!this.config.aot,K={...this.validator.getCandidate()},B={body:W?.body??K?.body,headers:W?.headers??K?.headers,params:W?.params??K?.params,query:W?.query??K?.query,cookie:W?.cookie??K?.cookie,response:W?.response??K?.response},U=()=>B.cookie?e0({validator:B.cookie,defaultConfig:this.config.cookie,config:B.cookie?.config??{},dynamic:Y,models:G}):void 0,w=this.config.normalize,D=this.config.precompile===!0||typeof this.config.precompile==="object"&&this.config.precompile.schema===!0?{body:h(B.body,{dynamic:Y,models:G,normalize:w}),headers:h(B.headers,{dynamic:Y,models:G,additionalProperties:!this.config.normalize,coerce:!0,additionalCoerce:D0}),params:h(B.params,{dynamic:Y,models:G,coerce:!0,additionalCoerce:D0}),query:h(B.query,{dynamic:Y,models:G,normalize:w,coerce:!0,additionalCoerce:D0}),cookie:U(),response:o0(B.response,{dynamic:Y,models:G,normalize:w})}:{createBody(){if(this.body)return this.body;return this.body=h(B.body,{dynamic:Y,models:G,normalize:w})},createHeaders(){if(this.headers)return this.headers;return this.headers=h(B.headers,{dynamic:Y,models:G,additionalProperties:!w,coerce:!0,additionalCoerce:D0})},createParams(){if(this.params)return this.params;return this.params=h(B.params,{dynamic:Y,models:G,coerce:!0,additionalCoerce:D0})},createQuery(){if(this.query)return this.query;return this.query=h(B.query,{dynamic:Y,models:G,coerce:!0,additionalCoerce:D0})},createCookie(){if(this.cookie)return this.cookie;return this.cookie=U()},createResponse(){if(this.response)return this.response;return this.response=o0(B.response,{dynamic:Y,models:G,normalize:w})}},Q=X.endsWith("/")?X.slice(0,X.length-1):X+"/";if(W=c(W,K),W.tags)if(!W.detail)W.detail={tags:W.tags};else W.detail.tags=W.tags;if(p(this.config.detail))W.detail=d(Object.assign({},this.config.detail),W.detail);this.applyMacro(W);const _=c(this.event,W);if(this.config.aot===!1){if(this.router.dynamic.add($,X,{validator:D,hooks:_,content:W?.type,handle:Z}),this.config.strictPath===!1)this.router.dynamic.add($,Q,{validator:D,hooks:_,content:W?.type,handle:Z});this.router.history.push({method:$,path:X,composed:null,handler:Z,hooks:_});return}const P=this.config.precompile===!0||typeof this.config.precompile==="object"&&this.config.precompile.compose===!0,M=u0(this.inference),I=()=>F2({app:this,path:X,method:$,localHook:c(W),hooks:_,validator:D,handler:Z,allowMeta:J,inference:M}),V=P?I():(E)=>{return I()(E)},O=this.router.history.length;if(this.routeTree.has($+X))for(let E=0;E<this.router.history.length;E++){const k=this.router.history[E];if(k.path===X&&k.method===$){const R=this.router.history.splice(E,1)[0];if(R&&this.routeTree.has(R?.method+R?.path))this.routeTree.delete(R.method+R.path)}}else this.routeTree.set($+X,O);this.router.history.push({method:$,path:X,composed:V,handler:Z,hooks:_});const q=this.router.static.http,L={handler:P?V:void 0,compile:I};if($==="$INTERNALWS"){const E=this.config.strictPath?void 0:X.endsWith("/")?X.slice(0,X.length-1):X+"/";if(X.indexOf(":")===-1&&X.indexOf("*")===-1){const k=q.handlers.length;if(q.handlers.push((R)=>(q.handlers[k]=I())(R)),this.router.static.ws[X]=k,E)this.router.static.ws[E]=k}else if(this.router.ws.add("ws",X,L),E)this.router.ws.add("ws",E,L);return}if(X.indexOf(":")===-1&&X.indexOf("*")===-1){const E=q.handlers.length;if(q.handlers.push((k)=>(q.handlers[E]=I())(k)),!q.map[X])q.map[X]={code:""};if($==="ALL")q.map[X].all=`default: return st[${E}](ctx)\n`;else q.map[X].code=`case '${$}': return st[${E}](ctx)\n${q.map[X].code}`;if(!this.config.strictPath){if(!q.map[Q])q.map[Q]={code:""};if($==="ALL")q.map[Q].all=`default: return st[${E}](ctx)\n`;else q.map[Q].code=`case '${$}': return st[${E}](ctx)\n${q.map[Q].code}`}}else if(this.router.http.add($,X,L),!this.config.strictPath)this.router.http.add($,X.endsWith("/")?X.slice(0,X.length-1):X+"/",L)}setHeaders;headers($){if(!$)return this;if(!this.setHeaders)this.setHeaders={};return this.setHeaders=d(this.setHeaders,$),this}onStart($){return this.on("start",$),this}onRequest($){return this.on("request",$),this}onParse($,X){if(!X)return this.on("parse",$);return this.on($,"parse",X)}onTransform($,X){if(!X)return this.on("transform",$);return this.on($,"transform",X)}resolve($,X){if(!X)X=$,$={as:"local"};const Z={subType:"resolve",fn:X};return this.onBeforeHandle($,Z)}mapResolve($,X){if(!X)X=$,$={as:"local"};const Z={subType:"mapResolve",fn:X};return this.onBeforeHandle($,Z)}onBeforeHandle($,X){if(!X)return this.on("beforeHandle",$);return this.on($,"beforeHandle",X)}onAfterHandle($,X){if(!X)return this.on("afterHandle",$);return this.on($,"afterHandle",X)}mapResponse($,X){if(!X)return this.on("mapResponse",$);return this.on($,"mapResponse",X)}onAfterResponse($,X){if(!X)return this.on("afterResponse",$);return this.on($,"afterResponse",X)}trace($,X){if(!X)X=$,$={as:"local"};if(!Array.isArray(X))X=[X];for(let Z of X)this.on($,"trace",U2(Z));return this}error($,X){switch(typeof $){case"string":return X.prototype[N0]=$,this.definitions.error[$]=X,this;case"function":return this.definitions.error=$(this.definitions.error),this}for(let[Z,W]of Object.entries($))W.prototype[N0]=Z,this.definitions.error[Z]=W;return this}onError($,X){if(!X)return this.on("error",$);return this.on($,"error",X)}onStop($){return this.on("stop",$),this}on($,X,Z){let W;switch(typeof $){case"string":W=$,Z=X;break;case"object":if(W=X,!Array.isArray(X)&&typeof X==="object")Z=X;break}if(Array.isArray(Z))Z=i(Z);else if(typeof Z==="function")Z=[{fn:Z}];else Z=[Z];const J=Z;for(let j of J)j.scope=typeof $==="string"?"local":$?.as??"local";if(W!=="trace")i0({[W]:J.map((j)=>j.fn)},this.inference);for(let j of J){const G=j2(j,"global",{skipIfHasType:!0});switch(W){case"start":this.event.start.push(G);break;case"request":this.event.request.push(G);break;case"parse":this.event.parse.push(G);break;case"transform":this.event.transform.push(G);break;case"beforeHandle":this.event.beforeHandle.push(G);break;case"afterHandle":this.event.afterHandle.push(G);break;case"mapResponse":this.event.mapResponse.push(G);break;case"afterResponse":this.event.afterResponse.push(G);break;case"trace":this.event.trace.push(G);break;case"error":this.event.error.push(G);break;case"stop":this.event.stop.push(G);break}}return this}propagate(){return v(this.event.parse),v(this.event.transform),v(this.event.beforeHandle),v(this.event.afterHandle),v(this.event.mapResponse),v(this.event.afterResponse),v(this.event.trace),v(this.event.error),this}as($){const X={plugin:"scoped",global:"global"}[$];if(v(this.event.parse,X),v(this.event.transform,X),v(this.event.beforeHandle,X),v(this.event.afterHandle,X),v(this.event.mapResponse,X),v(this.event.afterResponse,X),v(this.event.trace,X),v(this.event.error,X),$==="plugin")this.validator.scoped=H0(this.validator.scoped,this.validator.local),this.validator.local=null;else if($==="global")this.validator.global=H0(this.validator.global,H0(this.validator.scoped,this.validator.local)),this.validator.scoped=null,this.validator.local=null;return this}group($,X,Z){const W=new Z0({...this.config,prefix:""});W.singleton={...this.singleton},W.definitions={...this.definitions},W.getServer=()=>this.getServer(),W.inference=u0(this.inference),W.extender={...this.extender};const J=typeof X==="object",j=(J?Z:X)(W);if(this.singleton=d(this.singleton,W.singleton),this.definitions=d(this.definitions,W.definitions),j.event.request.length)this.event.request=[...this.event.request||[],...j.event.request||[]];if(j.event.mapResponse.length)this.event.mapResponse=[...this.event.mapResponse||[],...j.event.mapResponse||[]];return this.model(j.definitions.type),Object.values(W.router.history).forEach(({method:G,path:Y,handler:K,hooks:B})=>{if(Y=(J?"":this.config.prefix)+$+Y,J){const U=X,w=B;this.add(G,Y,K,c(U,{...w||{},error:!w.error?j.event.error:Array.isArray(w.error)?[...w.error||{},...j.event.error||{}]:[w.error,...j.event.error||{}]}))}else this.add(G,Y,K,c(B,{error:j.event.error}),{skipPrefix:!0})}),this}guard($,X){if(!X){if(typeof $==="object"){this.applyMacro($);const J=$.as??"local";if(this.validator[J]={body:$.body??this.validator[J]?.body,headers:$.headers??this.validator[J]?.headers,params:$.params??this.validator[J]?.params,query:$.query??this.validator[J]?.query,response:$.response??this.validator[J]?.response,cookie:$.cookie??this.validator[J]?.cookie},$.parse)this.on({as:J},"parse",$.parse);if($.transform)this.on({as:J},"transform",$.transform);if($.beforeHandle)this.on({as:J},"beforeHandle",$.beforeHandle);if($.afterHandle)this.on({as:J},"afterHandle",$.afterHandle);if($.mapResponse)this.on({as:J},"mapResponse",$.mapResponse);if($.afterResponse)this.on({as:J},"afterResponse",$.afterResponse);if($.error)this.on({as:J},"error",$.error);if($.detail)if(this.config.detail)this.config.detail=d(Object.assign({},this.config.detail),$.detail);else this.config.detail=$.detail;if($?.tags)if(!this.config.detail)this.config.detail={tags:$.tags};else this.config.detail.tags=$.tags;return this}return this.guard({},$)}const Z=new Z0({...this.config,prefix:""});Z.singleton={...this.singleton},Z.definitions={...this.definitions},Z.inference=u0(this.inference),Z.extender={...this.extender};const W=X(Z);if(this.singleton=d(this.singleton,Z.singleton),this.definitions=d(this.definitions,Z.definitions),W.getServer=()=>this.server,W.event.request.length)this.event.request=[...this.event.request||[],...W.event.request||[]];if(W.event.mapResponse.length)this.event.mapResponse=[...this.event.mapResponse||[],...W.event.mapResponse||[]];return this.model(W.definitions.type),Object.values(Z.router.history).forEach(({method:J,path:j,handler:G,hooks:Y})=>{this.add(J,j,G,c($,{...Y||{},error:!Y.error?W.event.error:Array.isArray(Y.error)?[...Y.error||{},...W.event.error||[]]:[Y.error,...W.event.error||[]]}))}),this}use($,X){if(X?.scoped)return this.guard({},(Z)=>Z.use($));if(Array.isArray($)){let Z=this;for(let W of $)Z=this.use(W);return Z}if($ instanceof Promise)return this.promisedModules.add($.then((Z)=>{if(typeof Z==="function")return Z(this);if(Z instanceof Z0)return this._use(Z);if(typeof Z.default==="function")return Z.default(this);if(Z.default instanceof Z0)return this._use(Z.default);throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.')}).then((Z)=>Z.compile())),this;return this._use($)}_use($){if(typeof $==="function"){const J=$(this);if(J instanceof Promise)return this.promisedModules.add(J.then((j)=>{if(j instanceof Z0){this.compile();for(let{method:G,path:Y,handler:K,hooks:B}of Object.values(j.router.history))this.add(G,Y,K,c(B,{error:j.event.error}));return j}if(typeof j==="function")return j(this);if(typeof j.default==="function")return j.default(this);return this._use(j)}).then((j)=>j.compile())),this;return J}if($.promisedModules.size)return this.promisedModules.add($.modules.then(()=>this._use($)).then((J)=>J.compile())),this;const{name:X,seed:Z}=$.config;$.getServer=()=>this.getServer(),$.getGlobalRoutes=()=>this.getGlobalRoutes(),$.model(this.definitions.type),$.error(this.definitions.error);const W=$.config.scoped;if(W){if(X){if(!(X in this.dependencies))this.dependencies[X]=[];const j=Z!==void 0?z0(X+JSON.stringify(Z)):0;if(this.dependencies[X].some(({checksum:G})=>j===G))return this;this.dependencies[X].push(!this.config?.analytic?{name:$.config.name,seed:$.config.seed,checksum:j,dependencies:$.dependencies}:{name:$.config.name,seed:$.config.seed,checksum:j,dependencies:$.dependencies,stack:$.telemetry.stack,routes:$.router.history,decorators:$.singleton.decorator,store:$.singleton.store,type:$.definitions.type,error:$.definitions.error,derive:$.event.transform.filter((G)=>G.subType==="derive").map((G)=>({fn:G.fn.toString(),stack:new Error().stack??""})),resolve:$.event.transform.filter((G)=>G.subType==="derive").map((G)=>({fn:G.fn.toString(),stack:new Error().stack??""}))})}$.extender.macros=this.extender.macros.concat($.extender.macros);const J=[];for(let j=0;j<$.extender.macros.length;j++){const G=this.extender.macros[j];if(J.includes(G.checksum))$.extender.macros.splice(j,1),j--;J.push(G.checksum)}if($.onRequest((j)=>{Object.assign(j,this.singleton.decorator),Object.assign(j.store,this.singleton.store)}),$.event.trace.length)$.event.trace.push(...$.event.trace);if(!$.config.prefix)console.warn("It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.");if($.event.error.length)$.event.error.push(...this.event.error);if($.config.aot)$.compile();if(W===!0&&$.config.prefix){this.mount($.config.prefix+"/",$.fetch);for(let j of $.router.history)this.routeTree.set(j.method+`${$.config.prefix}${j.path}`,this.router.history.length),this.router.history.push({...j,path:`${$.config.prefix}${j.path}`,hooks:c(j.hooks,{error:this.event.error})})}else{this.mount($.fetch);for(let j of $.router.history)this.routeTree.set(j.method+`${$.config.prefix}${j.path}`,this.router.history.length),this.router.history.push({...j,path:`${$.config.prefix}${j.path}`,hooks:c(j.hooks,{error:this.event.error})})}return this}else{if(this.headers($.setHeaders),X){if(!(X in this.dependencies))this.dependencies[X]=[];const j=Z!==void 0?z0(X+JSON.stringify(Z)):0;if(!this.dependencies[X].some(({checksum:G})=>j===G))this.extender.macros=this.extender.macros.concat($.extender.macros),this.extender.higherOrderFunctions=this.extender.higherOrderFunctions.concat($.extender.higherOrderFunctions)}else this.extender.macros=this.extender.macros.concat($.extender.macros),this.extender.higherOrderFunctions=this.extender.higherOrderFunctions.concat($.extender.higherOrderFunctions);W1(this.extender.macros),W1(this.extender.higherOrderFunctions);const J=[];for(let j=0;j<this.extender.higherOrderFunctions.length;j++){const G=this.extender.higherOrderFunctions[j];if(G.checksum){if(J.includes(G.checksum))this.extender.higherOrderFunctions.splice(j,1),j--;J.push(G.checksum)}}this.inference={body:this.inference.body||$.inference.body,cookie:this.inference.cookie||$.inference.cookie,headers:this.inference.headers||$.inference.headers,query:this.inference.query||$.inference.query,set:this.inference.set||$.inference.set,server:this.inference.server||$.inference.server}}this.decorate($.singleton.decorator),this.state($.singleton.store),this.model($.definitions.type),this.error($.definitions.error),$.extender.macros=this.extender.macros.concat($.extender.macros);for(let{method:J,path:j,handler:G,hooks:Y}of Object.values($.router.history))this.add(J,j,G,c(Y,{error:$.event.error}));if(!W)if(X){if(!(X in this.dependencies))this.dependencies[X]=[];const J=Z!==void 0?z0(X+JSON.stringify(Z)):0;if(this.dependencies[X].some(({checksum:j})=>J===j))return this;this.dependencies[X].push(!this.config?.analytic?{name:$.config.name,seed:$.config.seed,checksum:J,dependencies:$.dependencies}:{name:$.config.name,seed:$.config.seed,checksum:J,dependencies:$.dependencies,stack:$.telemetry.stack,routes:$.router.history,decorators:$.singleton,store:$.singleton.store,type:$.definitions.type,error:$.definitions.error,derive:$.event.transform.filter((j)=>j?.subType==="derive").map((j)=>({fn:j.toString(),stack:new Error().stack??""})),resolve:$.event.transform.filter((j)=>j?.subType==="resolve").map((j)=>({fn:j.toString(),stack:new Error().stack??""}))}),this.event=z1(this.event,P1($.event),J)}else this.event=z1(this.event,P1($.event));return this.validator.global=c(this.validator.global,{...$.validator.global}),this.validator.local=c(this.validator.local,{...$.validator.scoped}),this}macro($){const X={checksum:z0(JSON.stringify({name:this.config.name,seed:this.config.seed,content:$.toString()})),fn:$};return this.extender.macros.push(X),this}mount($,X){if($ instanceof Z0||typeof $==="function"||$.length===0||$==="/"){const J=typeof $==="function"?$:$ instanceof Z0?$.compile().fetch:X instanceof Z0?X.compile().fetch:X,j=async({request:G,path:Y})=>J(new Request(a0(G.url,Y||"/"),G));return this.all("/*",j,{type:"none"}),this}const Z=$.length;if(X instanceof Z0)X=X.compile().fetch;const W=async({request:J,path:j})=>X(new Request(a0(J.url,j.slice(Z)||"/"),J));return this.all($,W,{type:"none"}),this.all($+($.endsWith("/")?"*":"/*"),W,{type:"none"}),this}get($,X,Z){return this.add("GET",$,X,Z),this}post($,X,Z){return this.add("POST",$,X,Z),this}put($,X,Z){return this.add("PUT",$,X,Z),this}patch($,X,Z){return this.add("PATCH",$,X,Z),this}delete($,X,Z){return this.add("DELETE",$,X,Z),this}options($,X,Z){return this.add("OPTIONS",$,X,Z),this}all($,X,Z){return this.add("ALL",$,X,Z),this}head($,X,Z){return this.add("HEAD",$,X,Z),this}connect($,X,Z){return this.add("CONNECT",$,X,Z),this}route($,X,Z,W){return this.add($.toUpperCase(),X,Z,W,W?.config),this}ws($,X){const Z=X.transformMessage?Array.isArray(X.transformMessage)?X.transformMessage:[X.transformMessage]:void 0;let W=null;const J=h(X?.body,{models:this.definitions.type,normalize:this.config.normalize}),j=h(X?.response,{models:this.definitions.type,normalize:this.config.normalize}),G=(Y)=>{if(typeof Y==="string"){const K=Y?.charCodeAt(0);if(K===47||K===123)try{Y=JSON.parse(Y)}catch{}else if(X1(Y))Y=+Y}if(Z?.length)for(let K=0;K<Z.length;K++){const B=Z[K](Y);if(B!==void 0)Y=B}return Y};return this.route("$INTERNALWS",$,(Y)=>{const{set:K,path:B,qi:U,headers:w,query:D,params:Q}=Y;if(W===null)W=this.getServer();if(W?.upgrade(Y.request,{headers:typeof X.upgrade==="function"?X.upgrade(Y):X.upgrade,data:{validator:j,open(_){X.open?.(new R0(_,Y))},message:(_,P)=>{const M=G(P);if(J?.Check(M)===!1)return void _.send(new H("message",J,M).message);X.message?.(new R0(_,Y),M)},drain(_){X.drain?.(new R0(_,Y))},close(_,P,M){X.close?.(new R0(_,Y),P,M)}}}))return;return K.status=400,"Expected a websocket connection"},{beforeHandle:X.beforeHandle,transform:X.transform,headers:X.headers,params:X.params,query:X.query}),this}state($,X,Z){if(X===void 0)Z=$,$={as:"append"},X="";else if(Z===void 0){if(typeof $==="string")Z=X,X=$,$={as:"append"};else if(typeof $==="object")Z=X,X=""}const{as:W}=$;if(typeof X!=="string")return this;switch(typeof Z){case"object":if(X){if(X in this.singleton.store)this.singleton.store[X]=d(this.singleton.store[X],Z,{override:W==="override"});else this.singleton.store[X]=Z;return this}if(Z===null)return this;return this.singleton.store=d(this.singleton.store,Z,{override:W==="override"}),this;case"function":if(X){if(W==="override"||!(X in this.singleton.store))this.singleton.store[X]=Z}else this.singleton.store=Z(this.singleton.store);return this;default:if(W==="override"||!(X in this.singleton.store))this.singleton.store[X]=Z;return this}}decorate($,X,Z){if(X===void 0)Z=$,$={as:"append"},X="";else if(Z===void 0){if(typeof $==="string")Z=X,X=$,$={as:"append"};else if(typeof $==="object")Z=X,X=""}const{as:W}=$;if(typeof X!=="string")return this;switch(typeof Z){case"object":if(X){if(X in this.singleton.decorator)this.singleton.decorator[X]=d(this.singleton.decorator[X],Z,{override:W==="override"});else this.singleton.decorator[X]=Z;return this}if(Z===null)return this;return this.singleton.decorator=d(this.singleton.decorator,Z,{override:W==="override"}),this;case"function":if(X){if(W==="override"||!(X in this.singleton.decorator))this.singleton.decorator[X]=Z}else this.singleton.decorator=Z(this.singleton.decorator);return this;default:if(W==="override"||!(X in this.singleton.decorator))this.singleton.decorator[X]=Z;return this}}derive($,X){if(!X)X=$,$={as:"local"};const Z={subType:"derive",fn:X};return this.onTransform($,Z)}model($,X){switch(typeof $){case"object":return Object.entries($).forEach(([Z,W])=>{if(!(Z in this.definitions.type))this.definitions.type[Z]=W}),this;case"function":return this.definitions.type=$(this.definitions.type),this}return this.definitions.type[$]=X,this}mapDerive($,X){if(!X)X=$,$={as:"local"};const Z={subType:"mapDerive",fn:X};return this.onTransform($,Z)}affix($,X,Z){if(Z==="")return this;const W=["_","-"," "],J=(K)=>K[0].toUpperCase()+K.slice(1),j=$==="prefix"?(K,B)=>W.includes(K.at(-1)??"")?K+B:K+J(B):W.includes(Z.at(-1)??"")?(K,B)=>B+K:(K,B)=>B+J(K),G=(K)=>{const B={};switch(K){case"decorator":for(let U in this.singleton.decorator)B[j(Z,U)]=this.singleton.decorator[U];this.singleton.decorator=B;break;case"state":for(let U in this.singleton.store)B[j(Z,U)]=this.singleton.store[U];this.singleton.store=B;break;case"model":for(let U in this.definitions.type)B[j(Z,U)]=this.definitions.type[U];this.definitions.type=B;break;case"error":for(let U in this.definitions.error)B[j(Z,U)]=this.definitions.error[U];this.definitions.error=B;break}},Y=Array.isArray(X)?X:[X];for(let K of Y.some((B)=>B==="all")?["decorator","state","model","error"]:Y)G(K);return this}prefix($,X){return this.affix("prefix",$,X)}suffix($,X){return this.affix("suffix",$,X)}compile(){if(this.fetch=this.config.aot?L1(this):H1(this),typeof this.server?.reload==="function")this.server.reload({...this.server||{},fetch:this.fetch});return this}handle=async($)=>this.fetch($);fetch=($)=>{return(this.fetch=this.config.aot?L1(this):H1(this))($)};handleError=async($,X)=>(this.handleError=this.config.aot?T1(this):D2(this))($,X);outerErrorHandler=($)=>new Response($.message||$.name||"Error",{status:$?.status??500});listen=($,X)=>{if(typeof Bun==="undefined")throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");if(this.compile(),typeof $==="string"){if(!X1($))throw new Error("Port must be a numeric value");$=parseInt($)}const Z=this.fetch,W=typeof $==="object"?{development:!d0,reusePort:!0,...this.config.serve||{},...$||{},websocket:{...this.config.websocket||{},...O1||{}},fetch:Z,error:this.outerErrorHandler}:{development:!d0,reusePort:!0,...this.config.serve||{},websocket:{...this.config.websocket||{},...O1||{}},port:$,fetch:Z,error:this.outerErrorHandler};this.server=Bun?.serve(W);for(let J=0;J<this.event.start.length;J++)this.event.start[J].fn(this);if(X)X(this.server);return process.on("beforeExit",()=>{if(this.server){this.server.stop(),this.server=null;for(let J=0;J<this.event.stop.length;J++)this.event.stop[J].fn(this)}}),this.promisedModules.then(()=>{Bun?.gc(!1)}),this};stop=async()=>{if(!this.server)throw new Error("Elysia isn't running. Call `app.listen` to start the server.");if(this.server){if(this.server.stop(),this.server=null,this.event.stop.length)for(let $=0;$<this.event.stop.length;$++)this.event.stop[$].fn(this)}};get modules(){return Promise.all(this.promisedModules.promises)}}export{A as t,a0 as replaceUrlPath,J2 as replaceSchemaType,h0 as redirect,x as mergeObjectArray,c as mergeHook,s as mapValueError,f as mapResponse,y as mapEarlyResponse,e as mapCompactResponse,h as getSchemaValidator,o0 as getResponseSchemaValidator,M0 as form,V1 as error,Z0 as default,W1 as deduplicateChecksum,u0 as cloneInference,z0 as checksum,H as ValidationError,Y0 as StatusMap,j1 as ParseError,I0 as NotFoundError,$1 as InvertedStatusMap,y0 as InvalidCookieSignature,J1 as InternalServerError,Z0 as Elysia,N0 as ERROR_CODE,c0 as ELYSIA_TRACE,m as ELYSIA_RESPONSE,P0 as ELYSIA_REQUEST_ID,M3 as ELYSIA_FORM_DATA,G0 as Cookie};

//# debugId=343A34477716BDA564756E2164756E21
