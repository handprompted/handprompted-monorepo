import Elysia from 'elysia';
import { defaultOptions } from '../constants/defaultOptions';
import { DefaultContext } from './defaultContext';
import { logger } from './logger';
export const plugin = (userOptions) => {
    const options = {
        ...defaultOptions,
        ...userOptions,
        context: userOptions?.context ?? new DefaultContext(),
    };
    options.context.init(options);
    return (app) => {
        const plugin = new Elysia({
            name: "elysia-rate-limit"
        });
        plugin.onBeforeHandle({ as: options.scoping }, async ({ set, request, query, path, store, cookie, error, body, params, headers, qi, ...rest }) => {
            let clientKey;
            if (options.skip.length >= 2)
                clientKey = await options.generator(request, options.injectServer?.() ?? app.server, rest);
            if (await options.skip(request, clientKey) === false) {
                if (options.skip.length < 2)
                    clientKey = await options.generator(request, options.injectServer?.() ?? app.server, rest);
                const { count, nextReset } = await options.context.increment(clientKey);
                const payload = {
                    limit: options.max,
                    current: count,
                    remaining: Math.max(options.max - count, 0),
                    nextReset,
                };
                const reset = Math.max(0, Math.ceil((nextReset.getTime() - Date.now()) / 1000));
                let builtHeaders = {
                    'RateLimit-Limit': String(options.max),
                    'RateLimit-Remaining': String(payload.remaining),
                    'RateLimit-Reset': String(reset),
                };
                if (payload.current >= payload.limit + 1) {
                    logger('plugin', 'rate limit exceeded for clientKey: %s (resetting in %d seconds)', clientKey, reset);
                    builtHeaders['Retry-After'] = String(Math.ceil(options.duration / 1000));
                    if (options.errorResponse instanceof Error)
                        throw options.errorResponse;
                    else if (options.errorResponse instanceof Response) {
                        const clonedResponse = options.errorResponse.clone();
                        if (options.headers)
                            for (const [key, value] of Object.entries(builtHeaders))
                                clonedResponse.headers.set(key, value);
                        return clonedResponse;
                    }
                    else {
                        if (options.headers)
                            for (const [key, value] of Object.entries(builtHeaders))
                                set.headers[key] = value;
                        set.status = 429;
                        return options.errorResponse;
                    }
                }
                if (options.headers)
                    for (const [key, value] of Object.entries(builtHeaders))
                        set.headers[key] = value;
                logger('plugin', 'clientKey %s passed through with %d/%d request used (resetting in %d seconds)', clientKey, options.max - payload.remaining, options.max, reset);
            }
        });
        plugin.onError({ as: options.scoping }, async ({ set, request, query, path, store, cookie, error, body, params, headers, qi, code, ...rest }) => {
            if (!options.countFailedRequest) {
                const clientKey = await options.generator(request, options.injectServer?.() ?? app.server, rest);
                logger('plugin', 'request failed for clientKey: %s, refunding', clientKey);
                await options.context.decrement(clientKey);
            }
        });
        plugin.onStop(async () => {
            logger('plugin', 'kill signal received');
            await options.context.kill();
        });
        return app.use(plugin);
    };
};
