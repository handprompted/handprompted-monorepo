"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default,
  staticPlugin: () => staticPlugin
});
module.exports = __toCommonJS(src_exports);
var import_elysia = require("elysia");
var import_promises2 = require("fs/promises");
var import_path = require("path");
var import_node_cache = __toESM(require("node-cache"));

// src/cache.ts
var import_promises = require("fs/promises");
async function isCached(headers, etag, filePath) {
  if (headers["cache-control"] && headers["cache-control"].indexOf("no-cache") !== -1)
    return false;
  if ("if-none-match" in headers) {
    const ifNoneMatch = headers["if-none-match"];
    if (ifNoneMatch === "*") return true;
    if (ifNoneMatch === null) return false;
    if (typeof etag !== "string") return false;
    const isMatching = ifNoneMatch === etag;
    if (isMatching) return true;
    return false;
  }
  if (headers["if-modified-since"]) {
    const ifModifiedSince = headers["if-modified-since"];
    let lastModified;
    try {
      lastModified = (await (0, import_promises.stat)(filePath)).mtime;
    } catch {
    }
    if (lastModified !== void 0 && lastModified.getTime() <= Date.parse(ifModifiedSince))
      return true;
  }
  return false;
}
async function generateETag(file) {
  const hash = new Bun.CryptoHasher("md5");
  hash.update(await file.arrayBuffer());
  return hash.digest("base64");
}

// src/index.ts
var URL_PATH_SEP = "/";
var fileExists = (path) => (0, import_promises2.stat)(path).then(
  () => true,
  () => false
);
var statCache = new import_node_cache.default({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var fileCache = new import_node_cache.default({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var htmlCache = new import_node_cache.default({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var listFiles = async (dir) => {
  const files = await (0, import_promises2.readdir)(dir);
  const all = await Promise.all(
    files.map(async (name) => {
      const file = dir + import_path.sep + name;
      const stats = await (0, import_promises2.stat)(file);
      return stats && stats.isDirectory() ? await listFiles(file) : [(0, import_path.resolve)(dir, file)];
    })
  );
  return all.flat();
};
var staticPlugin = async ({
  assets = "public",
  prefix = "/public",
  staticLimit = 1024,
  alwaysStatic = process.env.NODE_ENV === "production",
  ignorePatterns = [".DS_Store", ".git", ".env"],
  noExtension = false,
  enableDecodeURI = false,
  resolve: resolve2 = import_path.resolve,
  headers = {},
  noCache = false,
  maxAge = 86400,
  directive = "public",
  indexHTML = true
} = {
  assets: "public",
  prefix: "/public",
  staticLimit: 1024,
  alwaysStatic: process.env.NODE_ENV === "production",
  ignorePatterns: [],
  noExtension: false,
  enableDecodeURI: false,
  resolve: import_path.resolve,
  headers: {},
  noCache: false,
  indexHTML: true
}) => {
  const files = await listFiles((0, import_path.resolve)(assets));
  const isFSSepUnsafe = import_path.sep !== URL_PATH_SEP;
  if (prefix === URL_PATH_SEP) prefix = "";
  const shouldIgnore = (file) => {
    if (!ignorePatterns.length) return false;
    return ignorePatterns.find((pattern) => {
      if (typeof pattern === "string") return pattern.includes(file);
      else return pattern.test(file);
    });
  };
  const app = new import_elysia.Elysia({
    name: "static",
    seed: {
      assets,
      prefix,
      staticLimit,
      alwaysStatic,
      ignorePatterns,
      noExtension,
      enableDecodeURI,
      resolve: resolve2.toString(),
      headers,
      noCache,
      maxAge,
      directive,
      indexHTML
    }
  });
  if (alwaysStatic || process.env.ENV === "production" && files.length <= staticLimit)
    for (let i = 0; i < files.length; i++) {
      const filePath = files[i];
      if (!filePath || shouldIgnore(filePath)) continue;
      let fileName = filePath.replace(resolve2(), "").replace(`${assets}${import_path.sep}`, "");
      if (noExtension) {
        const temp = fileName.split(".");
        temp.splice(-1);
        fileName = temp.join(".");
      }
      const file = Bun.file(filePath);
      const etag = await generateETag(file);
      const pathName = isFSSepUnsafe ? prefix + fileName.split(import_path.sep).join(URL_PATH_SEP) : (0, import_path.join)(prefix, fileName);
      app.get(
        pathName,
        noCache ? new Response(file, {
          headers
        }) : async ({ headers: reqHeaders }) => {
          if (await isCached(reqHeaders, etag, filePath)) {
            return new Response(null, {
              status: 304,
              headers
            });
          }
          headers["Etag"] = etag;
          headers["Cache-Control"] = directive;
          if (maxAge !== null)
            headers["Cache-Control"] += `, max-age=${maxAge}`;
          return new Response(file, {
            headers
          });
        }
      );
      if (indexHTML && pathName.endsWith("/index.html"))
        app.get(
          (0, import_path.join)(prefix, pathName.replace("/index.html", "")),
          noCache ? new Response(file, {
            headers
          }) : async ({ headers: reqHeaders }) => {
            if (await isCached(reqHeaders, etag, pathName)) {
              return new Response(null, {
                status: 304,
                headers
              });
            }
            headers["Etag"] = etag;
            headers["Cache-Control"] = directive;
            if (maxAge !== null)
              headers["Cache-Control"] += `, max-age=${maxAge}`;
            return new Response(file, {
              headers
            });
          }
        );
    }
  else {
    if (!app.router.history.find(
      ({ method, path }) => path === `${prefix}/*` && method === "GET"
    ))
      app.onError(() => {
      }).get(
        `${prefix}/*`,
        async ({ params, headers: reqHeaders }) => {
          let path = enableDecodeURI ? decodeURI(`${assets}/${decodeURI(params["*"])}`) : `${assets}/${params["*"]}`;
          if (isFSSepUnsafe) {
            path = path.replace(URL_PATH_SEP, import_path.sep);
          }
          if (shouldIgnore(path)) throw new import_elysia.NotFoundError();
          try {
            let status = statCache.get(path);
            if (!status) {
              status = await (0, import_promises2.stat)(path);
              statCache.set(path, status);
            }
            let file = fileCache.get(
              path
            );
            if (!file) {
              if (status.isDirectory()) {
                let hasCache = false;
                if (indexHTML && (hasCache = htmlCache.get(
                  `${path}${import_path.sep}index.html`
                ) ?? await fileExists(
                  `${path}${import_path.sep}index.html`
                ))) {
                  if (hasCache === void 0)
                    htmlCache.set(
                      `${path}${import_path.sep}index.html`,
                      true
                    );
                  file = Bun.file(`${path}${import_path.sep}index.html`);
                } else {
                  if (indexHTML && hasCache === void 0)
                    htmlCache.set(
                      `${path}${import_path.sep}index.html`,
                      false
                    );
                  throw new import_elysia.NotFoundError();
                }
              }
              file ??= Bun.file(path);
              fileCache.set(path, file);
            }
            if (noCache)
              return new Response(file, {
                headers
              });
            const etag = await generateETag(file);
            if (await isCached(reqHeaders, etag, path))
              return new Response(null, {
                status: 304,
                headers
              });
            headers["Etag"] = etag;
            headers["Cache-Control"] = directive;
            if (maxAge !== null)
              headers["Cache-Control"] += `, max-age=${maxAge}`;
            return new Response(file, {
              headers
            });
          } catch (error) {
            throw new import_elysia.NotFoundError();
          }
        }
      );
  }
  return app;
};
var src_default = staticPlugin;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  staticPlugin
});
