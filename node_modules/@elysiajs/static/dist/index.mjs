// src/index.ts
import { Elysia, NotFoundError } from "elysia";
import { readdir, stat as stat2 } from "fs/promises";
import { resolve, resolve as resolveFn, join, sep } from "path";
import Cache from "node-cache";

// src/cache.ts
import { stat } from "fs/promises";
async function isCached(headers, etag, filePath) {
  if (headers["cache-control"] && headers["cache-control"].indexOf("no-cache") !== -1)
    return false;
  if ("if-none-match" in headers) {
    const ifNoneMatch = headers["if-none-match"];
    if (ifNoneMatch === "*") return true;
    if (ifNoneMatch === null) return false;
    if (typeof etag !== "string") return false;
    const isMatching = ifNoneMatch === etag;
    if (isMatching) return true;
    return false;
  }
  if (headers["if-modified-since"]) {
    const ifModifiedSince = headers["if-modified-since"];
    let lastModified;
    try {
      lastModified = (await stat(filePath)).mtime;
    } catch {
    }
    if (lastModified !== void 0 && lastModified.getTime() <= Date.parse(ifModifiedSince))
      return true;
  }
  return false;
}
async function generateETag(file) {
  const hash = new Bun.CryptoHasher("md5");
  hash.update(await file.arrayBuffer());
  return hash.digest("base64");
}

// src/index.ts
var URL_PATH_SEP = "/";
var fileExists = (path) => stat2(path).then(
  () => true,
  () => false
);
var statCache = new Cache({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var fileCache = new Cache({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var htmlCache = new Cache({
  useClones: false,
  checkperiod: 5 * 60,
  stdTTL: 3 * 60 * 60,
  maxKeys: 250
});
var listFiles = async (dir) => {
  const files = await readdir(dir);
  const all = await Promise.all(
    files.map(async (name) => {
      const file = dir + sep + name;
      const stats = await stat2(file);
      return stats && stats.isDirectory() ? await listFiles(file) : [resolve(dir, file)];
    })
  );
  return all.flat();
};
var staticPlugin = async ({
  assets = "public",
  prefix = "/public",
  staticLimit = 1024,
  alwaysStatic = process.env.NODE_ENV === "production",
  ignorePatterns = [".DS_Store", ".git", ".env"],
  noExtension = false,
  enableDecodeURI = false,
  resolve: resolve2 = resolveFn,
  headers = {},
  noCache = false,
  maxAge = 86400,
  directive = "public",
  indexHTML = true
} = {
  assets: "public",
  prefix: "/public",
  staticLimit: 1024,
  alwaysStatic: process.env.NODE_ENV === "production",
  ignorePatterns: [],
  noExtension: false,
  enableDecodeURI: false,
  resolve: resolveFn,
  headers: {},
  noCache: false,
  indexHTML: true
}) => {
  const files = await listFiles(resolveFn(assets));
  const isFSSepUnsafe = sep !== URL_PATH_SEP;
  if (prefix === URL_PATH_SEP) prefix = "";
  const shouldIgnore = (file) => {
    if (!ignorePatterns.length) return false;
    return ignorePatterns.find((pattern) => {
      if (typeof pattern === "string") return pattern.includes(file);
      else return pattern.test(file);
    });
  };
  const app = new Elysia({
    name: "static",
    seed: {
      assets,
      prefix,
      staticLimit,
      alwaysStatic,
      ignorePatterns,
      noExtension,
      enableDecodeURI,
      resolve: resolve2.toString(),
      headers,
      noCache,
      maxAge,
      directive,
      indexHTML
    }
  });
  if (alwaysStatic || process.env.ENV === "production" && files.length <= staticLimit)
    for (let i = 0; i < files.length; i++) {
      const filePath = files[i];
      if (!filePath || shouldIgnore(filePath)) continue;
      let fileName = filePath.replace(resolve2(), "").replace(`${assets}${sep}`, "");
      if (noExtension) {
        const temp = fileName.split(".");
        temp.splice(-1);
        fileName = temp.join(".");
      }
      const file = Bun.file(filePath);
      const etag = await generateETag(file);
      const pathName = isFSSepUnsafe ? prefix + fileName.split(sep).join(URL_PATH_SEP) : join(prefix, fileName);
      app.get(
        pathName,
        noCache ? new Response(file, {
          headers
        }) : async ({ headers: reqHeaders }) => {
          if (await isCached(reqHeaders, etag, filePath)) {
            return new Response(null, {
              status: 304,
              headers
            });
          }
          headers["Etag"] = etag;
          headers["Cache-Control"] = directive;
          if (maxAge !== null)
            headers["Cache-Control"] += `, max-age=${maxAge}`;
          return new Response(file, {
            headers
          });
        }
      );
      if (indexHTML && pathName.endsWith("/index.html"))
        app.get(
          join(prefix, pathName.replace("/index.html", "")),
          noCache ? new Response(file, {
            headers
          }) : async ({ headers: reqHeaders }) => {
            if (await isCached(reqHeaders, etag, pathName)) {
              return new Response(null, {
                status: 304,
                headers
              });
            }
            headers["Etag"] = etag;
            headers["Cache-Control"] = directive;
            if (maxAge !== null)
              headers["Cache-Control"] += `, max-age=${maxAge}`;
            return new Response(file, {
              headers
            });
          }
        );
    }
  else {
    if (!app.router.history.find(
      ({ method, path }) => path === `${prefix}/*` && method === "GET"
    ))
      app.onError(() => {
      }).get(
        `${prefix}/*`,
        async ({ params, headers: reqHeaders }) => {
          let path = enableDecodeURI ? decodeURI(`${assets}/${decodeURI(params["*"])}`) : `${assets}/${params["*"]}`;
          if (isFSSepUnsafe) {
            path = path.replace(URL_PATH_SEP, sep);
          }
          if (shouldIgnore(path)) throw new NotFoundError();
          try {
            let status = statCache.get(path);
            if (!status) {
              status = await stat2(path);
              statCache.set(path, status);
            }
            let file = fileCache.get(
              path
            );
            if (!file) {
              if (status.isDirectory()) {
                let hasCache = false;
                if (indexHTML && (hasCache = htmlCache.get(
                  `${path}${sep}index.html`
                ) ?? await fileExists(
                  `${path}${sep}index.html`
                ))) {
                  if (hasCache === void 0)
                    htmlCache.set(
                      `${path}${sep}index.html`,
                      true
                    );
                  file = Bun.file(`${path}${sep}index.html`);
                } else {
                  if (indexHTML && hasCache === void 0)
                    htmlCache.set(
                      `${path}${sep}index.html`,
                      false
                    );
                  throw new NotFoundError();
                }
              }
              file ??= Bun.file(path);
              fileCache.set(path, file);
            }
            if (noCache)
              return new Response(file, {
                headers
              });
            const etag = await generateETag(file);
            if (await isCached(reqHeaders, etag, path))
              return new Response(null, {
                status: 304,
                headers
              });
            headers["Etag"] = etag;
            headers["Cache-Control"] = directive;
            if (maxAge !== null)
              headers["Cache-Control"] += `, max-age=${maxAge}`;
            return new Response(file, {
              headers
            });
          } catch (error) {
            throw new NotFoundError();
          }
        }
      );
  }
  return app;
};
var src_default = staticPlugin;
export {
  src_default as default,
  staticPlugin
};
