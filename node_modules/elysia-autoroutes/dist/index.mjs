import { Elysia } from 'elysia';
import path from 'node:path';
import fs from 'node:fs';

function handleParameters(token) {
    const replacements = [
        // Clean the url extensions
        {
            regex: /\.(ts|js|mjs|cjs|jsx|tsx)$/u,
            replacement: ''
        },
        // Handle wild card based routes - users/[...id]/profile.ts -> users/*/profile
        {
            regex: /\[\.\.\..+\]/gu,
            replacement: '*'
        },
        // Handle generic square bracket based routes - users/[id]/index.ts -> users/:id
        {
            regex: /\[(.*?)\]/gu,
            replacement: (_subString, match)=>`:${match}`
        },
        // Handle the case when multiple parameters are present in one file
        // users / [id] - [name].ts to users /: id -:name and users / [id] - [name] / [age].ts to users /: id -: name /: age
        {
            regex: /\]-\[/gu,
            replacement: '-:'
        },
        {
            regex: /\]\//gu,
            replacement: '/'
        },
        {
            regex: /\[/gu,
            replacement: ''
        },
        {
            regex: /\]/gu,
            replacement: ''
        }
    ];
    let url = token;
    for (const { regex, replacement } of replacements)url = url.replace(regex, replacement);
    return url;
}

function transformPathToUrl(filePath) {
    const url = `/${filePath}` // Add leading slash to the URL
    ;
    if (url.length === 1) return url // If the URL is just "/", return it as is
    ;
    const resultUrl = url.split(path.sep).map((part)=>handleParameters(part)).join('/') // Map and join the URL parts using handleParameters function
    ;
    // Remove 'index' from the end of the URL if it exists
    let finalUrl = resultUrl.endsWith('index') ? resultUrl.replace(/\/?index$/, '') : resultUrl;
    // Remove the trailing slash from the URL if it exists
    finalUrl = finalUrl.replace(/\/$/, '');
    // If the URL is empty, replace it with the root path "/"
    if (finalUrl.length === 0) return '/';
    // Replace multiple slashes with a single slash
    return finalUrl.replace(/\/{2,}/g, '/');
}

async function autoload(app, routesDir, generateTags) {
    const dirPath = getDirPath(routesDir);
    if (!fs.existsSync(dirPath)) throw new Error(`Directory "${dirPath}" does not exist`);
    if (!fs.statSync(dirPath).isDirectory()) throw new Error(`"${dirPath}" is not a directory.`);
    const router = new Bun.FileSystemRouter({
        style: 'nextjs',
        dir: dirPath
    });
    const routeModules = {};
    const importPromises = [];
    for (const [nextRouteName, file] of Object.entries(router.routes)){
        const routeName = transformPathToUrl(nextRouteName);
        importPromises.push(import(file).then((routeModule)=>{
            routeModules[routeName] = routeModule.default;
        }));
    }
    await Promise.all(importPromises);
    for (const [routeName, routeModule] of Object.entries(routeModules)){
        app.group(routeName, (app)=>{
            const mappedApp = routeModule(app);
            if (generateTags) {
                mappedApp.routes.forEach((route)=>{
                    if (route.hooks.detail) route.hooks.detail.tags = [
                        ...route.hooks.detail.tags || [],
                        routeName
                    ];
                    else Object.assign(route.hooks, {
                        detail: {
                            tags: [
                                routeName
                            ]
                        }
                    });
                });
            }
            return mappedApp;
        });
    }
}
function getDirPath(dir) {
    let dirPath;
    if (path.isAbsolute(dir)) dirPath = dir;
    else if (path.isAbsolute(process.argv[1])) dirPath = path.join(process.argv[1], '..', dir);
    else dirPath = path.join(process.cwd(), process.argv[1], '..', dir);
    return dirPath;
}

function autoroutes(options) {
    const { routesDir, prefix, generateTags } = {
        ...options,
        routesDir: options?.routesDir ?? './routes',
        prefix: options?.prefix ?? '',
        generateTags: options?.generateTags ?? true
    };
    const seed = {
        routesDir,
        prefix
    };
    const autoroutesPlugin = new Elysia({
        prefix,
        name: `autoroutes-${JSON.stringify(seed)}`,
        seed
    });
    return async function plugin(app) {
        await autoload(autoroutesPlugin, routesDir, generateTags);
        app.use(autoroutesPlugin);
        return app;
    };
}

export { autoroutes };
